// --- Start of script: Assets/Logic/ViewmodelRig.cs ---
using UnityEngine;

public class ViewmodelSwayAnimation : MonoBehaviour
{
    [Header("References")]
    [SerializeField] private PlayerLook playerLook;
    [SerializeField] private Transform weaponCamera;

    [Header("Sway Settings")]
    public float swayMultiplier = 0.02f;
    public float maxSwayX = 0.06f;
    public float maxSwayY = 0.06f;
    public float swaySmoothness = 8f;

    private Vector3 initialCamLocalPosition;
    private Vector2 smoothedSwayInput;
    private Vector2 previousLookInput;

    private void Awake()
    {
        if (playerLook == null)
        {
            Debug.LogError("[PlayerLook] Player look is not assigned!");
        }

        if (weaponCamera == null)
        {
            Debug.LogError("[ViewmodelRig] Weapon Camera is not assigned!");
        }
    }

    private void Start()
    {
        if (weaponCamera != null)
        {
            initialCamLocalPosition = weaponCamera.localPosition;
        }
    }

    private void LateUpdate()
    {
        if (playerLook == null || weaponCamera == null)
            return;

        // === Calculate Mouse Delta ===
        Vector2 currentLookInput = new Vector2(Input.GetAxisRaw("Mouse X"), Input.GetAxisRaw("Mouse Y"));
        Vector2 rawDelta = currentLookInput - previousLookInput;
        previousLookInput = currentLookInput;

        smoothedSwayInput = Vector2.Lerp(smoothedSwayInput, rawDelta, Time.deltaTime * swaySmoothness);

        Vector3 swayOffset = new Vector3(
            Mathf.Clamp(-smoothedSwayInput.x * swayMultiplier, -maxSwayX, maxSwayX), // ✅ Inverted X
            Mathf.Clamp(-smoothedSwayInput.y * swayMultiplier, -maxSwayY, maxSwayY),
            0f
        );

        // === Apply position sway only ===
        weaponCamera.localPosition = Vector3.Lerp(
            weaponCamera.localPosition,
            initialCamLocalPosition + swayOffset,
            Time.deltaTime * swaySmoothness
        );
    }
}
// --- End of script: Assets/Logic/ViewmodelRig.cs ---

// --- Start of script: Assets/Logic/WorldInteractor.cs ---
using UnityEngine;

// Interface for objects that can be interacted with using the 'Interact' key (e.g., 'E')
public interface IInteractable
{
    // Pass PlayerManager if interaction needs player context (inventory, stats, etc.)
    void Interact(PlayerManager player); 
    // Alternatively: void Interact(GameObject interactor); for more generic interaction
}

public class WorldInteractor : MonoBehaviour
{
    [Header("Interaction Settings")]
    [Tooltip("Maximum distance to check for interactable objects.")]
    [SerializeField] private float interactionRange = 3f;

    [Tooltip("Assign the specific layer(s) containing objects with IInteractable components (e.g., buttons, switches, NPCs). This should be different from layers used for grabbing parts.")]
    [SerializeField] private LayerMask interactableLayer = 0; // <<--- ASSIGN THIS IN INSPECTOR

    [Header("References")]
    [Tooltip("Reference to the PlayerLook component for raycasting direction.")]
    [SerializeField] private PlayerLook playerLook; // Reference needed for ray origin/direction

    // Reference to PlayerManager, usually obtained from parent or passed in
    private PlayerManager playerManager;

    private void Awake()
    {
        // Find PlayerManager (e.g., in parent)
        playerManager = GetComponentInParent<PlayerManager>();
        if (playerManager == null)
        {
            Debug.LogError("[WorldInteractor] Could not find PlayerManager in parent!", this);
        }

        // Attempt to get PlayerLook if not assigned
        if (playerLook == null && playerManager != null)
        {
            playerLook = playerManager.Look;
        }
        // Final check if PlayerLook is still missing
        if (playerLook == null)
        {
             Debug.LogError("[WorldInteractor] PlayerLook component is not assigned and could not be found via PlayerManager!", this);
             this.enabled = false; // Disable if look component is missing
             return;
        }

        // Ensure the interactable layer mask is assigned in the editor
         if (interactableLayer.value == 0) { // LayerMask value is 0 if unset or set to 'Nothing'
              Debug.LogWarning($"[WorldInteractor] Interactable LayerMask is not set on {gameObject.name}. Interaction will likely fail. Assign a layer in the Inspector.", this);
              // You could optionally default it here, but it's better to force assignment:
              // interactableLayer = LayerMask.GetMask("Interactable"); // Example if you have a layer named "Interactable"
              // interactableLayer = 1; // Default layer (usually not desired)
         }
    }

    // This method is called by PlayerManager when the 'Interact' input action is performed.
    public void OnInteractPressed()
    {
        if (playerManager == null || playerLook == null || interactableLayer.value == 0) {
            // Don't interact if setup is incomplete or layer mask is unassigned
            if (interactableLayer.value == 0) Debug.LogWarning("[WorldInteractor] Cannot interact: Interactable LayerMask not set.", this);
            return;
        }

        TryInteract();
    }

    private void TryInteract()
    {
        // Use PlayerLook to get the camera's ray for interaction
        Ray ray = playerLook.GetLookRay();

        // Raycast using the dedicated interactableLayer mask assigned in the inspector
        if (Physics.Raycast(ray, out RaycastHit hit, interactionRange, interactableLayer, QueryTriggerInteraction.Collide))
        {
            // Check if the hit object has an IInteractable component
            // Using GetComponentInParent allows interaction triggers on child colliders
            if (hit.collider.TryGetComponent<IInteractable>(out IInteractable interactable)) 
            // Alternatively, use GetComponentInParent if interactable logic is on a parent object:
            // IInteractable interactable = hit.collider.GetComponentInParent<IInteractable>();
            // if (interactable != null)
            {
                // Found an interactable object, call its Interact method
                interactable.Interact(playerManager);
                // Optional: Debug log
                // Debug.Log($"[WorldInteractor] Interacted with {hit.collider.name}");
            }
            // else { Debug.Log($"[WorldInteractor] Hit {hit.collider.name} on Interactable layer, but it has no IInteractable component."); }
        }
        // else { Debug.DrawRay(ray.origin, ray.direction * interactionRange, Color.red, 0.5f); } // Optional: Visualize failed interaction ray
    }
}
// --- End of script: Assets/Logic/WorldInteractor.cs ---

// --- Start of script: Assets/Logic/Debug/DebugForwardLine.cs ---
using UnityEngine;

public class DebugForwardLine : MonoBehaviour
{
    [SerializeField] private float lineLength = 20f;
    private Color randomColor;

    private void Start()
    {
        randomColor = new Color(Random.value, Random.value, Random.value);
    }

    private void Update()
    {
        Debug.DrawLine(transform.position, transform.position + transform.forward * lineLength, randomColor);
    }
}
// --- End of script: Assets/Logic/Debug/DebugForwardLine.cs ---

// --- Start of script: Assets/Logic/Enemies/SlimeMob.cs ---
using UnityEngine;

public interface IDamageable
{
    void TakeDamage(float amount, Vector3 hitPoint, Vector3 hitDirection);
}

[RequireComponent(typeof(Rigidbody))]
public class SlimeMob : MonoBehaviour, IDamageable
{
    [SerializeField] private float maxHealth = 100f;
    private float currentHealth;

    [Header("Jump Settings")]
    [SerializeField] private float jumpForce = 4f;
    [SerializeField] private float jumpCooldown = 2f;
    [SerializeField] private float jumpHorizontalForce = 1.5f;
    [SerializeField] private float jumpRandomness = 1f;

    [Header("Ground Check")]
    [SerializeField] private float groundCheckDistance = 1.1f;

    private Rigidbody rb;
    private float nextJumpTime;

    private void Awake()
    {
        rb = GetComponent<Rigidbody>();
        currentHealth = maxHealth;
    }

    private void Update()
    {
        if (Time.time >= nextJumpTime && IsGrounded())
        {
            Jump();
            nextJumpTime = Time.time + jumpCooldown + Random.Range(-jumpRandomness, jumpRandomness);
        }
    }

    private void Jump()
    {
        // Random horizontal direction
        Vector3 horizontalDir = new Vector3(
            Random.Range(-1f, 1f),
            0f,
            Random.Range(-1f, 1f)
        ).normalized;

        Vector3 jumpVector = horizontalDir * jumpHorizontalForce + Vector3.up * jumpForce;

        // Rotate slime to face jump direction
        if (horizontalDir != Vector3.zero)
        {
            Quaternion targetRotation = Quaternion.LookRotation(horizontalDir);
            transform.rotation = targetRotation;
        }

        rb.AddForce(jumpVector, ForceMode.Impulse);
    }

    private bool IsGrounded()
    {
        return Physics.Raycast(transform.position + Vector3.up, Vector3.down, groundCheckDistance);
    }

    public void TakeDamage(float amount, Vector3 hitPoint, Vector3 hitDirection)
    {
        currentHealth -= amount;
        Debug.Log($"Slime took {amount} damage. Remaining HP: {currentHealth}");

        // Optional: play hit animation, spawn particles

        if (currentHealth <= 0f)
        {
            Die();
        }
    }

    private void Die()
    {
        Debug.Log("Slime died!");
        Destroy(gameObject);
    }
}
// --- End of script: Assets/Logic/Enemies/SlimeMob.cs ---

// --- Start of script: Assets/Logic/Input/PlayerInputHandler.cs ---
// --- Start of script: Assets/Logic/Input/PlayerInputHandler.cs ---
using UnityEngine;
using UnityEngine.InputSystem;
using System;

[RequireComponent(typeof(PlayerInput))]
public class PlayerInputHandler : MonoBehaviour
{
    private PlayerInput playerInput;

    // Gameplay Events
    public event Action<Vector2> MovePerformed;
    public event Action JumpPerformed;
    public event Action SprintStarted, SprintCanceled;
    public event Action CrouchStarted, CrouchCanceled;
    public event Action SlowWalkStarted, SlowWalkCanceled;
    public event Action Fire1Started, Fire1Performed, Fire1Canceled;
    public event Action Fire2Started, Fire2Performed, Fire2Canceled;
    public event Action UtilityPerformed, UtilityCanceled;
    public event Action ReloadPerformed;
    public event Action InteractPerformed;
    public event Action StorePerformed;
    public event Action<Vector2> LookPerformed;          // For camera look
    public event Action<Vector2> RotateDeltaPerformed; // For item rotation delta (driven by Look when MMB is held)
    public event Action<float> ToolbarScrollPerformed;
    public event Action<int> ToolbarSlotSelected;
    public event Action ToggleInventoryPerformed;
    public event Action ToggleMenuPerformed;
    
    public event Action RotateHeldStarted;  // For MMB press
    public event Action RotateHeldEnded;    // For MMB release

    // UI Control Events
    public event Action UITabNavigatePerformed;
    public event Action UICancelPerformed;

    // State Properties
    public bool IsSprintHeld { get; private set; }
    public bool IsCrouchHeld { get; private set; }
    public bool IsSlowWalkHeld { get; private set; }
    public bool IsFire1Held { get; private set; }
    public bool IsFire2Held { get; private set; }
    public bool IsRotateHeld { get; private set; } // Tracks if MMB ("RotateHeld" action) is currently pressed

    void Awake()
    {
        playerInput = GetComponent<PlayerInput>();
        if (playerInput == null) { Debug.LogError("PlayerInput missing on PlayerInputHandler!", this); this.enabled = false; return; }
    }

    private void OnEnable()
    {
        if (playerInput == null || playerInput.actions == null) return;

        SubscribeToAction("Gameplay", "Move", performed: HandleMovePerformed, canceled: HandleMoveCanceled);
        SubscribeToAction("Gameplay", "Look", performed: HandleLookPerformed); // Look input drives both camera and item rotation delta
        SubscribeToAction("Gameplay", "Jump", performed: HandleJumpPerformed);
        SubscribeToAction("Gameplay", "Sprint", started: HandleSprintStarted, canceled: HandleSprintCanceled);
        SubscribeToAction("Gameplay", "Crouch", started: HandleCrouchStarted, canceled: HandleCrouchCanceled);
        SubscribeToAction("Gameplay", "SlowWalk", started: HandleSlowWalkStarted, canceled: HandleSlowWalkCanceled);
        SubscribeToAction("Gameplay", "Fire1", started: HandleFire1Started, performed: HandleFire1Performed, canceled: HandleFire1Canceled);
        SubscribeToAction("Gameplay", "Fire2", started: HandleFire2Started, performed: HandleFire2Performed, canceled: HandleFire2Canceled);
        SubscribeToAction("Gameplay", "Utility", performed: HandleUtilityPerformed, canceled: HandleUtilityCanceled);
        SubscribeToAction("Gameplay", "Reload", performed: HandleReloadPerformed);
        SubscribeToAction("Gameplay", "Interact", performed: HandleInteractPerformed);
        SubscribeToAction("Gameplay", "Store", performed: HandleStorePerformed);
        SubscribeToAction("Gameplay", "ToolbarScroll", performed: HandleToolbarScrollPerformed);
        SubscribeToAction("Gameplay", "ToggleInventory", performed: HandleToggleInventoryPerformed);
        SubscribeToAction("Gameplay", "ToggleMenu", performed: HandleToggleMenuPerformed);
        SubscribeToAction("Gameplay", "RotateHeld", started: HandleRotateHeldStartedCallback, canceled: HandleRotateHeldEndedCallback);


        InputActionMap gameplayMap = playerInput.actions.FindActionMap("Gameplay");
        if (gameplayMap != null) {
            for (int i = 1; i <= 9; i++) {
                InputAction action = gameplayMap.FindAction($"ToolbarSlot{i}");
                if (action != null) { int slotIndex = i - 1; action.performed += ctx => HandleToolbarSlotSelected(slotIndex); }
            }
        } else { Debug.LogError("Gameplay Action Map not found!", this); }

        SubscribeToAction("UI", "Cancel", performed: HandleUICancelPerformed);
        SubscribeToAction("UI", "UITabNavigate", performed: HandleUITabNavigatePerformed);
    }

    private void OnDisable()
    {
        if (playerInput == null || playerInput.actions == null) return;

        UnsubscribeFromAction("Gameplay", "Move", performed: HandleMovePerformed, canceled: HandleMoveCanceled);
        UnsubscribeFromAction("Gameplay", "Look", performed: HandleLookPerformed);
        UnsubscribeFromAction("Gameplay", "Jump", performed: HandleJumpPerformed);
        UnsubscribeFromAction("Gameplay", "Sprint", started: HandleSprintStarted, canceled: HandleSprintCanceled);
        UnsubscribeFromAction("Gameplay", "Crouch", started: HandleCrouchStarted, canceled: HandleCrouchCanceled);
        UnsubscribeFromAction("Gameplay", "SlowWalk", started: HandleSlowWalkStarted, canceled: HandleSlowWalkCanceled);
        UnsubscribeFromAction("Gameplay", "Fire1", started: HandleFire1Started, performed: HandleFire1Performed, canceled: HandleFire1Canceled);
        UnsubscribeFromAction("Gameplay", "Fire2", started: HandleFire2Started, performed: HandleFire2Performed, canceled: HandleFire2Canceled);
        UnsubscribeFromAction("Gameplay", "Utility", performed: HandleUtilityPerformed, canceled: HandleUtilityCanceled);
        UnsubscribeFromAction("Gameplay", "Reload", performed: HandleReloadPerformed);
        UnsubscribeFromAction("Gameplay", "Interact", performed: HandleInteractPerformed);
        UnsubscribeFromAction("Gameplay", "Store", performed: HandleStorePerformed);
        UnsubscribeFromAction("Gameplay", "ToolbarScroll", performed: HandleToolbarScrollPerformed);
        UnsubscribeFromAction("Gameplay", "ToggleInventory", performed: HandleToggleInventoryPerformed);
        UnsubscribeFromAction("Gameplay", "ToggleMenu", performed: HandleToggleMenuPerformed);
        UnsubscribeFromAction("Gameplay", "RotateHeld", started: HandleRotateHeldStartedCallback, canceled: HandleRotateHeldEndedCallback);

        InputActionMap gameplayMap = playerInput.actions?.FindActionMap("Gameplay");
        if (gameplayMap != null) {
            for (int i = 1; i <= 9; i++) {
                InputAction action = gameplayMap.FindAction($"ToolbarSlot{i}");
                if (action != null) { int slotIndex = i - 1; action.performed -= ctx => HandleToolbarSlotSelected(slotIndex); }
            }
        }

        UnsubscribeFromAction("UI", "Cancel", performed: HandleUICancelPerformed);
        UnsubscribeFromAction("UI", "UITabNavigate", performed: HandleUITabNavigatePerformed);
    }

    private void HandleMovePerformed(InputAction.CallbackContext ctx) => MovePerformed?.Invoke(ctx.ReadValue<Vector2>());
    private void HandleMoveCanceled(InputAction.CallbackContext ctx) => MovePerformed?.Invoke(Vector2.zero);
    
    private void HandleLookPerformed(InputAction.CallbackContext ctx) {
        if (Time.timeScale < 0.01f) return;
        Vector2 lookDelta = ctx.ReadValue<Vector2>();

        LookPerformed?.Invoke(lookDelta); // Always send for camera look (PlayerManager will gate it if IsRotateHeld)
        
        if (IsRotateHeld) { // If MMB is held, also send this delta for item rotation
            RotateDeltaPerformed?.Invoke(lookDelta);
        }
    }

    private void HandleJumpPerformed(InputAction.CallbackContext ctx) => JumpPerformed?.Invoke();
    private void HandleSprintStarted(InputAction.CallbackContext ctx) { SprintStarted?.Invoke(); IsSprintHeld = true; }
    private void HandleSprintCanceled(InputAction.CallbackContext ctx) { SprintCanceled?.Invoke(); IsSprintHeld = false; }
    private void HandleCrouchStarted(InputAction.CallbackContext ctx) { CrouchStarted?.Invoke(); IsCrouchHeld = true; }
    private void HandleCrouchCanceled(InputAction.CallbackContext ctx) { CrouchCanceled?.Invoke(); IsCrouchHeld = false; }
    private void HandleSlowWalkStarted(InputAction.CallbackContext ctx) { SlowWalkStarted?.Invoke(); IsSlowWalkHeld = true; }
    private void HandleSlowWalkCanceled(InputAction.CallbackContext ctx) { SlowWalkCanceled?.Invoke(); IsSlowWalkHeld = false; }
    private void HandleFire1Started(InputAction.CallbackContext ctx) { Fire1Started?.Invoke(); IsFire1Held = true; }
    private void HandleFire1Performed(InputAction.CallbackContext ctx) => Fire1Performed?.Invoke();
    private void HandleFire1Canceled(InputAction.CallbackContext ctx) { Fire1Canceled?.Invoke(); IsFire1Held = false; }
    private void HandleFire2Started(InputAction.CallbackContext ctx) { Fire2Started?.Invoke(); IsFire2Held = true; }
    private void HandleFire2Performed(InputAction.CallbackContext ctx) => Fire2Performed?.Invoke();
    private void HandleFire2Canceled(InputAction.CallbackContext ctx) { Fire2Canceled?.Invoke(); IsFire2Held = false; }
    private void HandleUtilityPerformed(InputAction.CallbackContext ctx) => UtilityPerformed?.Invoke();
    private void HandleUtilityCanceled(InputAction.CallbackContext ctx) => UtilityCanceled?.Invoke();
    private void HandleReloadPerformed(InputAction.CallbackContext ctx) => ReloadPerformed?.Invoke();
    private void HandleInteractPerformed(InputAction.CallbackContext ctx) => InteractPerformed?.Invoke();
    private void HandleStorePerformed(InputAction.CallbackContext ctx) => StorePerformed?.Invoke();
    private void HandleToolbarScrollPerformed(InputAction.CallbackContext ctx) {
        float scrollY = ctx.ReadValue<Vector2>().y;
        if (Mathf.Abs(scrollY) > 0.01f) ToolbarScrollPerformed?.Invoke(Mathf.Sign(scrollY));
    }
    private void HandleToolbarSlotSelected(int slotIndex) => ToolbarSlotSelected?.Invoke(slotIndex);
    private void HandleToggleInventoryPerformed(InputAction.CallbackContext ctx) => ToggleInventoryPerformed?.Invoke();
    private void HandleToggleMenuPerformed(InputAction.CallbackContext ctx) => ToggleMenuPerformed?.Invoke();
    private void HandleUICancelPerformed(InputAction.CallbackContext ctx) => UICancelPerformed?.Invoke();
    private void HandleUITabNavigatePerformed(InputAction.CallbackContext ctx) => UITabNavigatePerformed?.Invoke();

    private void HandleRotateHeldStartedCallback(InputAction.CallbackContext ctx) {
        IsRotateHeld = true;
        RotateHeldStarted?.Invoke();
    }
    private void HandleRotateHeldEndedCallback(InputAction.CallbackContext ctx) {
        IsRotateHeld = false;
        RotateHeldEnded?.Invoke();
    }

    public void EnableGameplayControls() => playerInput?.SwitchCurrentActionMap("Gameplay");
    public void EnableUIControls() => playerInput?.SwitchCurrentActionMap("UI");

    private void SubscribeToAction(string mapName, string actionName, 
                                   Action<InputAction.CallbackContext> performed = null, 
                                   Action<InputAction.CallbackContext> canceled = null, 
                                   Action<InputAction.CallbackContext> started = null) {
        var action = playerInput?.actions?.FindActionMap(mapName)?.FindAction(actionName);
        if (action != null) {
            if (started != null) action.started += started;
            if (performed != null) action.performed += performed;
            if (canceled != null) action.canceled += canceled;
        } else { Debug.LogWarning($"Action '{actionName}' in map '{mapName}' not found during subscription.", this); }
    }

    private void UnsubscribeFromAction(string mapName, string actionName, 
                                     Action<InputAction.CallbackContext> performed = null, 
                                     Action<InputAction.CallbackContext> canceled = null, 
                                     Action<InputAction.CallbackContext> started = null) {
        if (playerInput?.actions == null) return;
        var action = playerInput.actions.FindActionMap(mapName)?.FindAction(actionName);
        if (action != null) {
             if (started != null) action.started -= started;
             if (performed != null) action.performed -= performed;
             if (canceled != null) action.canceled -= canceled;
        }
    }
}
// --- End of script: Assets/Logic/Input/PlayerInputHandler.cs ---
// --- End of script: Assets/Logic/Input/PlayerInputHandler.cs ---

// --- Start of script: Assets/Logic/Items/WorldItem.cs ---
// In Assets/Scripts/Items/WorldItem.cs
using UnityEngine;

/// <summary>
/// Represents an item existing physically in the world (dropped).
/// Allows it to be picked up via the IGrabbable interface.
/// </summary>
[RequireComponent(typeof(Rigidbody))] // Dropped items should generally have physics
[RequireComponent(typeof(Collider))] // And a collider
public class WorldItem : MonoBehaviour, IGrabbable {

    [Tooltip("The static ItemData definition for this item.")]
    [SerializeField] private ItemData itemDefinition;

    // The specific instance data (durability, ammo etc.)
    // This needs to be *set* when the item is dropped from inventory.
    private InventoryItem _instanceItemData;

    private Rigidbody _rigidbody;
    private Collider[] _colliders;

    void Awake() {
        _rigidbody = GetComponent<Rigidbody>();
        _colliders = GetComponentsInChildren<Collider>(true);
         if (_rigidbody == null) Debug.LogError($"WorldItem on {gameObject.name} missing Rigidbody!", this);
         if (_colliders.Length == 0) Debug.LogError($"WorldItem on {gameObject.name} missing Collider!", this);
    }

    /// <summary>
    /// Call this immediately after instantiating the WorldItem prefab
    /// when dropping an item from inventory.
    /// </summary>
    public void Initialize(InventoryItem sourceInventoryItem) {
        if (sourceInventoryItem == null || sourceInventoryItem.data == null) {
            Debug.LogError($"WorldItem Initialize called with invalid InventoryItem!", this);
            Destroy(gameObject); // Destroy if invalid data
            return;
        }
        this.itemDefinition = sourceInventoryItem.data; // Set static data ref
        this._instanceItemData = sourceInventoryItem; // Store the whole item (with runtime state)

        // Update visuals if necessary based on item data/state
        gameObject.name = $"WorldItem_{itemDefinition.itemName}";
        MeshFilter mf = GetComponentInChildren<MeshFilter>();
        MeshRenderer mr = GetComponentInChildren<MeshRenderer>();
        // TODO: Set mesh/material based on itemDefinition or visual variants?
        // Example: if(mf != null && itemDefinition.worldMesh != null) mf.sharedMesh = itemDefinition.worldMesh;
    }


    // --- IGrabbable Implementation ---
    public InventoryItem GetInventoryItemData() {
        // Return the stored instance data (which includes runtime state)
        // If _instanceItemData is null, create a default one ONLY if itemDefinition exists
        if (_instanceItemData == null && itemDefinition != null) {
            // This might happen if placed in scene without Initialize being called
             Debug.LogWarning($"WorldItem {gameObject.name} returning default InventoryItem as instance data was null.", this);
             // Need a way to create default runtime state if ItemData requires it.
             // For now, just return a basic one. This path should ideally be avoided.
             _instanceItemData = new InventoryItem(itemDefinition);
        }
        return _instanceItemData;
    }

    public Transform GetTransform() {
        return this.transform;
    }

    public virtual bool CanGrab() {
        // Most world items can always be grabbed unless specific logic added
        return true;
    }

    public virtual void OnGrabbed(Transform grabberTransform) {
        if (_rigidbody != null) _rigidbody.isKinematic = true;
        if (_colliders != null) foreach (var col in _colliders) if (col != null) col.enabled = false;
        transform.SetParent(grabberTransform);
    }

    public virtual void OnDropped(Vector3 dropVelocity) {
        transform.SetParent(null);
        if (_colliders != null) foreach (var col in _colliders) if (col != null) col.enabled = true;
        if (_rigidbody != null) {
            _rigidbody.isKinematic = false;
            _rigidbody.linearVelocity = dropVelocity;
        }
    }

    public virtual void OnStored() {
        // Called by HandsBehavior just before Destroy(gameObject)
    }
    // --- End IGrabbable ---
}
// --- End of script: Assets/Logic/Items/WorldItem.cs ---

// --- Start of script: Assets/Logic/ItemSpawners/EngineItemSpawner.cs ---
using UnityEngine;

/// <summary>
/// Spawns an Engine, using the 'initialStateTemplate' configured directly
/// in the Inspector as the source for the spawned engine's runtime state.
/// </summary>
public class EngineItemSpawner : ItemSpawner { // Inherit from base

    [Header("--- Engine Initial State Template ---")]
    [Tooltip("Configure the desired starting state for the spawned engine here. This exact state will be cloned.")]
    [SerializeField] private EngineRuntimeState initialStateTemplate = new EngineRuntimeState(); // The template you edit!

    /// <summary>
    /// OVERRIDE: Creates the InventoryItem using the base itemToSpawn data
    /// and a CLONE of the initialStateTemplate configured in the Inspector.
    /// </summary>
    protected override InventoryItem GetInitialInventoryItem() {
        if (itemToSpawn == null) {
             Debug.LogError($"[{gameObject.name} EngineItemSpawner] 'Item To Spawn' (EngineData) is not assigned!", this);
             return null;
        }
        if (!(itemToSpawn is EngineData)) {
             Debug.LogError($"[{gameObject.name} EngineItemSpawner] Assigned 'Item To Spawn' is not EngineData!", this);
             return null;
        }

        // --- Cloning ---
        EngineRuntimeState stateClone = null;
        if (initialStateTemplate != null) {
            // Manual field-by-field clone is safest
            stateClone = new EngineRuntimeState {
                CurrentDurability = initialStateTemplate.CurrentDurability,
                CurrentWear = initialStateTemplate.CurrentWear,
                currentEngineOilLiters = initialStateTemplate.currentEngineOilLiters,
                currentCoolantLiters = initialStateTemplate.currentCoolantLiters,
                totalOperatingHours = initialStateTemplate.totalOperatingHours,
                isSeized = initialStateTemplate.isSeized,
                currentTemperatureCelsius = initialStateTemplate.currentTemperatureCelsius
            };
        } else {
            // If user set template to null, fall back to default creation
            Debug.LogWarning($"[{gameObject.name} EngineItemSpawner] Initial State Template is null. Creating default engine state.", this);
            stateClone = (EngineRuntimeState)CreateDefaultStateForItem(itemToSpawn); // Use base helper
             if (stateClone == null) { // Check if default creation failed
                 Debug.LogError($"[{gameObject.name} EngineItemSpawner] Failed to create default engine state!", this);
                 return null;
             }
        }
        // --- End Cloning ---

        // Create the final InventoryItem with the cloned state
        return new InventoryItem(itemToSpawn, stateClone);
    }

    /// <summary>
    /// EDITOR VALIDATION: Ensure the assigned item is EngineData.
    /// </summary>
    protected override void OnValidate() {
        base.OnValidate(); // Check if itemToSpawn is assigned
        if (itemToSpawn != null && !(itemToSpawn is EngineData)) {
             Debug.LogError($"[{gameObject.name} EngineItemSpawner] Assigned 'Item To Spawn' ({itemToSpawn.name}) is NOT EngineData!", this);
        }
         if (initialStateTemplate == null) {
             Debug.LogWarning($"[{gameObject.name} EngineItemSpawner] 'Initial State Template' is null. Default state will be used.", this);
         }
    }
}
// --- End of script: Assets/Logic/ItemSpawners/EngineItemSpawner.cs ---

// --- Start of script: Assets/Logic/ItemSpawners/FirearmItemSpawner.cs ---
using UnityEngine;

/// <summary>
/// Auto-generated spawner for FirearmItemData. Configures the initial state
/// (FirearmRuntimeState) directly in the Inspector via the 'initialStateTemplate' field.
/// </summary>
public class FirearmItemSpawner : ItemSpawner {

    [Header("--- FirearmRuntimeState Initial State Template ---")]
    [Tooltip("Configure the desired starting state. This exact state will be cloned.")]
    [SerializeField] private FirearmRuntimeState initialStateTemplate = new FirearmRuntimeState();

    /// <summary>
    /// OVERRIDE: Creates the InventoryItem using the base itemToSpawn data
    /// and a CLONE of the initialStateTemplate.
    /// </summary>
    protected override InventoryItem GetInitialInventoryItem() {
        if (itemToSpawn == null) { Debug.LogError($"[{gameObject.name} FirearmItemSpawner] 'Item To Spawn' not assigned!", this); return null; }
        if (!(itemToSpawn is FirearmItemData)) { Debug.LogError($"[{gameObject.name} FirearmItemSpawner] Assigned 'Item To Spawn' is not FirearmItemData!", this); return null; }

        FirearmRuntimeState stateClone = null;
        if (initialStateTemplate != null) {
            if (initialStateTemplate is ICloneableRuntimeState templateCloneable) {
                 stateClone = templateCloneable.Clone() as FirearmRuntimeState;
                 if (stateClone == null) { Debug.LogError($"[{gameObject.name} FirearmItemSpawner] Failed clone/cast! Check FirearmRuntimeState.Clone().", this); }
            } else { Debug.LogError($"[{gameObject.name} FirearmItemSpawner] Template does not implement ICloneableRuntimeState!", this); }
        }

        // Fallback to default if template null or clone failed
        if (stateClone == null) {
            Debug.LogWarning($"[{gameObject.name} FirearmItemSpawner] Using default state.", this);
            stateClone = CreateDefaultStateForItem(itemToSpawn) as FirearmRuntimeState;
             if (stateClone == null) { Debug.LogError($"[{gameObject.name} FirearmItemSpawner] Failed to create default state!", this); return null; }
        }

        return new InventoryItem(itemToSpawn, stateClone);
    }

    /// <summary>EDITOR VALIDATION</summary>
    protected override void OnValidate() {
        base.OnValidate();
        if (itemToSpawn != null && !(itemToSpawn is FirearmItemData)) { Debug.LogError($"Assigned ItemData is NOT FirearmItemData!", this); }
         if (initialStateTemplate == null && this.enabled) { Debug.LogWarning($"'Initial State Template' is null. Default state will be used.", this); }
         else if(initialStateTemplate != null && !(initialStateTemplate is ICloneableRuntimeState)) { Debug.LogError($"Assigned Initial State Template (FirearmRuntimeState) MUST implement ICloneableRuntimeState!", this); }
    }
}
// --- End of script: Assets/Logic/ItemSpawners/FirearmItemSpawner.cs ---

// --- Start of script: Assets/Logic/ItemSpawners/GearboxItemSpawner.cs ---
using UnityEngine;

/// <summary>
/// Auto-generated spawner for GearboxData. Configures the initial state
/// (GearboxRuntimeState) directly in the Inspector via the 'initialStateTemplate' field.
/// </summary>
public class GearboxItemSpawner : ItemSpawner {

    [Header("--- GearboxRuntimeState Initial State Template ---")]
    [Tooltip("Configure the desired starting state. This exact state will be cloned.")]
    [SerializeField] private GearboxRuntimeState initialStateTemplate = new GearboxRuntimeState();

    /// <summary>
    /// OVERRIDE: Creates the InventoryItem using the base itemToSpawn data
    /// and a CLONE of the initialStateTemplate.
    /// </summary>
    protected override InventoryItem GetInitialInventoryItem() {
        if (itemToSpawn == null) { Debug.LogError($"[{gameObject.name} GearboxItemSpawner] 'Item To Spawn' not assigned!", this); return null; }
        if (!(itemToSpawn is GearboxData)) { Debug.LogError($"[{gameObject.name} GearboxItemSpawner] Assigned 'Item To Spawn' is not GearboxData!", this); return null; }

        GearboxRuntimeState stateClone = null;
        if (initialStateTemplate != null) {
            if (initialStateTemplate is ICloneableRuntimeState templateCloneable) {
                 stateClone = templateCloneable.Clone() as GearboxRuntimeState;
                 if (stateClone == null) { Debug.LogError($"[{gameObject.name} GearboxItemSpawner] Failed clone/cast! Check GearboxRuntimeState.Clone().", this); }
            } else { Debug.LogError($"[{gameObject.name} GearboxItemSpawner] Template does not implement ICloneableRuntimeState!", this); }
        }

        // Fallback to default if template null or clone failed
        if (stateClone == null) {
            Debug.LogWarning($"[{gameObject.name} GearboxItemSpawner] Using default state.", this);
            stateClone = CreateDefaultStateForItem(itemToSpawn) as GearboxRuntimeState;
             if (stateClone == null) { Debug.LogError($"[{gameObject.name} GearboxItemSpawner] Failed to create default state!", this); return null; }
        }

        return new InventoryItem(itemToSpawn, stateClone);
    }

    /// <summary>EDITOR VALIDATION</summary>
    protected override void OnValidate() {
        base.OnValidate();
        if (itemToSpawn != null && !(itemToSpawn is GearboxData)) { Debug.LogError($"Assigned ItemData is NOT GearboxData!", this); }
         if (initialStateTemplate == null && this.enabled) { Debug.LogWarning($"'Initial State Template' is null. Default state will be used.", this); }
         else if(initialStateTemplate != null && !(initialStateTemplate is ICloneableRuntimeState)) { Debug.LogError($"Assigned Initial State Template (GearboxRuntimeState) MUST implement ICloneableRuntimeState!", this); }
    }
}
// --- End of script: Assets/Logic/ItemSpawners/GearboxItemSpawner.cs ---

// --- Start of script: Assets/Logic/ItemSpawners/ICloneableRuntimeState.cs ---
public interface ICloneableRuntimeState : IRuntimeState {
    IRuntimeState Clone(); // Returns a deep copy of itself
}
// --- End of script: Assets/Logic/ItemSpawners/ICloneableRuntimeState.cs ---

// --- Start of script: Assets/Logic/ItemSpawners/ItemSpawner.cs ---
// Assets/Logic/ItemSpawners/ItemSpawner.cs
using UnityEngine;

/// <summary>
/// Generic base class for spawning item prefabs in the world.
/// Handles prefab instantiation based on ItemData, InventoryItem creation
/// (using default or derived-provided state), initialization of the spawned instance.
/// Provides options for spawn offsets and self-destruction.
/// </summary>
public class ItemSpawner : MonoBehaviour {

    [Header("Item Definition")]
    [Tooltip("The ItemData defining the item to spawn.")]
    [SerializeField] protected ItemData itemToSpawn; // Use protected for derived access

    // --- Restored Spawner Settings ---
    [Header("Spawner Settings")]
    [Tooltip("Should the spawner destroy itself after successfully spawning the item?")]
    [SerializeField] private bool destroySpawnerAfterSpawn = true;
    [Tooltip("Optional offset from the spawner's position for the item spawn point (relative to spawner's transform).")]
    [SerializeField] private Vector3 spawnPositionOffset = Vector3.zero;
    [Tooltip("Optional rotation relative to the spawner's rotation.")]
    [SerializeField] private Vector3 spawnRotationOffset = Vector3.zero;
    // --- End Restored Spawner Settings ---

    /// <summary>
    /// Spawns the item and potentially destroys the spawner GameObject.
    /// </summary>
    protected virtual void Awake() {
        SpawnItem();
        // Conditionally destroy the spawner based on the setting
        if (destroySpawnerAfterSpawn) {
            Destroy(gameObject);
        } else {
             // Optionally disable the component if not destroying,
             // prevents respawning on scene reload or re-enable
             enabled = false;
        }
    }

    /// <summary>
    /// Spawns the item at the spawner's position/rotation plus offsets.
    /// </summary>
    protected virtual void SpawnItem() {
        if (itemToSpawn == null) { Debug.LogError($"[{gameObject.name}] No 'Item To Spawn' assigned!", this); return; }
        if (itemToSpawn.worldPrefab == null) { Debug.LogError($"[{gameObject.name}] ItemData '{itemToSpawn.itemName}' has no World Prefab!", itemToSpawn); return; }

        // Get the fully configured InventoryItem (with cloned state) from potentially derived class
        InventoryItem newItemInstance = GetInitialInventoryItem(); // Calls derived override
        if (newItemInstance == null) { Debug.LogError($"[{gameObject.name}] Failed to get initial InventoryItem for '{itemToSpawn.itemName}'!", this); return; }

        // --- Calculate Spawn Transform using Offsets ---
        // Position: Spawner position + Spawner rotation * Local Offset
        Vector3 spawnPos = transform.position + transform.rotation * spawnPositionOffset;
        // Rotation: Spawner rotation * Local Rotation Offset
        Quaternion spawnRot = transform.rotation * Quaternion.Euler(spawnRotationOffset);
        // --- End Calculation ---

        // Instantiate & Initialize AT CALCULATED TRANSFORM
        GameObject spawnedGO = Instantiate(itemToSpawn.worldPrefab, spawnPos, spawnRot); // Use calculated pos/rot
        if (spawnedGO == null) { Debug.LogError($"[{gameObject.name}] Failed to Instantiate worldPrefab: {itemToSpawn.worldPrefab.name}", this); return; }
        spawnedGO.name = $"{itemToSpawn.worldPrefab.name}_Spawned"; // Optional: Rename

        InitializeSpawnedInstance(spawnedGO, newItemInstance);
    }

    /// <summary>
    /// Handles initializing the spawned GameObject based on its components.
    /// It will correctly call the Initialize(InventoryItem) method on ItemInstance derivatives (like FirearmInstance or PartInstance when loose)
    /// or on WorldItem.
    /// </summary>
    protected virtual void InitializeSpawnedInstance(GameObject spawnedGO, InventoryItem itemInstanceToAssign) {
        // Try to get the ItemInstance component. This covers PartInstance, FirearmInstance, etc.
        // It will call the most specific override of Initialize(InventoryItem).
        if (spawnedGO.TryGetComponent<ItemInstance>(out var itemInst)) {
            itemInst.Initialize(itemInstanceToAssign);
        }
        // WorldItem is distinct and does not inherit ItemInstance in the current structure.
        else if (spawnedGO.TryGetComponent<WorldItem>(out var worldItem)) {
            worldItem.Initialize(itemInstanceToAssign);
        }
        // If neither, then it's something else the spawner doesn't know how to generically initialize.
        else {
             Debug.LogWarning($"[{gameObject.name} ItemSpawner] Spawned prefab '{spawnedGO.name}' does not have a recognized initialization component (e.g., ItemInstance or WorldItem). The prefab should have a script that inherits from ItemInstance or is a WorldItem.", spawnedGO);
        }
    }

    /// <summary>
    /// VIRTUAL HOOK (PROTECTED): Derived spawners override to create/return InventoryItem with cloned state template.
    /// Base attempts to create item with default state.
    /// </summary>
    protected virtual InventoryItem GetInitialInventoryItem() {
        if (itemToSpawn == null) return null;
        IRuntimeState state = GetConfiguredRuntimeStateClone() ?? CreateDefaultStateForItem(itemToSpawn);
        if (state != null) return new InventoryItem(itemToSpawn, state);
        else return new InventoryItem(itemToSpawn); // No runtime state
    }

    /// <summary>
    /// VIRTUAL HOOK (PROTECTED): Derived spawners override to return CLONE of their state template. Base returns null.
    /// </summary>
    protected virtual IRuntimeState GetConfiguredRuntimeStateClone() { return null; }

    /// <summary>
    /// Helper to create the default state object based on ItemData type. Protected.
    /// </summary>
    protected IRuntimeState CreateDefaultStateForItem(ItemData itemData) {
        if (itemData is CarPartData carPartData) return carPartData.CreateDefaultRuntimeState();
        if (itemData is FirearmItemData firearmData) return new FirearmRuntimeState(firearmData.attachmentSlots, 100); // Correct Name
        // Add other types...
        return null;
    }

    protected virtual void OnValidate() {
        if (itemToSpawn == null && this.enabled) {
            Debug.LogWarning($"ItemSpawner on {gameObject.name} has no 'Item To Spawn' assigned.");
        }
    }
}
// --- End of script: Assets/Logic/ItemSpawners/ItemSpawner.cs ---

// --- Start of script: Assets/Logic/Player/InteractionController.cs ---
using UnityEngine;
using UnityEngine.UI; // Uncomment if you add the Text prompt back

/// <summary>
/// Detects interactable objects (Parts, MountPoints, etc.) the player is looking at
/// and provides information about them. Also handles highlighting potential MountPoints
/// when requested by other systems (like HandsBehavior).
/// </summary>
public class InteractionController : MonoBehaviour {

    [Header("Detection Settings")]
    [Tooltip("Max distance to detect interactable objects.")]
    [SerializeField] private float detectionRange = 3.0f;
    [Tooltip("Layers containing physically interactable objects like PartInstances and MountPoints.")]
    [SerializeField] private LayerMask detectionLayerMask = 0; // Renamed for clarity
    [Tooltip("Color used to highlight compatible MountPoints.")]
    [SerializeField] private Color highlightColor = Color.green;

    [Header("References")]
    [Tooltip("The transform of the camera used for raycasting.")]
    [SerializeField] private Transform playerCameraTransform;
    // [Tooltip("Optional UI Text element to display interaction prompts.")]
    // [SerializeField] private Text interactionPromptText;

    // --- Runtime State ---
    private InteractableInfo _currentLookInfo; // Internal state
    private MountPoint _highlightedMountPoint;
    private Material _originalMountMaterial; // For restoring color
    private Renderer _highlightedRenderer;   // Cache renderer for efficiency

    /// <summary>
    /// Information about the object currently being looked at by the player.
    /// </summary>
    public InteractableInfo CurrentLookTargetInfo => _currentLookInfo; // Public read-only property

    /// <summary>
    /// Struct holding details about the detected interactable object.
    /// </summary>
    public struct InteractableInfo {
        public GameObject TargetObject { get; private set; }
        public PartInstance Part { get; private set; } // Renamed for clarity
        public MountPoint Mount { get; private set; } // Renamed for clarity
        public bool IsLoosePart { get; private set; }
        public bool IsInstalledPart { get; private set; }
        public bool HasTarget => TargetObject != null; // Helper property

        // Constructor to set values safely
        public InteractableInfo(GameObject target, PartInstance part, MountPoint mount) {
            TargetObject = target;
            Part = part;
            Mount = mount;
            IsLoosePart = part != null && part.OwningVehicle == null;
            // Installed if part exists, attached to vehicle, and is the part currently on the detected mount (or no mount detected)
            IsInstalledPart = part != null && part.OwningVehicle != null && (mount == null || mount.CurrentlyAttachedPart == part);
        }
    }

    private void Awake() {
        // Attempt to find camera if not assigned
        if (playerCameraTransform == null) {
            var mainCamera = Camera.main;
            if (mainCamera != null) {
                playerCameraTransform = mainCamera.transform;
            } else {
                Debug.LogError($"[{GetType().Name}] Player Camera Transform not found or assigned, and Camera.main is null!", this);
                enabled = false; // Cannot function without a camera
                return;
            }
        }
        // Validate detection layer mask
        if (detectionLayerMask.value == 0) {
             Debug.LogWarning($"[{GetType().Name} on {gameObject.name}] Detection Layer Mask is not set. Will likely not detect any parts/mounts.", this);
        }
        // if (interactionPromptText == null) Debug.LogWarning($"[{GetType().Name}] Interaction Prompt Text not assigned.", this);
        // else interactionPromptText.text = "";
    }

    private void Update() {
        if (playerCameraTransform == null) return; // Exit if camera is missing

        // Store previous target for comparison
        GameObject previousTarget = _currentLookInfo.TargetObject;

        // Detect what's currently being looked at
        DetectLookTarget();

        // If target changed, clear any existing highlight
        if (previousTarget != _currentLookInfo.TargetObject && _highlightedMountPoint != null) {
            ClearMountHighlight();
        }

        // Update UI prompt based on the new look target
        UpdateInteractionPrompt();
    }

    /// <summary>
    /// Performs a raycast and populates the _currentLookInfo struct.
    /// </summary>
    private void DetectLookTarget() {
        Ray lookRay = new Ray(playerCameraTransform.position, playerCameraTransform.forward);
        _currentLookInfo = new InteractableInfo(); // Reset info

        if (Physics.Raycast(lookRay, out RaycastHit hit, detectionRange, detectionLayerMask)) {
             GameObject hitObject = hit.collider.gameObject;
             // Prioritize getting components from the collider first, then check parent
             PartInstance part = hit.collider.GetComponent<PartInstance>() ?? hit.collider.GetComponentInParent<PartInstance>();
             MountPoint mount = hit.collider.GetComponent<MountPoint>() ?? hit.collider.GetComponentInParent<MountPoint>();

             _currentLookInfo = new InteractableInfo(hitObject, part, mount);
        }
        // If raycast hits nothing relevant, _currentLookInfo remains empty (default values).
    }

    /// <summary>
    /// Updates the interaction prompt (currently Debug.Log) based on the looked-at object.
    /// </summary>
    private void UpdateInteractionPrompt() {
        // if (interactionPromptText == null) return; // Early exit if no UI text

        string prompt = "";
        if (_currentLookInfo.HasTarget) {
            PartInstance targetPart = _currentLookInfo.Part; // Use property for clarity
            MountPoint targetMount = _currentLookInfo.Mount; // Use property

            if (targetPart != null) { // Check if we are looking at a PartInstance
                // Use the correct GetItemData method
                ItemData partData = targetPart.GetItemData<ItemData>();
                string itemName = partData?.itemName ?? "Part"; // Use null-conditional access

                if (_currentLookInfo.IsLoosePart) {
                    // Prompt assumes HandsBehavior uses LMB ('Fire1') to grab/detach
                    prompt = $"[LMB] Grab {itemName}";
                } else if (_currentLookInfo.IsInstalledPart) {
                     prompt = $"[LMB] Detach {itemName}";
                }
                // Note: If looking at an installed part that *is not* the one on the mount point
                // (e.g., looking at engine block behind a radiator mounted to it),
                // IsInstalledPart might be true but IsLoosePart false. Add specific prompts if needed.

            } else if (targetMount != null && targetMount.CurrentlyAttachedPart == null) {
                // Looking at an empty mount point - prompt depends on HandsBehavior state (if holding compatible part)
                // Example (HandsBehavior would need to signal this state):
                // if (IsPlayerHoldingCompatiblePart(targetMount)) {
                //    prompt = $"[LMB] Attach Held Part to {targetMount.mountPointDefinitionID}";
                // }
                 prompt = $"Look at empty Mount Point: {targetMount.mountPointDefinitionID}"; // Generic placeholder
            }
            // Add more conditions for other interactable types if InteractionController handled them
        }

        // Update UI Text or Debug Log
        // interactionPromptText.text = prompt;
        if (!string.IsNullOrEmpty(prompt)) {
            Debug.Log($"[InteractionPrompt] {prompt}"); // Placeholder UI
        }
    }


    // --- Highlighting Logic ---

    /// <summary>
    /// Called by HandsBehavior to potentially highlight a mount point the player is looking at,
    /// checking for compatibility with the held part.
    /// </summary>
    public void UpdateMountPointHighlight(PartInstance heldPart) {
        // Check if currently looking at a suitable mount point
        MountPoint potentialMount = _currentLookInfo.Mount; // Get from current look info

        if (potentialMount != null && potentialMount.CurrentlyAttachedPart == null && heldPart != null && potentialMount.IsCompatible(heldPart)) {
             // Compatible empty mount point is being looked at
             if (_highlightedMountPoint != potentialMount) {
                 ClearMountHighlight(); // Clear previous if different
                 HighlightMount(potentialMount);
             }
        } else {
             // Not looking at a compatible empty mount point, clear highlight
             if (_highlightedMountPoint != null) {
                 ClearMountHighlight();
             }
        }
    }

    /// <summary>
    /// Applies the highlight effect to the specified MountPoint.
    /// </summary>
    private void HighlightMount(MountPoint mp) {
        if (mp == null) return;

        _highlightedMountPoint = mp;
        _highlightedRenderer = mp.GetComponent<Renderer>(); // Attempt to get renderer

        if (_highlightedRenderer != null) {
            _originalMountMaterial = _highlightedRenderer.material; // Store original
            // Create a temporary instance to avoid modifying shared material asset
            Material tempMat = new Material(_originalMountMaterial);
            tempMat.color = highlightColor;
             // Assign the temporary material
            _highlightedRenderer.material = tempMat;
            // Debug.Log($"[InteractionController] Highlighting Mount: {mp.name}", mp);
        } else {
             Debug.LogWarning($"[InteractionController] Cannot highlight MountPoint '{mp.name}': No Renderer found.", mp);
        }
    }

    /// <summary>
    /// Removes any active highlight effect.
    /// </summary>
    public void ClearMountHighlight() {
        if (_highlightedMountPoint != null && _highlightedRenderer != null) {
            // Check if we have a stored original material to restore
            if (_originalMountMaterial != null) {
                // If the current material is the temp instance we created, destroy it
                if (_highlightedRenderer.material != _originalMountMaterial && _highlightedRenderer.material.name.Contains("(Instance)")) {
                     Destroy(_highlightedRenderer.material);
                }
                // Restore the original material
                _highlightedRenderer.material = _originalMountMaterial;
            }
            // else: No original material stored or renderer lost? Just clear refs.
            // Debug.Log($"[InteractionController] Clearing Highlight from Mount: {_highlightedMountPoint.name}", _highlightedMountPoint);
        }
        // Clear references regardless
        _highlightedMountPoint = null;
        _highlightedRenderer = null;
        _originalMountMaterial = null;
    }
}
// --- End of script: Assets/Logic/Player/InteractionController.cs ---

// --- Start of script: Assets/Logic/Player/PlayerLook.cs ---
using UnityEngine;

// Ensure this class actually implements IAimProvider
public class PlayerLook : MonoBehaviour, IAimProvider
{
    [Header("References")]
    [SerializeField] private Transform cameraPivot; // The object that handles Pitch rotation (usually the camera itself)
    [SerializeField] private Transform yawRoot;     // The object that handles Yaw rotation (usually the player's root body)

    [Header("Look Settings")]
    [SerializeField] private float sensitivityX = 2f;
    [SerializeField] private float sensitivityY = 2f;
    [SerializeField] private float minPitch = -85f; // Slightly increased range
    [SerializeField] private float maxPitch = 85f;

    [Header("Aim Settings (for IAimProvider)")]
    [SerializeField] private float maxAimDistance = 100f;
    [SerializeField] private LayerMask aimCollisionLayers = ~0; // Hit everything by default

    // Runtime state
    private float _targetYaw;
    private float _targetPitch;

    // Public properties
    public Quaternion YawOrientation => yawRoot != null ? yawRoot.rotation : Quaternion.identity;
    public Quaternion PitchOrientation => cameraPivot != null ? cameraPivot.localRotation : Quaternion.identity;
    public float CurrentYaw => _targetYaw;
    public float CurrentPitch => _targetPitch;

    private void Awake()
    {
        // Auto-assign yawRoot if not set
        if (yawRoot == null) yawRoot = transform;
        if (cameraPivot == null) {
             // Try finding camera tagged "MainCamera" as a child if pivot isn't set
             Camera mainCam = GetComponentInChildren<Camera>();
             if (mainCam != null && mainCam.CompareTag("MainCamera")) {
                 cameraPivot = mainCam.transform;
                 Debug.LogWarning($"[PlayerLook] Camera Pivot not assigned on {gameObject.name}, automatically assigned to child Camera '{cameraPivot.name}'.", this);
             } else {
                 Debug.LogError("[PlayerLook] Camera Pivot not assigned and could not be found automatically!", this);
                 this.enabled = false;
                 return;
             }
        }

        // Initialize rotation from current transform state
        _targetYaw = yawRoot.eulerAngles.y;
        // Correctly handle initial pitch if camera is rotated down
        Vector3 currentPivotEuler = cameraPivot.localEulerAngles;
        _targetPitch = (currentPivotEuler.x > 180) ? currentPivotEuler.x - 360 : currentPivotEuler.x;

        // Initial application ensures visual matches internal state
        ApplyRotation();
    }

    // Called by PlayerManager when look input is received
    public void SetLookInput(Vector2 lookDelta)
    {
        if (Mathf.Approximately(Time.timeScale, 0f)) return; // Don't process look input if paused

        // Accumulate rotation changes
        _targetYaw += lookDelta.x * sensitivityX;
        _targetPitch -= lookDelta.y * sensitivityY; // Subtract Y delta for standard FPS controls

        // Clamp pitch
        _targetPitch = Mathf.Clamp(_targetPitch, minPitch, maxPitch);

        ApplyRotation();
    }

    private void ApplyRotation()
    {
         if (yawRoot) yawRoot.localRotation = Quaternion.Euler(0f, _targetYaw, 0f); // Apply Yaw to root
         if (cameraPivot) cameraPivot.localRotation = Quaternion.Euler(_targetPitch, 0f, 0f); // Apply Pitch to pivot
    }

    // --- IAimProvider Implementation ---
    public Vector3 GetAimHitPoint() {
         if (!cameraPivot) {
             Debug.LogError("[PlayerLook GetAimHitPoint] Camera Pivot is null!", this);
             return (yawRoot ?? transform).position + (yawRoot ?? transform).forward * maxAimDistance; // Fallback
         }
         Ray ray = GetLookRay();
         if (Physics.Raycast(ray, out RaycastHit hit, maxAimDistance, aimCollisionLayers, QueryTriggerInteraction.Ignore)) {
             return hit.point;
         }
         return ray.origin + ray.direction * maxAimDistance; // Return point far along ray if no hit
    }

    public Ray GetLookRay() {
         if (!cameraPivot) {
             Debug.LogError("[PlayerLook GetLookRay] Camera Pivot is null!", this);
             Transform root = yawRoot ?? transform;
             return new Ray(root.position, root.forward); // Fallback ray from root
         }
         // Ray originates from camera pivot and goes forward
         return new Ray(cameraPivot.position, cameraPivot.forward);
    }

    public Transform GetLookTransform() {
        // Return the transform used for raycasting (the camera pivot)
        if (!cameraPivot) Debug.LogError("[PlayerLook GetLookTransform] Camera Pivot is null!", this);
        return cameraPivot;
     }

     // Added methods that might be useful from IAimProvider interface if defined elsewhere
     public Vector3 GetLookDirection() => cameraPivot ? cameraPivot.forward : (yawRoot ?? transform).forward;
     public Vector3 GetLookOrigin() => cameraPivot ? cameraPivot.position : (yawRoot ?? transform).position;
     public Vector3 GetAimDirection(Vector3 fromPosition) => (GetAimHitPoint() - fromPosition).normalized;
}
// --- End of script: Assets/Logic/Player/PlayerLook.cs ---

// --- Start of script: Assets/Logic/Player/PlayerManager.cs ---
// --- Start of script: Assets/Logic/Player/PlayerManager.cs ---
using UnityEngine;
using System;
using UnityEngine.InputSystem;

public class PlayerManager : MonoBehaviour
{
    [Header("Core Components (Auto-find where possible)")]
    [SerializeField] private PlayerInventory playerInventory;
    [SerializeField] private PlayerLook playerLook;
    [SerializeField] private MyCharacterController characterController;
    [SerializeField] private EquipmentController equipmentController;
    [SerializeField] private WorldInteractor worldInteractor;
    [SerializeField] private PlayerInputHandler inputHandler;
    [SerializeField] private PlayerGrabController grabController;

    [Header("UI Components (Assign or Find)")]
    [SerializeField] private InventoryUIManager inventoryUIManager;
    [SerializeField] private UIStateController uiStateController;
    [SerializeField] private UIPanelRegistry uiPanelRegistry;

    public PlayerLook Look => playerLook;
    public MyCharacterController CharacterController => characterController;
    public EquipmentController Equipment => equipmentController;
    public WorldInteractor Interactor => worldInteractor;
    public PlayerInventory Inventory => playerInventory;
    public PlayerInputHandler InputHandler => inputHandler;
    public PlayerGrabController GrabController => grabController;

    private bool isRotatingGrabbedItem = false; // True if MMB is held AND an item is grabbed

    private void Awake()
    {
        inputHandler ??= GetComponentInChildren<PlayerInputHandler>(true);
        playerInventory ??= GetComponentInChildren<PlayerInventory>(true);
        playerLook ??= GetComponentInChildren<PlayerLook>(true);
        characterController ??= GetComponentInChildren<MyCharacterController>(true);
        equipmentController ??= GetComponentInChildren<EquipmentController>(true);
        worldInteractor ??= GetComponentInChildren<WorldInteractor>(true);
        grabController ??= GetComponentInChildren<PlayerGrabController>(true);
        uiStateController ??= FindFirstObjectByType<UIStateController>();
        inventoryUIManager ??= FindFirstObjectByType<InventoryUIManager>();
        uiPanelRegistry ??= FindFirstObjectByType<UIPanelRegistry>();

        if (inputHandler == null) Debug.LogError("[PM] Input Handler Missing", this);
        if (playerInventory == null) Debug.LogError("[PM] PlayerInventory Missing", this);
        if (playerLook == null) Debug.LogError("[PM] PlayerLook Missing", this);
        if (characterController == null) Debug.LogError("[PM] CharacterController Missing", this);
        if (equipmentController == null) Debug.LogError("[PM] EquipmentController Missing", this);
        if (worldInteractor == null) Debug.LogError("[PM] WorldInteractor Missing", this);
        if (grabController == null) Debug.LogError("[PM] Grab Controller Missing.", this);
        if (uiStateController == null) Debug.LogError("[PM] UIStateController Missing", this);
        
        if (uiStateController != null) uiStateController.OnStateChanged += HandleUIStateChange;
        if (grabController != null)
        {
            grabController.InitializeController(this);
            grabController.OnGrabStateChanged += HandleGrabStateChanged;
        }
    }

    private void Start()
    {
        if (uiPanelRegistry != null && uiStateController != null) uiPanelRegistry.Hook(uiStateController);
        else if (uiStateController == null && inputHandler != null) inputHandler.EnableGameplayControls();
        else if (uiStateController != null) HandleUIStateChange(new UIStateChanged(uiStateController.Current, uiStateController.Current));

        if (inventoryUIManager != null && playerInventory != null) inventoryUIManager.Show(playerInventory);
        equipmentController?.ManualStart();
    }

    private void OnEnable()
    {
        if (inputHandler == null) { Debug.LogError("[PM] Input Handler Null on Enable.", this); return; }

        inputHandler.MovePerformed += HandleMoveInput;
        inputHandler.LookPerformed += HandleLookInput; // This event provides the delta
        inputHandler.JumpPerformed += HandleJumpInput;
        inputHandler.SprintStarted += HandleSprintStart; inputHandler.SprintCanceled += HandleSprintCancel;
        inputHandler.CrouchStarted += HandleCrouchStart; inputHandler.CrouchCanceled += HandleCrouchCancel;
        inputHandler.SlowWalkStarted += HandleSlowWalkStart; inputHandler.SlowWalkCanceled += HandleSlowWalkCancel;
        inputHandler.ToolbarScrollPerformed += HandleToolbarScroll;
        inputHandler.ToolbarSlotSelected += HandleToolbarSlotSelection;
        inputHandler.InteractPerformed += HandleInteract;
        inputHandler.Fire1Started += HandleFire1Start; inputHandler.Fire1Canceled += HandleFire1Cancel;
        inputHandler.Fire2Started += HandleFire2Start; inputHandler.Fire2Canceled += HandleFire2Cancel;
        inputHandler.ReloadPerformed += HandleReload;
        inputHandler.StorePerformed += HandleStore;
        inputHandler.UtilityPerformed += HandleUtilityStart; inputHandler.UtilityCanceled += HandleUtilityCancel;
        inputHandler.ToggleInventoryPerformed += HandleToggleInventory; inputHandler.ToggleMenuPerformed += HandleToggleMenu;
        
        inputHandler.RotateHeldStarted += HandleRotateHeldStartedEvent; // Renamed to avoid conflict
        inputHandler.RotateHeldEnded += HandleRotateHeldEndedEvent;     // Renamed to avoid conflict
        inputHandler.RotateDeltaPerformed += HandleRotateDeltaInput;    // This receives delta from LookPerformed when MMB is held
        
        inputHandler.UICancelPerformed += HandleUICancel;
        inputHandler.UITabNavigatePerformed += HandleUITabNavigate;
    }

    private void OnDisable()
    {
        if (inputHandler != null) {
             inputHandler.MovePerformed -= HandleMoveInput;
             inputHandler.LookPerformed -= HandleLookInput;
             inputHandler.JumpPerformed -= HandleJumpInput;
             inputHandler.SprintStarted -= HandleSprintStart; inputHandler.SprintCanceled -= HandleSprintCancel;
             inputHandler.CrouchStarted -= HandleCrouchStart; inputHandler.CrouchCanceled -= HandleCrouchCancel;
             inputHandler.SlowWalkStarted -= HandleSlowWalkStart; inputHandler.SlowWalkCanceled -= HandleSlowWalkCancel;
             inputHandler.ToolbarScrollPerformed -= HandleToolbarScroll;
             inputHandler.ToolbarSlotSelected -= HandleToolbarSlotSelection;
             inputHandler.InteractPerformed -= HandleInteract;
             inputHandler.Fire1Started -= HandleFire1Start; inputHandler.Fire1Canceled -= HandleFire1Cancel;
             inputHandler.Fire2Started -= HandleFire2Start; inputHandler.Fire2Canceled -= HandleFire2Cancel;
             inputHandler.ReloadPerformed -= HandleReload;
             inputHandler.StorePerformed -= HandleStore;
             inputHandler.UtilityPerformed -= HandleUtilityStart; inputHandler.UtilityCanceled -= HandleUtilityCancel;
             inputHandler.ToggleInventoryPerformed -= HandleToggleInventory; inputHandler.ToggleMenuPerformed -= HandleToggleMenu;

             inputHandler.RotateHeldStarted -= HandleRotateHeldStartedEvent;
             inputHandler.RotateHeldEnded -= HandleRotateHeldEndedEvent;
             inputHandler.RotateDeltaPerformed -= HandleRotateDeltaInput;

             inputHandler.UICancelPerformed -= HandleUICancel;
             inputHandler.UITabNavigatePerformed -= HandleUITabNavigate;
        }
        if (uiStateController != null) { uiStateController.OnStateChanged -= HandleUIStateChange; }
        if (grabController != null) { grabController.OnGrabStateChanged -= HandleGrabStateChanged; }
    }

    private void Update() {
        if (characterController != null && playerLook != null) {
            characterController.SetLookDirection(playerLook.GetLookDirection());
        }
        if (inputHandler != null && equipmentController != null && !isRotatingGrabbedItem && (grabController == null || !grabController.IsGrabbing)) {
            if (inputHandler.IsFire1Held) equipmentController.HandleFire1Hold();
            if (inputHandler.IsFire2Held) equipmentController.HandleFire2Hold();
        }
    }

    private void LateUpdate() {
         if (characterController != null && playerLook != null && playerLook.transform != null) {
             Vector3 targetPos = characterController.GetSmoothedHeadWorldPosition();
             playerLook.transform.position = Vector3.Lerp(playerLook.transform.position, targetPos, Time.deltaTime * 20f);
         }
    }

    private void HandleUIStateChange(UIStateChanged eventArgs) {
        if (inputHandler == null) return;
        if (eventArgs.Current == UIState.Gameplay) inputHandler.EnableGameplayControls();
        else inputHandler.EnableUIControls();
        if (eventArgs.Current != UIState.Gameplay && isRotatingGrabbedItem) {
            isRotatingGrabbedItem = false;
            grabController?.EndGrabRotation();
        }
     }
    private void HandleGrabStateChanged(bool isGrabbing, IGrabbable grabbedItem) {
        if (isGrabbing) {
            equipmentController?.HandleEquipRequest(null); 
        } else {
            equipmentController?.HandleEquipRequest(playerInventory?.GetCurrentEquippedItem()); 
            if (isRotatingGrabbedItem) {
                isRotatingGrabbedItem = false; 
            }
        }
    }

    private void HandleMoveInput(Vector2 m) => characterController?.SetMoveInput(m);

    private void HandleLookInput(Vector2 lookDelta) {
        // This lookDelta is from InputHandler.LookPerformed
        // PlayerInputHandler now gates the LookPerformed event based on IsRotateHeld for camera look
        // but always fires RotateDeltaPerformed if IsRotateHeld is true.
        // So, here we only pass to PlayerLook if not rotating item.
        if (!isRotatingGrabbedItem) {
            playerLook?.SetLookInput(lookDelta);
        }
    }
    private void HandleRotateDeltaInput(Vector2 rotateDelta) {
        // This is called from InputHandler.RotateDeltaPerformed (which is fired by LookPerformed if IsRotateHeld)
        if (isRotatingGrabbedItem && grabController != null && grabController.IsGrabbing) {
            grabController.ApplyGrabbedItemRotationInput(rotateDelta);
        }
    }

    private void HandleJumpInput() => characterController?.OnJumpPressed();
    private void HandleInteract() {
        if (isRotatingGrabbedItem) return; 
        worldInteractor?.OnInteractPressed();
    }
    private void HandleSprintStart() => characterController?.SetSprint(true);
    private void HandleSprintCancel() => characterController?.SetSprint(false);
    private void HandleCrouchStart() => characterController?.SetCrouch(true);
    private void HandleCrouchCancel() => characterController?.SetCrouch(false);
    private void HandleSlowWalkStart() => characterController?.SetSlowWalk(true);
    private void HandleSlowWalkCancel() => characterController?.SetSlowWalk(false);

    private void HandleToolbarScroll(float dir) {
        if (isRotatingGrabbedItem) return; 
        if (grabController != null && grabController.IsGrabbing)
            grabController.AdjustGrabbedItemDistance(dir);
        else
            playerInventory?.HandleToolbarScroll(dir);
    }

    private void HandleToolbarSlotSelection(int idx) {
        if (isRotatingGrabbedItem) return; 
        playerInventory?.HandleToolbarSlotSelection(idx);
    }

    private void HandleFire1Start() {
        equipmentController?.HandleFire1Down();
    }

    private void HandleFire1Cancel() {
        // Only forward if not grabbing AND not rotating (as Fire1 is LMB and might be involved in future drag actions)
        if (!isRotatingGrabbedItem && (grabController == null || !grabController.IsGrabbing))
             equipmentController?.HandleFire1Up();
    }
    
    private void HandleFire2Start() {
        if (isRotatingGrabbedItem) return;
        if (grabController == null || !grabController.IsGrabbing) {
            equipmentController?.HandleFire2Down();
        }
    }
    private void HandleFire2Cancel() {
         if (isRotatingGrabbedItem) return;
         if (grabController == null || !grabController.IsGrabbing)
            equipmentController?.HandleFire2Up();
    }
    private void HandleReload() {
         if (isRotatingGrabbedItem) return; 
         if (grabController == null || !grabController.IsGrabbing) 
            equipmentController?.HandleReloadDown();
    }
    
    private void HandleStore() {
        if (isRotatingGrabbedItem) return; 
        // The PlayerGrabController's HandleStoreAction now decides to store or pull
        grabController?.HandleStoreAction();
    }

    private void HandleUtilityStart() {
        if (isRotatingGrabbedItem) return;
        // If you want Utility to do something specific while grabbing (other than rotation, which uses MMB),
        // you could add logic here to call a method on grabController.
        // For now, it only forwards to equipment if not grabbing.
        if (grabController == null || !grabController.IsGrabbing) {
            equipmentController?.HandleUtilityDown();
        }
    }
    private void HandleUtilityCancel() {
         if (isRotatingGrabbedItem) return;
         if (grabController == null || !grabController.IsGrabbing)
             equipmentController?.HandleUtilityUp();
    }

    // Renamed to avoid conflict with internal state variable
    private void HandleRotateHeldStartedEvent() {
        if (grabController != null && grabController.IsGrabbing) {
            isRotatingGrabbedItem = true; // This is the PM's state flag
            grabController.StartGrabRotation(); // Tell PGC to enter its rotation mode
        }
    }
    private void HandleRotateHeldEndedEvent() {
        if(isRotatingGrabbedItem) { // Only if we were actually in rotation mode
            grabController?.EndGrabRotation(); // Tell PGC to exit its rotation mode
        }
        isRotatingGrabbedItem = false; // Always reset PM's state flag
    }
    
    private void HandleToggleInventory() { 
        if (isRotatingGrabbedItem) HandleRotateHeldEndedEvent(); // Cancel rotation if opening UI
        uiStateController?.ToggleState(UIState.Inventory); 
    }
    private void HandleToggleMenu() { 
        if (isRotatingGrabbedItem) HandleRotateHeldEndedEvent();
        uiStateController?.ToggleState(UIState.Menu); 
    }
    private void HandleUICancel() {
        if (isRotatingGrabbedItem) HandleRotateHeldEndedEvent();
        if (uiStateController?.IsUIOpen ?? false)
            uiStateController.SetState(UIState.Gameplay);
     }
    private void HandleUITabNavigate() {
         if (uiStateController == null) return;
         if (uiStateController.Current == UIState.Inventory) uiStateController.SetState(UIState.Gameplay);
    }

    public void ForceSlowWalk(bool v) => characterController?.ForceSlowWalk(v);
}
// --- End of script
// --- End of script: Assets/Logic/Player/PlayerManager.cs ---

// --- Start of script: Assets/Logic/Projectile/ArrowAudioHandler.cs ---
using UnityEngine;

[RequireComponent(typeof(AudioSource))]
public class ArrowAudioHandler : MonoBehaviour
{
    [SerializeField] private AudioClip impactSound;
    private AudioSource audioSource;

    private void Awake()
    {
        audioSource = GetComponent<AudioSource>();
        audioSource.playOnAwake = false;
    }

    public void PlayImpactSound()
    {
        if (impactSound != null)
        {
            audioSource.PlayOneShot(impactSound);
        }
    }
}
// --- End of script: Assets/Logic/Projectile/ArrowAudioHandler.cs ---

// --- Start of script: Assets/Logic/Projectile/ArrowProjectile.cs ---
using UnityEngine;

public class ArrowProjectile : ProjectileBehavior
{
    [Header("Settings")]
    [SerializeField] private float impactForceMultiplier = 1f;

    [Header("Gravity Settings")]
    [SerializeField] private Vector3 gravity = new Vector3(0f, -9.81f, 0f);

    private bool hasLaunched = false;
    private bool hasHit = false;
    private Vector3 velocity;

    private GameObject arrowAnchor;

    [Header("References")]
    private ArrowAudioHandler audioHandler;
    private HoleDecalSpawner holeDecalSpawner;

    private void Start()
    {
        audioHandler = GetComponent<ArrowAudioHandler>();
        holeDecalSpawner = GetComponent<HoleDecalSpawner>();
        //Destroy(gameObject, maxLifetime);
    }

    private void FixedUpdate()
    {
        if (!hasLaunched || hasHit) return;

        // Apply gravity
        velocity += gravity * Time.fixedDeltaTime;
        Vector3 movement = velocity * Time.fixedDeltaTime;

        Vector3 currentPosition = transform.position;
        Vector3 nextPosition = currentPosition + movement;

        // Create a mask that ignores Interactable layer (let's say it's layer 8)
        int interactableLayer = LayerMask.NameToLayer("Interactable");
        int everythingExceptInteractables = ~(1 << interactableLayer);


        if (Physics.Raycast(currentPosition, movement.normalized, out RaycastHit hit, movement.magnitude, everythingExceptInteractables, QueryTriggerInteraction.Ignore))
        {
            OnHit(hit);
        }   
        else
        {
            transform.position = nextPosition;
            if (velocity != Vector3.zero)
                transform.rotation = Quaternion.LookRotation(velocity);
        }
    }

    private void LateUpdate()
    {
        if(!hasHit)
            return;

        if (arrowAnchor != null)
        {
            transform.position = arrowAnchor.transform.position;
            transform.rotation = arrowAnchor.transform.rotation;
        }
        else
            Destroy(gameObject);
    }

    public override void Launch(Vector3 direction, float force)
    {
        if (hasLaunched) return;

        hasLaunched = true;
        velocity = direction.normalized * force;
        transform.rotation = Quaternion.LookRotation(direction);
    }

    private void OnHit(RaycastHit hit)
    {
        hasHit = true;

        GameObject newAnchor = new GameObject();
        newAnchor.transform.position = hit.point;
        newAnchor.transform.rotation = Quaternion.LookRotation(velocity);

        newAnchor.transform.SetParent(hit.transform);

        arrowAnchor = newAnchor;

        // Apply force if applicable
        if (hit.rigidbody != null)
        {
            Vector3 force = velocity * impactForceMultiplier;
            hit.rigidbody.AddForceAtPosition(force, hit.point, ForceMode.Impulse);
        }

        //Apply damage
        IDamageable damageable = hit.collider.GetComponentInParent<IDamageable>();
        if (damageable != null)
        {
            damageable.TakeDamage(30f, hit.point, velocity.normalized); // Replace 5f with your damage value
        }

        audioHandler.PlayImpactSound();
        holeDecalSpawner.SpawnDecal(newAnchor.transform.position, hit.normal, arrowAnchor.transform);

        //Debug.Log("Arrow hit: " + hit.collider.name);
    }
}
// --- End of script: Assets/Logic/Projectile/ArrowProjectile.cs ---

// --- Start of script: Assets/Logic/Projectile/HoleDecalSpawner.cs ---
using UnityEngine;

public class HoleDecalSpawner : MonoBehaviour
{
    [SerializeField] private GameObject decalPrefab;
    [SerializeField] private float decalOffset = 0.01f;
    [SerializeField] private float decalLifetime = 1000f;
    [SerializeField] private bool randomizeRotation = true;

    /// <summary>
    /// Spawns a decal at the hit point with proper orientation and optional random roll.
    /// </summary>
    /// <param name="position">World hit point</param>
    /// <param name="normal">Surface normal at the hit point</param>
    /// <param name="parent">Optional transform to parent the decal to</param>
    public void SpawnDecal(Vector3 position, Vector3 normal, Transform parent = null)
    {
        if (decalPrefab == null) return;

        Quaternion baseRotation = Quaternion.LookRotation(-normal);

        if (randomizeRotation)
        {
            Quaternion randomRoll = Quaternion.AngleAxis(Random.Range(0f, 360f), normal);
            baseRotation = randomRoll * baseRotation;
        }

        Vector3 decalPosition = position + normal * decalOffset;
        GameObject decalInstance = Instantiate(decalPrefab, decalPosition, baseRotation);

        if (parent != null)
        {
            decalInstance.transform.SetParent(parent);
        }

        Destroy(decalInstance, decalLifetime);
    }
}
// --- End of script: Assets/Logic/Projectile/HoleDecalSpawner.cs ---

// --- Start of script: Assets/Logic/Projectile/ProjectileBehavior.cs ---
using UnityEngine;

public abstract class ProjectileBehavior : MonoBehaviour
{
    public abstract void Launch(Vector3 direction, float force);
}
// --- End of script: Assets/Logic/Projectile/ProjectileBehavior.cs ---

// --- Start of script: Assets/Logic/UI/UIPanelRegistry.cs ---
using UnityEngine;
using System;
using System.Collections.Generic;

// Removed namespace

public class UIPanelRegistry : MonoBehaviour
{
    [Serializable]
    private struct PanelMapping
    {
        [Tooltip("The UI state that activates these panels.")]
        public UIState state;
        [Tooltip("The UI panels (GameObjects) to activate for this state.")]
        public GameObject[] panels;
    }

    [Tooltip("Define which panels are active for each UI state.")]
    [SerializeField] private PanelMapping[] panelMappings;

    private readonly Dictionary<UIState, GameObject[]> _panelLookup = new();
    private UIStateController _hookedController; // Store reference for unhooking and initial state

    private void Awake()
    {
        // Build the lookup dictionary
        _panelLookup.Clear(); // Ensure dictionary is clear if Awake runs again
        foreach (var mapping in panelMappings)
        {
            if (_panelLookup.ContainsKey(mapping.state))
            {
                Debug.LogWarning($"Duplicate UIState mapping found for '{mapping.state}' in UIPanelRegistry. Overwriting.", this);
            }
            _panelLookup[mapping.state] = mapping.panels ?? Array.Empty<GameObject>();
        }

        // Deactivate all managed panels initially to ensure a clean state
        // This prevents panels left active in the editor from showing incorrectly at start
        DeactivateAllManagedPanels();
    }

    /// <summary>
    /// Subscribes this registry to the UIStateController's state change events
    /// AND applies the controller's current state immediately.
    /// </summary>
    public void Hook(UIStateController controller)
    {
        if (controller != null)
        {
            // Unhook previous if necessary
            Unhook(_hookedController);

            _hookedController = controller; // Store reference
            _hookedController.OnStateChanged += HandleStateChange; // Subscribe to future changes

            // --- APPLY INITIAL STATE ---
            // Get the state the controller is *currently* in when Hook is called
            UIState initialState = _hookedController.Current;
            //Debug.Log($"[UIPanelRegistry HOOK] Hooked. Controller's current state is: {initialState}. Applying this state now.");

            // Deactivate everything first (optional but ensures clean state if panels were active in editor)
            // DeactivateAllManagedPanels(); // Can sometimes cause flicker, might not be needed if Awake handles it.

            // Directly try to activate panels for the initial state found
            if (_panelLookup.TryGetValue(initialState, out var panelsToActivate))
            {
                // Debug.Log($"[UIPanelRegistry HOOK] Found panels for initial state {initialState}. Activating...");
                SetPanelActiveState(panelsToActivate, true); // Activate the panels for the current state
            }
            else
            {
                 Debug.LogWarning($"[UIPanelRegistry HOOK] No panel mapping found for initial state: {initialState}");
            }
            // --- END APPLY INITIAL STATE ---
        }
        else
        {
            Debug.LogError("UIPanelRegistry cannot Hook to a null UIStateController!", this);
        }
    }

    /// <summary>
    /// Unsubscribes from the UIStateController's events.
    /// </summary>
    public void Unhook(UIStateController controller)
    {
         // Check if the controller passed is the one we are hooked to OR just unsubscribe from stored ref
         if (_hookedController != null)
         {
            _hookedController.OnStateChanged -= HandleStateChange;
            if (controller == _hookedController) // Clear stored ref only if unhooking the correct one
            {
                 _hookedController = null;
            }
         }
    }

    // Called when the hooked UIStateController's state changes
    private void HandleStateChange(UIStateChanged eventArgs)
    {
        // Debug.Log($"[UIPanelRegistry] HandleStateChange received. Previous: {eventArgs.Previous}, Current: {eventArgs.Current}");

        // Deactivate panels associated with the previous state (if different from current)
        if (eventArgs.Previous != eventArgs.Current && _panelLookup.TryGetValue(eventArgs.Previous, out var panelsToDeactivate))
        {
            // Debug.Log($"[UIPanelRegistry] Deactivating panels for state: {eventArgs.Previous}");
            SetPanelActiveState(panelsToDeactivate, false);
        }

        // Activate panels associated with the new (current) state
        if (_panelLookup.TryGetValue(eventArgs.Current, out var panelsToActivate))
        {
            // Debug.Log($"[UIPanelRegistry] Activating panels for state: {eventArgs.Current}. Panel count: {panelsToActivate?.Length ?? 0}");
             SetPanelActiveState(panelsToActivate, true);
            // if (panelsToActivate != null) foreach(var p in panelsToActivate) if (p!=null) Debug.Log($" - Activating: {p.name}");
        }
        // else Debug.LogWarning($"[UIPanelRegistry] No panel mapping found for state: {eventArgs.Current}");
    }

    // Helper to activate/deactivate panels safely
    private void SetPanelActiveState(GameObject[] panels, bool isActive)
    {
         if (panels == null) return;
         foreach (var panel in panels)
         {
             if (panel != null) panel.SetActive(isActive);
             // else Debug.LogWarning("A null panel reference was found in UIPanelRegistry mapping.", this);
         }
    }

     // Deactivate all panels managed by this registry
    private void DeactivateAllManagedPanels()
    {
        // Added null check for safety during initial Awake runs
        if (_panelLookup == null) return;

        foreach (var kvp in _panelLookup)
        {
            SetPanelActiveState(kvp.Value, false);
        }
    }

    // Ensure cleanup on destroy
    private void OnDestroy() {
        Unhook(_hookedController);
    }
}
// --- End of script: Assets/Logic/UI/UIPanelRegistry.cs ---

// --- Start of script: Assets/Logic/UI/UIStateController.cs ---
using UnityEngine;
using System;

// Removed namespace

public enum UIState { Gameplay, Inventory, Menu }

public struct UIStateChanged
{
    public UIState Previous;
    public UIState Current;
    public UIStateChanged(UIState previous, UIState current) { Previous = previous; Current = current; }
}

/// <summary>
/// Manages the overall UI state enum (Gameplay, Inventory, Menu).
/// Fires events on change and informs the CursorController about UI open status.
/// Does NOT directly control cursor lock/visibility.
/// </summary>
public class UIStateController : MonoBehaviour
{
    [SerializeField] private UIState startState = UIState.Gameplay;
    public UIState Current { get; private set; }
    public event Action<UIStateChanged> OnStateChanged;

    // --- Cached State ---
    // Keep track of whether we last considered the UI "open" to only notify CursorController on change
    private bool _wasUIOpen = false;

    private void Start()
    {
        Current = startState;
        // Initialize the open state and notify CursorController immediately
        _wasUIOpen = IsUIOpen; // Calculate initial state
        CursorController.Instance.SetUIOpen(_wasUIOpen); // Inform controller
    }

    public void ToggleState(UIState targetState)
    {
        if (targetState == UIState.Gameplay) { if (Current != UIState.Gameplay) SetState(UIState.Gameplay); }
        else { SetState(Current == targetState ? UIState.Gameplay : targetState); }
    }

    public void SetState(UIState newState, bool force = false)
    {
        if (!force && newState == Current) return;

        UIState previousState = Current;
        Current = newState;

        // Fire state changed event for listeners like UIPanelRegistry, PlayerManager
        var eventArgs = new UIStateChanged(previousState, Current);
        OnStateChanged?.Invoke(eventArgs);

        // --- Notify Cursor Controller IF Open Status Changed ---
        bool isNowOpen = IsUIOpen; // Check the new open status
        if (isNowOpen != _wasUIOpen) // Did the open status change?
        {
            CursorController.Instance.SetUIOpen(isNowOpen); // Inform cursor controller
            _wasUIOpen = isNowOpen; // Update cached state
        }
        // --- End Notification ---

        // Debug.Log($"[UIStateController] State set to: {Current}");
    }

    /// <summary>
    /// Returns true if any UI panel (non-Gameplay state) is currently active.
    /// </summary>
    public bool IsUIOpen => Current != UIState.Gameplay;

    // REMOVED: All cursor locking/visibility logic (_isCursorTemporarilyUnlockedByDrag, UpdateCursorState, HandleDragStateChanged)
    // REMOVED: OnEnable/OnDisable related to SlotView.DraggingChanged
}
// --- End of script: Assets/Logic/UI/UIStateController.cs ---

// --- Start of script: Assets/Logic/Viewmodel/SwayHandler.cs ---
using UnityEngine;

public class SwayHandler : MonoBehaviour
{
    [Header("References")]
    [Tooltip("Assign the PlayerLook component from your player rig.")]
    [SerializeField] private PlayerLook playerLook;
    [Tooltip("Assign the Transform holding your viewmodel camera (often called EquipmentCamera).")]
    [SerializeField] private Transform weaponCamera;

    [Header("Sway Settings")]
    [Tooltip("Base sway strength applied at multiplier = 1.")]
    [SerializeField] private float defaultSwayMultiplier = 0.02f;
    [Tooltip("Current overall sway strength (default * multiplier).")]
    [SerializeField] private float currentSwayMultiplier;
    [SerializeField] private float maxSwayX = 0.06f;
    [SerializeField] private float maxSwayY = 0.06f;
    [SerializeField] private float swaySmoothness = 8f;

    private Vector3 initialCamLocalPosition;
    private Vector2 smoothedSwayDelta;
    private float previousYaw;
    private float previousPitch;

    private void Awake()
    {
        if (playerLook == null)
            playerLook = GetComponentInParent<PlayerLook>();

        if (weaponCamera == null)
        {
            Debug.LogError("[SwayHandler] Weapon Camera is not assigned!", this);
            enabled = false;
            return;
        }

        if (playerLook == null)
        {
            Debug.LogError("[SwayHandler] PlayerLook component not found or assigned!", this);
            enabled = false;
            return;
        }
    }

    private void Start()
    {
        initialCamLocalPosition = weaponCamera.localPosition;
        previousYaw = playerLook.CurrentYaw;
        previousPitch = playerLook.CurrentPitch;

        // Ensure we start with normal hip-fire sway
        currentSwayMultiplier = defaultSwayMultiplier;
    }

    private void LateUpdate()
    {
        if (playerLook == null || weaponCamera == null) return;

        // 1) Compute raw look delta
        float currentYaw = playerLook.CurrentYaw;
        float currentPitch = playerLook.CurrentPitch;
        float deltaYaw = Mathf.DeltaAngle(previousYaw, currentYaw);
        float deltaPitch = Mathf.DeltaAngle(previousPitch, currentPitch);
        previousYaw = currentYaw;
        previousPitch = currentPitch;
        Vector2 rawDelta = new Vector2(deltaYaw, deltaPitch);

        // 2) Smooth it
        smoothedSwayDelta = Vector2.Lerp(smoothedSwayDelta, rawDelta, Time.deltaTime * swaySmoothness);

        // 3) Compute offset (invert axes as needed)
        Vector3 swayOffset = new Vector3(
            Mathf.Clamp(-smoothedSwayDelta.x * currentSwayMultiplier, -maxSwayX, maxSwayX),
            Mathf.Clamp(smoothedSwayDelta.y  * currentSwayMultiplier, -maxSwayY, maxSwayY),
            0f
        );

        // 4) Debug visualization
        Debug.DrawLine(
            weaponCamera.parent.TransformPoint(initialCamLocalPosition),
            weaponCamera.parent.TransformPoint(initialCamLocalPosition + swayOffset),
            Color.cyan
        );

        // 5) Apply sway
        weaponCamera.localPosition = Vector3.Lerp(
            weaponCamera.localPosition,
            initialCamLocalPosition + swayOffset,
            Time.deltaTime * swaySmoothness
        );
    }
}
// --- End of script: Assets/Logic/Viewmodel/SwayHandler.cs ---

// --- Start of script: Assets/Logic/Viewmodel/ViewmodelMovementAnimator.cs ---
using UnityEngine;

public class ViewmodelMovementAnimator : MonoBehaviour
{
    [Header("References")]
    [SerializeField] private MyCharacterController characterMotor; // Your real movement controller
    [SerializeField] private Transform weaponCamera; // EquipmentCamera

    [Header("Animation Settings")]
    public float idleBobFrequency = 1.5f;
    public float idleBobAmplitude = 0.005f;

    public float walkBobFrequency = 6f;
    public float walkBobAmplitude = 0.015f;

    public float runBobFrequency = 10f;
    public float runBobAmplitude = 0.03f;

    public float bobSpeedMultiplier = 1f;
    public float bobSmoothness = 8f;

    [Header("Speed Thresholds")]
    public float walkSpeedThreshold = 1f;
    public float runSpeedThreshold = 5f;

    private Vector3 initialLocalPosition;
    private float bobTimer;
    private float currentFrequency;
    private float currentAmplitude;

    private void Awake()
    {
        if (weaponCamera == null)
            Debug.LogError("[ViewmodelMovementAnimator] WeaponCamera reference missing!");
    }

    private void Start()
    {
        if (weaponCamera != null)
            initialLocalPosition = weaponCamera.localPosition;
    }

    private void LateUpdate()
    {
        if (characterMotor == null || weaponCamera == null)
            return;

        // Get player horizontal velocity
        Vector3 flatVelocity = new Vector3(characterMotor.GetVelocity().x, 0f, characterMotor.GetVelocity().z);
        float speed = flatVelocity.magnitude;

        // Select bob settings based on speed
        if (speed < walkSpeedThreshold)
        {
            // Idle
            currentFrequency = idleBobFrequency;
            currentAmplitude = idleBobAmplitude;
        }
        else if (speed < runSpeedThreshold)
        {
            // Walking
            currentFrequency = walkBobFrequency;
            currentAmplitude = walkBobAmplitude;
        }
        else
        {
            // Running
            currentFrequency = runBobFrequency;
            currentAmplitude = runBobAmplitude;
        }

        // Bobbing over time
        bobTimer += Time.deltaTime * currentFrequency * bobSpeedMultiplier;
        Vector3 bobOffset = new Vector3(
            0f,
            Mathf.Sin(bobTimer) * currentAmplitude,
            0f
        );

        // Smoothly apply bobbing
        weaponCamera.localPosition = Vector3.Lerp(
            weaponCamera.localPosition,
            initialLocalPosition + bobOffset,
            Time.deltaTime * bobSmoothness
        );
    }
}
// --- End of script: Assets/Logic/Viewmodel/ViewmodelMovementAnimator.cs ---

// --- Start of script: Assets/Logic/Core/Interfaces/IAimProvider.cs ---
using UnityEngine;

public interface IAimProvider
{
    Vector3 GetAimHitPoint();
    Ray GetLookRay(); // Added GetLookRay here for consistency
    Transform GetLookTransform(); // Might be useful for weapons
}
// --- End of script: Assets/Logic/Core/Interfaces/IAimProvider.cs ---

// --- Start of script: Assets/Logic/Core/Interfaces/IEquipabbleInstance.cs ---
// In Assets/Scripts/Player/Equipment/IEquippableInstance.cs (or your path)

/// <summary>
/// Interface implemented by the MonoBehaviour component that handles the
/// actual behavior of an equipped item (like EquippableBehavior).
/// Defines the initialization method signature expected by RuntimeEquippable.
/// </summary>
public interface IEquippableInstance {
    /// <summary>
    /// Initializes the instance with its runtime data, the entity holding the equipment,
    /// and the aiming provider.
    /// </summary>
    void Initialize(
        InventoryItem itemInstance,         // The item being equipped
        IEquipmentHolder holder,          // The entity holding this item
        IAimProvider aimProvider       // The aiming system for the holder
    );
}
// --- End of script: Assets/Logic/Core/Interfaces/IEquipabbleInstance.cs ---

// --- Start of script: Assets/Logic/Core/Interfaces/IRuntimeItem.cs ---
// ========================
// IRuntimeItem.cs
// ========================
public interface IRuntimeItem
{
    InventoryItem GetInventoryItem();
    void SetInventoryItem(InventoryItem item);
    ItemData GetItemData(); // Optional helper for quick access
}
// --- End of script: Assets/Logic/Core/Interfaces/IRuntimeItem.cs ---

// --- Start of script: Assets/Logic/Core/Systems/CursorController.cs ---
using UnityEngine;

// Removed namespace

/// <summary>
/// Centralized manager for controlling the visibility and lock state of the mouse cursor.
/// Uses a Singleton pattern for easy access.
/// Other systems request state changes via public methods.
/// </summary>
public class CursorController : MonoBehaviour
{
    // --- Singleton Instance ---
    private static CursorController _instance;
    public static CursorController Instance
    {
        get
        {
            if (_instance == null)
            {
                // Use the new method
                _instance = FindFirstObjectByType<CursorController>();
                if (_instance == null)
                {
                    GameObject go = new GameObject("CursorController");
                    _instance = go.AddComponent<CursorController>();
                    Debug.LogWarning("CursorController instance was not found, creating one automatically.");
                }
            }
            return _instance;
        }
    }

    // --- State Flags ---
    private bool _isUIOpen = false;     // Is any major UI (Inventory, Menu) currently considered open?
    private bool _isDragging = false;   // Is a UI element currently being dragged?

    // Keep track of the last applied state to avoid redundant calls
    private CursorLockMode _lastAppliedLockMode = CursorLockMode.None;
    private bool _lastAppliedVisibility = true;

    private void Awake()
    {
        // Singleton enforcement
        if (_instance != null && _instance != this)
        {
            Debug.LogWarning("Duplicate CursorController detected. Destroying this instance.", gameObject);
            Destroy(gameObject);
            return;
        }
        _instance = this;

        // Optional: Persist across scenes if needed
        // DontDestroyOnLoad(gameObject);

        // Apply initial state based on default flags (usually gameplay)
        UpdateCursorState();
    }

    /// <summary>
    /// Updates the cursor lock/visibility based on the current state flags.
    /// This should be called whenever a relevant state flag changes.
    /// </summary>
    private void UpdateCursorState()
    {
        // Determine the desired state
        bool shouldUnlock = _isUIOpen || _isDragging; // Unlock if UI is open OR dragging is happening

        CursorLockMode targetLockMode = shouldUnlock ? CursorLockMode.None : CursorLockMode.Locked;
        bool targetVisibility = shouldUnlock;

        // Apply the state only if it has actually changed
        ApplyStateToUnityCursor(targetLockMode, targetVisibility);
    }

    /// <summary>
    /// Directly sets the Unity Cursor properties if they differ from the last applied state.
    /// </summary>
    private void ApplyStateToUnityCursor(CursorLockMode mode, bool visible)
    {
        if (Cursor.lockState != mode || Cursor.visible != visible) // Check if change is needed
        {
            // Debug.Log($"[CursorController] Applying State: LockMode={mode} (Was {_lastAppliedLockMode}), Visible={visible} (Was {_lastAppliedVisibility})");
            Cursor.lockState = mode;
            Cursor.visible = visible;

            _lastAppliedLockMode = mode;
            _lastAppliedVisibility = visible;
        }
        // else Debug.Log($"[CursorController] State Unchanged: LockMode={mode}, Visible={visible}");

    }


    // --- Public Methods for Other Systems to Call ---

    /// <summary>
    /// Call this when a major UI panel (Inventory, Menu, etc.) opens or closes.
    /// </summary>
    /// <param name="isOpen">True if the UI is now open, false if closed.</param>
    public void SetUIOpen(bool isOpen)
    {
        if (_isUIOpen != isOpen)
        {
            // Debug.Log($"[CursorController] SetUIOpen called: {isOpen}");
            _isUIOpen = isOpen;
            UpdateCursorState(); // Recalculate and apply cursor state
        }
    }

    /// <summary>
    /// Call this when a UI drag operation starts or stops.
    /// </summary>
    /// <param name="isDragging">True if dragging started, false if stopped.</param>
    public void SetDragging(bool isDragging)
    {
        if (_isDragging != isDragging)
        {
             // Debug.Log($"[CursorController] SetDragging called: {isDragging}");
            _isDragging = isDragging;
            UpdateCursorState(); // Recalculate and apply cursor state
        }
    }

     // Optional: Add a LateUpdate check as a safety net (usually not needed if Set methods are called correctly)
     // private void LateUpdate()
     // {
     //     UpdateCursorState(); // Ensures state is correct at end of frame
     // }
}
// --- End of script: Assets/Logic/Core/Systems/CursorController.cs ---

// --- Start of script: Assets/Logic/Core/Systems/TimeManager.cs ---
using UnityEngine;
using UnityEngine.Rendering;

[DisallowMultipleComponent]
public class TimeManager : MonoBehaviour
{
    [Header("Sun (Directional Light)")]
    [SerializeField] private Light sun;

    [Header("Clock")]
    [Tooltip("Real-time seconds for a whole 24-hour game day (timeScale = 1).")]
    public float realSecondsPerDay = 600f;
    [Range(0.1f, 30f)] public float timeScale = 1f;

    [Header("Start Time")]
    [Tooltip("At what time (in hours) the game day starts (0-24).")]
    [Range(0f, 24f)]
    public float startHour = 6f;  // Default = 6:00 AM

    [Header("Lighting Curves")]
    public AnimationCurve sunIntensityCurve;
    public AnimationCurve ambientIntensityCurve;
    public Gradient ambientColorGradient;

    [Header("Optional")]
    [SerializeField] private ReflectionProbe globalReflectionProbe;

    [Header("Stars")]
    [SerializeField] private Material starsMaterial;       // Stars material
    public AnimationCurve starsVisibilityCurve;             // ⭐ new curve to control star alpha

    // ───────── runtime read-outs ─────────
    public float CurrentTime01 { get; private set; }
    public int Hours   => Mathf.FloorToInt(CurrentTime01 * 24f);
    public int Minutes => Mathf.FloorToInt((CurrentTime01 * 24f % 1f) * 60f);

    public float curveT;
    public float currentSunIntensity;

    void Reset()
    {
        sun = FindAnyObjectByType<Light>();
        if (sun && sun.type != LightType.Directional) sun = null;
    }

    void Awake()
    {
        if (!sun) Debug.LogError("TimeManager: Please assign a Directional Light as Sun");
        RenderSettings.ambientMode = AmbientMode.Flat;

        // Initialize the day start
        CurrentTime01 = Mathf.Clamp01(startHour / 24f);
    }

    void Update()
    {
        float inc = Time.deltaTime / realSecondsPerDay * timeScale;
        CurrentTime01 = (CurrentTime01 + inc) % 1f;

        curveT = CurrentTime01;
        currentSunIntensity = sunIntensityCurve.Evaluate(curveT);

        UpdateSun();
        UpdateAmbient();
        UpdateStars(); // ⭐ new call for stars fading

        if (Time.frameCount % 120 == 0)
        {
            DynamicGI.UpdateEnvironment();
            if (globalReflectionProbe && globalReflectionProbe.enabled)
                globalReflectionProbe.RenderProbe();
        }
    }

    void UpdateSun()
    {
        if (!sun) return;
        float angle = CurrentTime01 * 360f - 90f;
        sun.transform.rotation = Quaternion.Euler(angle, 180f, 0f);
        sun.intensity = currentSunIntensity;
    }

    void UpdateAmbient()
    {
        RenderSettings.ambientIntensity = ambientIntensityCurve.Evaluate(CurrentTime01);
        RenderSettings.ambientLight = ambientColorGradient.Evaluate(CurrentTime01);
    }

    void UpdateStars()
    {
        if (!starsMaterial || starsVisibilityCurve == null) return;

        float starAlpha = Mathf.Clamp01(starsVisibilityCurve.Evaluate(CurrentTime01));

        Color baseColor = starsMaterial.GetColor("_BaseColor");
        baseColor.a = starAlpha;
        starsMaterial.SetColor("_BaseColor", baseColor);
    }

    void OnGUI()
    {
        const int boxW = 200, boxH = 100;
        GUI.Box(new Rect(10, 10, boxW, boxH), "Time / Debug");

        GUI.Label(new Rect(22, 32, 140, 20), $"Clock    : {Hours:00}:{Minutes:00}");
        GUI.Label(new Rect(22, 50, 140, 20), $"Curve t  : {curveT:F3}");
        GUI.Label(new Rect(22, 68, 140, 20), $"Sun Int. : {currentSunIntensity:F2}");

        GUI.Label(new Rect(22, 86, 15, 20), "×");
        timeScale = GUI.HorizontalSlider(new Rect(37, 91, 145, 15), timeScale, 0.1f, 30f);
    }
}
// --- End of script: Assets/Logic/Core/Systems/TimeManager.cs ---

// --- Start of script: Assets/Logic/Inventory/Core/InventoryItem.cs ---
using UnityEngine;

[System.Serializable]
public class InventoryItem
{
    public ItemData data;                       // static definition (SO)

    [SerializeReference] public IRuntimeState runtime;

    public bool IsStackable => data != null && data.stackable;

    // full constructor – used by complex items (weapons etc.)
    public InventoryItem(ItemData def, IRuntimeState payload)
    {
        data    = def;
        runtime = payload;
    }

    public InventoryItem(ItemData def)
    {
        data = def;
    }

    // parameter-less for the factory above
    private InventoryItem() { }
}
// --- End of script: Assets/Logic/Inventory/Core/InventoryItem.cs ---

// --- Start of script: Assets/Logic/Inventory/Core/InventorySlot.cs ---
using UnityEngine;

[System.Serializable]
public class InventorySlot
{
    public InventoryItem item;
    public int           quantity;

    public InventorySlot(InventoryItem item, int qty)
    {
        this.item     = item;
        this.quantity = qty;
    }

    /* ---------- helpers ---------- */
    /// <summary>
    /// Add to the stack without exceeding its max size.
    /// Returns the number actually added.
    /// </summary>
    public int AddQuantity(int amt)
    {
        if (item == null || amt <= 0) return 0;

        int max    = item.data.stackable ? Mathf.Max(1, item.data.maxStack) : 1;
        int space  = max - quantity;
        int added  = Mathf.Clamp(amt, 0, space);

        quantity += added;
        return added;
    }

    public bool HasEnough(int amt) => quantity >= amt;

    public void ReduceQuantity(int amt)
    {
        quantity = Mathf.Max(0, quantity - amt);
        if (quantity == 0) Clear();
    }

    public bool IsEmpty() => item == null || quantity <= 0;

    public void Clear()
    {
        item     = null;
        quantity = 0;
    }

    public bool IsFull() => item != null &&
                            quantity >= (item.data.stackable
                                         ? Mathf.Max(1, item.data.maxStack)
                                         : 1);
}
// --- End of script: Assets/Logic/Inventory/Core/InventorySlot.cs ---

// --- Start of script: Assets/Logic/Inventory/Core/ItemCategory.cs ---
public enum ItemCategory {
    Generic,
    Weapon,
    Tool,
    Ammo,
    Resource,
    Container,  // For items like jerry cans, water bottles
    CarPart,    // For all attachable vehicle components
    Attachment, // For weapon attachments
    KeyItem
}
// --- End of script: Assets/Logic/Inventory/Core/ItemCategory.cs ---

// --- Start of script: Assets/Logic/Inventory/Core/ItemContainer.cs ---
// In Assets/Scripts/Inventory/Core/ItemContainer.cs (or your path)
using System;
using UnityEngine;

/// <summary>
/// A reusable stack-based container (backpack, toolbar, magazine, etc.).
/// Manages an array of InventorySlots.
/// </summary>
[Serializable]
public class ItemContainer {
    public event Action<int> OnSlotChanged;  // -1 => structural change

    [SerializeField] private InventorySlot[] _slots;
    // Public accessor to view slots, but prevents replacing the array externally
    public InventorySlot[] Slots => _slots;

    #region Constructor
    /// <summary>
    /// Creates a new ItemContainer with a specified size, initializing all slots as empty.
    /// </summary>
    public ItemContainer(int size) {
        size = Mathf.Max(1, size); // Ensure size is at least 1
        _slots = new InventorySlot[size];
        for (int i = 0; i < size; i++) {
            // Ensure each slot is properly initialized
            _slots[i] = new InventorySlot(null, 0);
        }
    }
    #endregion

    #region Structure & Size
    /// <summary>
    /// Gets the current number of slots in the container.
    /// </summary>
    public int Size => _slots?.Length ?? 0; // Handles potential null _slots array

    /// <summary>
    /// Resizes the container's internal slot array to the new specified size.
    /// Preserves existing items up to the smaller of the old and new sizes.
    /// Initializes any newly created slots as empty.
    /// WARNING: Shrinking the size will discard items in the removed slots.
    /// </summary>
    /// <param name="newSize">The desired number of slots.</param>
    public void Resize(int newSize) {
        newSize = Mathf.Max(1, newSize); // Ensure new size is valid
        int oldSize = this.Size;

        if (newSize == oldSize) return; // No change needed

        // Create backup if needed (optional, Array.Resize handles copying)
        // InventorySlot[] oldSlotsBackup = new InventorySlot[oldSize];
        // Array.Copy(_slots, oldSlotsBackup, oldSize);

        // Use Array.Resize - automatically preserves elements up to Min(oldSize, newSize)
        Array.Resize(ref _slots, newSize);

        // If expanding, initialize the newly added slots
        if (newSize > oldSize) {
            for (int i = oldSize; i < newSize; i++) {
                // Check if the slot is null (Array.Resize might leave them null) and initialize
                if (_slots[i] == null) {
                    _slots[i] = new InventorySlot(null, 0);
                }
            }
        }
        // If shrinking, elements beyond newSize are automatically removed by Array.Resize.

        OnSlotChanged?.Invoke(-1); // Notify listeners of the structural change
    }

    /// <summary>
    /// Accessor for getting a specific slot by index.
    /// </summary>
    public InventorySlot this[int i] {
        get {
            if (_slots != null && i >= 0 && i < _slots.Length) {
                return _slots[i];
            }
            Debug.LogError($"[ItemContainer] Index {i} out of range (Size: {Size}). Returning null.");
            return null; // Return null or throw exception for invalid index
        }
        // Optionally add a 'set' accessor if you want to allow replacing entire slots, use with caution.
        // set { ... }
    }
    #endregion

    #region Item Management Helpers
    /// <summary>
    /// Adds an incoming InventoryItem (with quantity) to the container.
    /// Handles stacking for stackable items and places non-stackables in empty slots.
    /// Correctly handles adding non-stackable items with existing runtime state by reference.
    /// </summary>
    public void AddItem(InventoryItem incoming, int quantity = 1) {
        if (incoming == null || incoming.data == null || quantity <= 0) {
             Debug.LogWarning($"[ItemContainer] AddItem called with invalid item or quantity.");
             return;
        }

        // --- Non-Stackable Item Handling (Parts, Weapons, Tools with state) ---
        if (!incoming.IsStackable) {
            if (quantity > 1) Debug.LogWarning($"[ItemContainer] Non-stackable '{incoming.data.itemName}' added with quantity > 1. Storing only 1.");
            quantity = 1;

            // Find the first empty slot and place the *exact* InventoryItem reference
            for (int i = 0; i < Slots.Length; i++) {
                if (Slots[i].IsEmpty()) {
                    Slots[i].item = incoming; // Store the reference including runtime state
                    Slots[i].quantity = 1;
                    OnSlotChanged?.Invoke(i);
                    // Debug.Log($"[ItemContainer] Added non-stackable '{incoming.data.itemName}' to slot {i}.");
                    return; // Item placed
                }
            }
            // If no empty slot found
            Debug.LogWarning($"[ItemContainer] Inventory full – couldn’t add non-stackable item '{incoming.data.itemName}'.");
            return;
        }
        // --- End Non-Stackable Handling ---

        // --- Stackable Item Handling ---
        int maxPerStack = Mathf.Max(1, incoming.data.maxStack);
        int remaining = quantity;

        // 1. Try to top-up existing stacks of the same item type
        for (int i = 0; i < Slots.Length && remaining > 0; i++) {
            InventorySlot s = Slots[i];
            // Can stack if item data matches, slot isn't full, and runtime states are compatible
            // (Basic check: only stack if incoming item has NO runtime state, assumes existing stack also doesn't or it's okay)
            bool canStackOnto = !s.IsEmpty() && s.item.data == incoming.data && !s.IsFull() && (incoming.runtime == null); // TODO: More robust runtime state check if needed

            if (canStackOnto) {
                remaining -= s.AddQuantity(remaining); // AddQuantity handles clamping to maxStack
                if(remaining < quantity) OnSlotChanged?.Invoke(i); // Fire event only if quantity changed
            }
        }

        // 2. Place remaining into empty slots
        for (int i = 0; i < Slots.Length && remaining > 0; i++) {
            if (Slots[i].IsEmpty()) {
                int amountToAdd = Mathf.Min(maxPerStack, remaining);
                // For simple stackables (no runtime state), create a new InventoryItem instance for the slot
                // If it *did* have runtime state but was stackable (rare), you'd pass 'incoming' directly.
                InventoryItem itemForNewSlot = (incoming.runtime == null) ? new InventoryItem(incoming.data) : incoming;

                Slots[i] = new InventorySlot(itemForNewSlot, amountToAdd); // Create new slot entry
                remaining -= amountToAdd;
                OnSlotChanged?.Invoke(i);
            }
        }

        // Log if any items couldn't be added
        if (remaining > 0) {
            Debug.LogWarning($"[ItemContainer] Inventory full – couldn’t add {remaining} × {incoming.data.itemName}.");
        }
    }

    /// <summary>
    /// Attempts to consume (remove) a specified amount of an item type from the container.
    /// Will remove from multiple stacks if necessary.
    /// </summary>
    /// <returns>True if the full amount was consumed, false otherwise.</returns>
    public bool TryConsumeItem(ItemData data, int amount = 1) {
        if (data == null || amount <= 0) return false;

        // Check total available first (optimization)
        if (!HasItem(data, amount)) {
             // Debug.LogWarning($"[ItemContainer] Cannot consume {amount}x {data.itemName} - Not enough available.");
             return false;
        }

        // Burn across stacks
        int remainingToConsume = amount;
        for (int i = 0; i < Slots.Length && remainingToConsume > 0; i++) {
            InventorySlot s = Slots[i];
            if (!s.IsEmpty() && s.item.data == data) {
                int take = Mathf.Min(s.quantity, remainingToConsume);
                s.ReduceQuantity(take); // ReduceQuantity handles clearing the slot if it becomes empty
                remainingToConsume -= take;
                OnSlotChanged?.Invoke(i); // Notify slot changed
            }
        }
        // Should always return true if HasItem check passed, unless logic error
        return remainingToConsume == 0;
    }

    /// <summary>
    /// Attempts to withdraw a quantity of items matching ItemData from this container
    /// and add it to a target InventorySlot. Used primarily for splitting stacks.
    /// </summary>
    /// <returns>True if the full amount was successfully withdrawn, false otherwise.</returns>
    public bool Withdraw(ItemData data, int amount, InventorySlot targetSlot) {
        if (data == null || amount <= 0 || targetSlot == null) return false;
        if (!HasItem(data, amount)) return false; // Check if enough exists first

        int remainingToWithdraw = amount;
        for (int i = 0; i < Slots.Length && remainingToWithdraw > 0; i++) {
            InventorySlot src = Slots[i];
            if (!src.IsEmpty() && src.item.data == data) {
                int take = Mathf.Min(src.quantity, remainingToWithdraw);

                // Add to target slot (handles creating item if target is empty)
                if (targetSlot.item == null) targetSlot.item = new InventoryItem(data); // Assume simple stackable for withdrawal target
                int actuallyAdded = targetSlot.AddQuantity(take); // Use target slot's logic

                // Only reduce source if successfully added to target
                if (actuallyAdded > 0) {
                     src.ReduceQuantity(actuallyAdded); // Reduce source by amount added
                     remainingToWithdraw -= actuallyAdded;
                     OnSlotChanged?.Invoke(i); // Notify source slot changed
                }

                 // If target slot became full, stop trying to add more to it in this iteration
                 if (targetSlot.IsFull()) break; // Exit withdraw loop early if target is full

                 // Safety break if AddQuantity somehow didn't add anything when it should have
                 if (actuallyAdded == 0 && take > 0) {
                     Debug.LogWarning($"[ItemContainer Withdraw] targetSlot.AddQuantity added 0 despite available space/quantity. Aborting withdraw.");
                     break; // Avoid infinite loop
                 }
            }
        }
        // Return true only if the full requested amount was withdrawn
        return remainingToWithdraw == 0;
    }

    /// <summary>
    /// Merges stackable items or swaps items between two slot indices.
    /// </summary>
    public void MergeOrSwap(int indexA, int indexB) {
        if (indexA < 0 || indexB < 0 || indexA >= Size || indexB >= Size || indexA == indexB) return;

        InventorySlot slotA = Slots[indexA];
        InventorySlot slotB = Slots[indexB];

        // --- Attempt Merge (Only if both are same STACKABLE item type) ---
        if (!slotA.IsEmpty() && !slotB.IsEmpty() &&
            slotA.item.data == slotB.item.data &&
            slotA.item.data.stackable) // Only merge stackables
        {
            int maxStack = Mathf.Max(1, slotA.item.data.maxStack);
            int spaceInB = maxStack - slotB.quantity;

            if (spaceInB > 0) { // If slot B has space
                int amountToMove = Mathf.Min(slotA.quantity, spaceInB); // Move as much as possible from A
                if (amountToMove > 0) {
                    slotB.AddQuantity(amountToMove); // Add to B
                    slotA.ReduceQuantity(amountToMove); // Remove from A
                    OnSlotChanged?.Invoke(indexA);
                    OnSlotChanged?.Invoke(indexB);
                    return; // Merge successful
                }
            }
            // If B was full, try merging into A instead (optional optimization)
            int spaceInA = maxStack - slotA.quantity;
             if (spaceInA > 0) {
                 int amountToMove = Mathf.Min(slotB.quantity, spaceInA);
                 if (amountToMove > 0) {
                     slotA.AddQuantity(amountToMove);
                     slotB.ReduceQuantity(amountToMove);
                     OnSlotChanged?.Invoke(indexA);
                     OnSlotChanged?.Invoke(indexB);
                     return;
                 }
             }
        }

        // --- If Merge wasn't possible or didn't happen, SWAP the slots ---
        (_slots[indexA], _slots[indexB]) = (_slots[indexB], _slots[indexA]); // C# Tuple Swap
        OnSlotChanged?.Invoke(indexA);
        OnSlotChanged?.Invoke(indexB);
    }

    /// <summary>
    /// Checks if the container holds at least a certain amount of a specific item type.
    /// </summary>
    /// <returns>True if the required amount is found, false otherwise.</returns>
    public bool HasItem(ItemData itemData, int amount = 1) {
        if (itemData == null || amount <= 0) return false;
        int count = 0;
        if (_slots == null) return false; // Safety check

        foreach (var slot in Slots) {
            if (slot != null && !slot.IsEmpty() && slot.item.data == itemData) {
                count += slot.quantity;
                if (count >= amount) return true; // Exit early if enough found
            }
        }
        return false; // Went through all slots, not enough found
    }
    #endregion

} // End of ItemContainer class
// --- End of script: Assets/Logic/Inventory/Core/ItemContainer.cs ---

// --- Start of script: Assets/Logic/Inventory/Logic/IInventoryViewDataSource.cs ---
using System;

/// <summary>
/// Interface for providing inventory data to a UI manager.
/// </summary>
public interface IInventoryViewDataSource
{
    int SlotCount { get; }
    InventorySlot GetSlotByIndex(int index);
    event Action<int> OnSlotChanged; // int = index of changed slot, -1 for structural change

    // Callback for UI actions
    void RequestMergeOrSwap(int fromIndex, int toIndex);
    // Add other requests if needed (e.g., RequestDrop, RequestUse)
}
// --- End of script: Assets/Logic/Inventory/Logic/IInventoryViewDataSource.cs ---

// --- Start of script: Assets/Logic/Inventory/Logic/InventoryComponent.cs ---
// In Assets/Scripts/Player/Inventory/InventoryComponent.cs (or your path)
using UnityEngine;
using System;

[DisallowMultipleComponent]
public class InventoryComponent : MonoBehaviour
{
    [Tooltip("The desired size of the inventory container when the game starts.")]
    [SerializeField] private int initialSize = 30;

    [Tooltip("The actual data container for inventory items. Can be pre-populated in Inspector.")]
    [SerializeField] private ItemContainer container; // Serialized field

    public ItemContainer Container => container;

    private void Awake()
    {
        // Debug.Log($"[InventoryComponent AWAKE on {gameObject.name}] Called.", this); // Removed
        InitializeContainer();
        // Debug.Log($"[InventoryComponent AWAKE on {gameObject.name}] Finished. Container: {(container == null ? "NULL" : $"Size={container.Size}")}", this); // Removed
    }

    private void InitializeContainer()
    {
        initialSize = Mathf.Max(1, initialSize);
        // Debug.Log($"[InventoryComponent InitializeContainer] Current: {(container == null ? "NULL" : "EXISTS")}, Target: {initialSize}", this); // Removed

        if (container == null)
        {
            // Debug.Log($"[InventoryComponent InitializeContainer] Container was null. Creating new size {initialSize}.", this); // Removed
            container = new ItemContainer(initialSize);
        }
        else
        {
            int currentSerializedSize = container.Slots != null ? container.Slots.Length : 0;
            if (currentSerializedSize != initialSize)
            {
                // Debug.Log($"[InventoryComponent InitializeContainer] Resizing from {currentSerializedSize} to {initialSize}.", this); // Removed
                container.Resize(initialSize);
            }
            else
            {
                 // Optional: Check for null slots within existing container - keep warning if useful
                 bool neededInitialization = false;
                 for(int i = 0; i < container.Slots.Length; i++) {
                     if(container.Slots[i] == null) {
                         container.Slots[i] = new InventorySlot(null, 0);
                         neededInitialization = true;
                     }
                 }
                 if(neededInitialization) Debug.LogWarning($"[InventoryComponent on {gameObject.name}] Initialized null slots within existing container.", this); // Keep useful warning
            }
        }
        // Error checking after initialization attempt
        if (container == null) Debug.LogError($"[InventoryComponent InitializeContainer] CONTAINER IS STILL NULL AFTER INIT!", this); // Keep error
        else if (container.Slots == null) Debug.LogError($"[InventoryComponent InitializeContainer] CONTAINER.SLOTS IS NULL AFTER INIT!", this); // Keep error
        // else Debug.Log($"[InventoryComponent InitializeContainer] Container ready. Slot count: {container.Slots.Length}", this); // Removed success log
    }
}
// --- End of script: Assets/Logic/Inventory/Logic/InventoryComponent.cs ---

// --- Start of script: Assets/Logic/Inventory/Logic/PlayerInventory.cs ---
// --- Start of script: Assets/Logic/Inventory/Logic/PlayerInventory.cs ---
using System;
using UnityEngine;
using System.Linq;

[DisallowMultipleComponent]
[RequireComponent(typeof(InventoryComponent))]
public class PlayerInventory : MonoBehaviour, IInventoryViewDataSource, IEquipmentHolder {
    [Header("Components")]
    [SerializeField] private InventoryComponent inventoryComp;
    [SerializeField] private ToolbarSelector toolbarSelector;

    public ToolbarSelector Toolbar => toolbarSelector;
    public ItemContainer Container => inventoryComp?.Container;

    public event Action<int> OnSlotChanged;
    public event Action<InventoryItem> OnEquippedItemChanged;
    public event Action<InventoryItem> OnItemPulledFromInventory;

    private InventoryItem _equippedCache; // Cache of the item in the currently selected toolbar slot

    public ItemContainer GetContainerForInventory() => inventoryComp?.Container;
    public InventoryItem GetCurrentEquippedItem() => _equippedCache; // Return the cached item

    public bool RequestAddItemToInventory(InventoryItem itemToAdd) {
        if (Container == null || itemToAdd == null || itemToAdd.data == null) {
            Debug.LogWarning("[PlayerInventory] Cannot add item - Container or item/data is null.");
            return false;
        }
        if (itemToAdd.data.isBulky) {
             Debug.LogWarning($"[PlayerInventory] Cannot add bulky item '{itemToAdd.data.itemName}' to main inventory.");
            return false; // Cannot add bulky items this way
        }
        Container.AddItem(itemToAdd, itemToAdd.IsStackable ? 1 : 1); // Add appropriate quantity (usually 1)
        // Verification after AddItem (AddItem handles logging failure)
        bool check = Container.HasItem(itemToAdd.data); // Simpler check
        // if (!check) Debug.LogWarning($"[PlayerInventory] AddItem verification failed for '{itemToAdd.data.itemName}'.");
        return check; // Return true if item is now present (might have stacked)
    }

    public bool TryStoreItemInSpecificSlot(InventoryItem itemToAdd, int slotIndex) {
        if (Container == null || itemToAdd == null || itemToAdd.data == null || slotIndex < 0 || slotIndex >= Container.Size) {
            return false;
        }
         // Check if trying to put bulky item in toolbar
        if (itemToAdd.data.isBulky && toolbarSelector != null && slotIndex < toolbarSelector.SlotCount) {
            Debug.LogWarning($"[PlayerInventory] Cannot store bulky item '{itemToAdd.data.itemName}' in toolbar slot {slotIndex}.");
            return false;
        }
        InventorySlot targetSlot = Container[slotIndex];
        if (targetSlot == null) {
            Debug.LogError($"[PlayerInventory] Target slot {slotIndex} is null in Container!");
            return false;
        }
        bool changed = false;
        if (targetSlot.IsEmpty()) {
            targetSlot.item = itemToAdd;
            targetSlot.quantity = 1; // Assume adding one non-stackable or the first of a stack
            changed = true;
        } else if (targetSlot.item.data == itemToAdd.data && targetSlot.item.IsStackable && !targetSlot.IsFull() && itemToAdd.runtime == null && targetSlot.item.runtime == null) {
            int added = targetSlot.AddQuantity(1); // Add one unit
            if (added > 0) {
                changed = true;
                // Note: If adding stackable item, we assume itemToAdd itself isn't kept, just its data/type is used.
            }
        }
        // else: Cannot store (slot occupied by different item, or full stackable)

        if (changed) {
            // IMPORTANT: Notify listeners AFTER making the change
            this.OnSlotChanged?.Invoke(slotIndex);
            // Check if the change affected the equipped item cache IMMEDIATELY
            HandleContainerSlotChangedForEquip(slotIndex); // Ensure cache updates if toolbar affected
            return true;
        }
        return false;
    }

    public bool CanAddItemToInventory(InventoryItem itemToCheck, int quantity = 1) {
        if (Container == null || itemToCheck == null || itemToCheck.data == null) return false;
        if (itemToCheck.data.isBulky) return false; // Cannot add bulky to main inventory this way

        // Check if there's space, considering stacking
        int remainingToAdd = quantity;

        // Check existing stacks
        if (itemToCheck.IsStackable) {
            foreach (var slot in Container.Slots) {
                if (!slot.IsEmpty() && slot.item.data == itemToCheck.data && !slot.IsFull() && slot.item.runtime == null) // Only stack simple items
                {
                    int canAdd = Mathf.Max(1, slot.item.data.maxStack) - slot.quantity;
                    remainingToAdd -= canAdd;
                    if (remainingToAdd <= 0) return true; // Enough space found in existing stacks
                }
            }
        }

        // Check empty slots
        foreach (var slot in Container.Slots) {
            if (slot.IsEmpty()) {
                int canAdd = itemToCheck.IsStackable ? Mathf.Max(1, itemToCheck.data.maxStack) : 1;
                remainingToAdd -= canAdd;
                if (remainingToAdd <= 0) return true; // Enough space found in empty slots
            }
        }

        return false; // Not enough space
     }

     public bool RequestConsumeItem(ItemData itemData, int amount = 1) {
        return Container?.TryConsumeItem(itemData, amount) ?? false;
     }
     public bool HasItemInInventory(ItemData itemData, int amount = 1) {
        return Container?.HasItem(itemData, amount) ?? false;
     }

    // --- MODIFIED METHOD ---
    /// <summary>
    /// Attempts to remove one item from the specified inventory slot.
    /// Handles stack splitting and updates the equipped cache if the selected slot changes.
    /// </summary>
    public bool TryPullItemFromSlot(int slotIndex, out InventoryItem pulledItem) {
        pulledItem = null;
        if (Container == null) return false;
        if (slotIndex < 0 || slotIndex >= Container.Size) return false;

        InventorySlot sourceSlot = Container[slotIndex];
        if (sourceSlot == null || sourceSlot.IsEmpty()) {
            return false; // Nothing to pull
        }

        bool success = false;
        if (sourceSlot.quantity > 1 && sourceSlot.item.IsStackable) {
            // --- Stack Splitting ---
            // Create a NEW InventoryItem instance for the single item being pulled.
             pulledItem = new InventoryItem(sourceSlot.item.data); // Simple copy for basic stackables
             // TODO: If stackable items *can* have runtime state, implement state cloning here.
             sourceSlot.ReduceQuantity(1); // Decrease quantity in the original slot
             success = true;
        } else if (sourceSlot.quantity == 1) {
            // --- Taking the Last Item ---
            pulledItem = sourceSlot.item; // Take the reference
            sourceSlot.Clear(); // Clear the source slot entirely
            success = true;
        } else {
            Debug.LogError($"[PlayerInventory] PullItem: Slot {slotIndex} quantity logic error. Qty: {sourceSlot.quantity}");
            success = false;
        }

        if (success) {
            // Notify listeners about the change *after* modifying the slot
            OnSlotChanged?.Invoke(slotIndex);
            OnItemPulledFromInventory?.Invoke(pulledItem);

            // *** CRITICAL: Immediately update equipped cache if this was the selected slot ***
            if (toolbarSelector != null && slotIndex == toolbarSelector.CurrentIndex) {
                RefreshEquippedItem(); // Force cache refresh NOW
            }
            return true;
        }
        return false;
    }
    // --- END MODIFIED METHOD ---

    // --- IInventoryViewDataSource Implementation ---
    public int SlotCount => Container?.Size ?? 0;
    public InventorySlot GetSlotByIndex(int index) => GetSlotAt(index);
    public void RequestMergeOrSwap(int fromIndex, int toIndex) {
        Container?.MergeOrSwap(fromIndex, toIndex);
        // Update cache if merge/swap affects selected slot
        int selectedIdx = GetSelectedToolbarIndex();
        if(fromIndex == selectedIdx || toIndex == selectedIdx) {
            RefreshEquippedItem();
        }
    }
    // --- End IInventoryViewDataSource ---

    // --- Initialization and Event Handling ---
    private void Awake() {
        inventoryComp = GetComponent<InventoryComponent>();
        if (inventoryComp == null) {
             Debug.LogError($"[PlayerInventory AWAKE on {gameObject.name}] CRITICAL: InventoryComponent is NULL! PlayerInventory cannot function.", this);
             this.enabled = false;
             return;
        }
        // Container should be initialized by InventoryComponent's Awake
        toolbarSelector ??= GetComponentInChildren<ToolbarSelector>(true);
        if (toolbarSelector == null) Debug.LogError($"[PlayerInventory on {gameObject.name}] ToolbarSelector missing!", this);
    }
    private void Start() {
         if (Container == null) {
             Debug.LogError($"[PlayerInventory START on {gameObject.name}] Container IS NULL. Check InventoryComponent's Awake/Initialization.", this);
         } else {
             // Subscribe after container confirmed non-null
            SubscribeToEvents();
            InitializeEquipmentState(); // Initial equip based on starting selection
         }
    }
    private void OnEnable() {
        // Re-subscribe and initialize state if re-enabled after Start
        if (inventoryComp?.Container != null) {
            SubscribeToEvents();
            InitializeEquipmentState();
        }
    }
    private void OnDisable() { UnsubscribeFromEvents(); }

    private void SubscribeToEvents() {
        UnsubscribeFromEvents(); // Prevent double subscription
        if (toolbarSelector != null) toolbarSelector.OnIndexChanged += HandleToolbarIndexChanged;
        if (inventoryComp?.Container != null) inventoryComp.Container.OnSlotChanged += HandleInternalContainerSlotChanged;
        else Debug.LogWarning("[PlayerInventory] Cannot subscribe to Container events - Container is null.");
    }
    private void UnsubscribeFromEvents() {
        if (toolbarSelector != null) toolbarSelector.OnIndexChanged -= HandleToolbarIndexChanged;
        // Check container exists before unsubscribing
        if (inventoryComp?.Container != null) inventoryComp.Container.OnSlotChanged -= HandleInternalContainerSlotChanged;
    }

    private void HandleInternalContainerSlotChanged(int index) {
        // Forward the event for the UI
        this.OnSlotChanged?.Invoke(index);
        // Check if the change affects the equipped item
        HandleContainerSlotChangedForEquip(index);
    }

    private void HandleToolbarIndexChanged(int newIndex) { RefreshEquippedItem(); }

    private void HandleContainerSlotChangedForEquip(int index) {
        // If index is -1 (structural change) or the changed slot is the currently selected toolbar slot, refresh equipped item
        if (index < 0) {
             RefreshEquippedItem();
             return;
        }
        if (toolbarSelector != null && index < toolbarSelector.SlotCount && index == toolbarSelector.CurrentIndex) {
            RefreshEquippedItem();
        }
    }

    public void HandleToolbarScroll(float scrollDirection) => toolbarSelector?.Step((int)Mathf.Sign(scrollDirection));
    public void HandleToolbarSlotSelection(int slotIndex) => toolbarSelector?.SetIndex(slotIndex);

    private void InitializeEquipmentState() {
        // Trigger initial check based on toolbar's starting index
        if (toolbarSelector != null && Container != null) {
             HandleToolbarIndexChanged(toolbarSelector.CurrentIndex);
        } else {
            RefreshEquippedItem(); // Fallback if toolbar/container not ready
        }
    }

    // --- MODIFIED METHOD ---
    /// <summary>
    /// Updates the _equippedCache based on the item currently in the selected toolbar slot.
    /// Explicitly reads the slot content NOW.
    /// </summary>
    private void RefreshEquippedItem() {
        InventoryItem newItemInSlot = null;
        int selectedIdx = GetSelectedToolbarIndex();

        if (selectedIdx >= 0 && Container != null && selectedIdx < Container.Size) {
            InventorySlot slot = GetSlotAt(selectedIdx); // Get the current state of the slot
            if (slot != null && !slot.IsEmpty()) {
                newItemInSlot = slot.item; // Get the item reference directly from the slot
            }
            // If slot is null or empty, newItemInSlot remains null
        }
        // else: No valid selection or container, newItemInSlot remains null

        // Update cache and fire event ONLY if the item reference has actually changed
        if (newItemInSlot != _equippedCache) {
            _equippedCache = newItemInSlot; // Update the cache
            // Debug.Log($"[PlayerInventory] Equipped Cache Updated. Now: {(_equippedCache?.data?.itemName ?? "NULL")}");
            OnEquippedItemChanged?.Invoke(_equippedCache); // Notify EquipmentController
        }
    }
    // --- END MODIFIED METHOD ---

    public InventorySlot GetSlotAt(int i) {
         if (Container != null && i >= 0 && i < Container.Size) return Container[i]; return null;
    }
    public int GetSelectedToolbarIndex() => toolbarSelector?.CurrentIndex ?? -1;

}
// --- End of script: Assets/Logic/Inventory/Logic/PlayerInventory.cs ---

// --- Start of script: Assets/Logic/Inventory/Runtime/EquipTransitionAnimator.cs ---
using System.Collections;
using UnityEngine;

public class EquipTransitionAnimator : MonoBehaviour
{
    public float duration = 0.3f;
    public Vector3 offset = new Vector3(0f, -0.3f, -0.2f);
    public AnimationCurve curve = AnimationCurve.EaseInOut(0, 0, 1, 1);

    private Vector3 originalPosition;
    private bool isAnimating;

    public bool IsPlaying => isAnimating;

    private void Awake()
    {
        originalPosition = transform.localPosition;
    }

    public void Play(System.Action onComplete)
    {
        if (isAnimating)
            StopAllCoroutines(); // 🚨 Cancel previous animation safely

        StartCoroutine(Animate(onComplete));
    }

    private IEnumerator Animate(System.Action onComplete)
    {
        isAnimating = true;

        Transform target = transform;
        Vector3 start = originalPosition + offset;
        Vector3 end = originalPosition;

        float t = 0f;
        while (t < duration)
        {
            t += Time.deltaTime;
            float eased = curve.Evaluate(t / duration);
            target.localPosition = Vector3.Lerp(start, end, eased);
            yield return null;
        }

        target.localPosition = end;
        isAnimating = false;
        onComplete?.Invoke();
    }
}
// --- End of script: Assets/Logic/Inventory/Runtime/EquipTransitionAnimator.cs ---

// --- Start of script: Assets/Logic/Inventory/Runtime/FirearmRuntimeState.cs ---
using UnityEngine;
using System; // For Serializable

[Serializable]
public class FirearmRuntimeState : IRuntimeState, ICloneableRuntimeState {

    [SerializeField] public ItemContainer magazine;
    [SerializeField] public ItemContainer attachments;
    [SerializeField] public int durability = 100; // Example simple durability

    // Constructor needed for setting container sizes
    public FirearmRuntimeState(int attachmentSlots = 0, int initialDurability = 100) {
        magazine = new ItemContainer(1); // Fixed size 1
        attachments = new ItemContainer(Mathf.Max(0, attachmentSlots));
        durability = initialDurability;
    }
    // Parameterless constructor needed by Unity Serializer sometimes
    public FirearmRuntimeState() : this(0, 100) {}

    public IRuntimeState Clone() {
        // Deep clone needed for containers
        FirearmRuntimeState clone = new FirearmRuntimeState(this.attachments?.Size ?? 0, this.durability);
        DeepCloneItemContainer(this.magazine, clone.magazine);
        DeepCloneItemContainer(this.attachments, clone.attachments);
        return clone;
    }

    // Deep Cloning Helper (Move to static Utility class recommended)
    private static void DeepCloneItemContainer(ItemContainer source, ItemContainer destination) {
         if (source == null || destination == null) return;
         if (destination.Size < source.Size) destination.Resize(source.Size);
         for (int i = 0; i < source.Size; i++) {
             InventorySlot sSlot = source.Slots[i];
             if (sSlot != null && !sSlot.IsEmpty() && sSlot.item != null && sSlot.item.data != null) {
                 IRuntimeState nestedClonedState = (sSlot.item.runtime as ICloneableRuntimeState)?.Clone();
                 InventoryItem clonedItem = new InventoryItem(sSlot.item.data, nestedClonedState);
                 destination.Slots[i] = new InventorySlot(clonedItem, sSlot.quantity);
             } else { destination.Slots[i] = new InventorySlot(null, 0); }
         }
         for (int i = source.Size; i < destination.Size; i++) { destination.Slots[i] = new InventorySlot(null, 0); }
    }
}
// --- End of script: Assets/Logic/Inventory/Runtime/FirearmRuntimeState.cs ---

// --- Start of script: Assets/Logic/Inventory/Runtime/IRuntimeState.cs ---
/// <summary>
/// Marker interface for per-instance runtime payloads
/// (magazine, durability, cooldown data, etc.).
/// </summary>
public interface IRuntimeState { }
// --- End of script: Assets/Logic/Inventory/Runtime/IRuntimeState.cs ---

// --- Start of script: Assets/Logic/Inventory/UI/InventoryUIManager.cs ---
using UnityEngine;
using System; // Keep for Action

// Removed namespace

public class InventoryUIManager : MonoBehaviour
{
    [Header("UI Element Parents")]
    [SerializeField] private Transform toolbarParent;
    [SerializeField] private Transform bagParent;

    [Header("Visuals")]
    [SerializeField] private Color selectedColor = Color.yellow;
    [SerializeField] private Color normalColor = Color.white;

    [Header("Prefabs")]
    [SerializeField] private SlotView slotPrefab;

    [Header("Sub-Panels")]
    [SerializeField] private ItemDetailUI detailPanel;

    private SlotView[] _toolbarViews = Array.Empty<SlotView>(); // Initialize to empty array
    private SlotView[] _bagViews = Array.Empty<SlotView>();     // Initialize to empty array
    private IInventoryViewDataSource _currentDataSource;
    private ToolbarSelector _linkedToolbarSelector; // Store reference for unsubscribing

    // Show the UI for a specific data source
    public void Show(IInventoryViewDataSource dataSource)
    {
        if (dataSource == null)
        {
            Debug.LogError("[InventoryUIManager] Cannot show Inventory UI with a null data source!");
            Hide();
            return;
        }

        _currentDataSource = dataSource;
        InitializeSlots(); // Setup slot views first

        // Subscribe to data source for content changes
        if (_currentDataSource != null)
        {
             // Debug.Log("[InventoryUIManager] Subscribing to DataSource.OnSlotChanged");
            _currentDataSource.OnSlotChanged += HandleSlotChanged;
        }

        // --- Subscribe to Toolbar for Highlight Changes ---
        _linkedToolbarSelector = null; // Reset previous link
        if (_currentDataSource is PlayerInventory playerInv && playerInv.Toolbar != null)
        {
            _linkedToolbarSelector = playerInv.Toolbar; // Store the reference
            // Debug.Log("[InventoryUIManager] Subscribing to ToolbarSelector.OnIndexChanged for highlighting.");
            _linkedToolbarSelector.OnIndexChanged += UpdateHighlight; // Subscribe UI method
        }
        else Debug.LogWarning("[InventoryUIManager] Cannot subscribe to ToolbarSelector: DataSource is not PlayerInventory or Toolbar is null.");
        // --- End Toolbar Subscription ---

        RedrawAll(); // Initial draw including highlight
        gameObject.SetActive(true);
        detailPanel?.Hide();
    }

    // Hide the UI and unsubscribe
    public void Hide()
    {
        gameObject.SetActive(false);

        // Unsubscribe from data source
        if (_currentDataSource != null)
        {
            // Debug.Log("[InventoryUIManager] Unsubscribing from DataSource.OnSlotChanged");
            _currentDataSource.OnSlotChanged -= HandleSlotChanged;
        }

        // Unsubscribe from Toolbar
        if (_linkedToolbarSelector != null)
        {
             // Debug.Log("[InventoryUIManager] Unsubscribing from ToolbarSelector.OnIndexChanged.");
             _linkedToolbarSelector.OnIndexChanged -= UpdateHighlight;
        }

        _currentDataSource = null;
        _linkedToolbarSelector = null; // Clear reference
    }

    // Creates/finds SlotView instances under parents
    private void InitializeSlots()
    {
        _toolbarViews = toolbarParent?.GetComponentsInChildren<SlotView>(true) ?? Array.Empty<SlotView>();
        _bagViews = bagParent?.GetComponentsInChildren<SlotView>(true) ?? Array.Empty<SlotView>();

        int totalUISlots = _toolbarViews.Length + _bagViews.Length;
        if (_currentDataSource != null && _currentDataSource.SlotCount != totalUISlots && totalUISlots > 0)
        {
            Debug.LogWarning($"Inventory UI has {totalUISlots} slots, but data source has {_currentDataSource.SlotCount}. UI may not show all items.");
        }

        int idx = 0;
        foreach (var v in _toolbarViews) if(v != null) v.Setup(idx++, this);
        foreach (var v in _bagViews) if(v != null) v.Setup(idx++, this);
    }

    // --- UI Interaction Requests ---
    public void RequestMergeOrSwap(int fromSlotIndex, int toSlotIndex) =>
        _currentDataSource?.RequestMergeOrSwap(fromSlotIndex, toSlotIndex);

    public void RequestInspect(int slotIndex)
    {
        if (_currentDataSource == null || detailPanel == null) return;
        var slot = _currentDataSource.GetSlotByIndex(slotIndex);
        if (slot == null || slot.IsEmpty()) detailPanel.Hide();
        else detailPanel.ShowFor(slot.item, slot.quantity, slotIndex);
    }

    // --- Drawing Logic ---
    private void RedrawAll()
    {
        if (_currentDataSource == null) return;

        // Draw content
        int uiSlotIndex = 0;
        foreach (var view in _toolbarViews) if (view != null) Draw(view, _currentDataSource.GetSlotByIndex(uiSlotIndex++));
        foreach (var view in _bagViews) if (view != null) Draw(view, _currentDataSource.GetSlotByIndex(uiSlotIndex++));

        // Set initial highlight
        UpdateHighlight(_linkedToolbarSelector?.CurrentIndex ?? 0); // Use stored selector's index or default
    }

    // Called by data source when slot content changes
    private void HandleSlotChanged(int index)
    {
        // Debug.Log($"[InventoryUIManager] HandleSlotChanged received index: {index}");
        if (_currentDataSource == null) return;

        if (index == -1) // Structural change
        {
            InitializeSlots(); // Re-find/setup views
            RedrawAll();      // Redraw everything including highlight
        }
        else if (index >= 0) // Single slot change
        {
            UpdateSingleSlot(index); // Update only the affected slot's content
        }
    }

    // Updates the icon/quantity of a single slot view
    private void UpdateSingleSlot(int index)
    {
        SlotView view = GetViewForIndex(index);
        if (view != null)
        {
            // Debug.Log($"[InventoryUIManager] Updating view for Slot Index: {index}");
            Draw(view, _currentDataSource.GetSlotByIndex(index));
        }
        // else Debug.LogWarning($"[InventoryUIManager] No view found for Slot Index: {index} in UpdateSingleSlot");
    }

    // Sets the visual state of a SlotView based on InventorySlot data
    private void Draw(SlotView view, InventorySlot slot)
    {
        if (view == null) return;
        if (slot == null || slot.IsEmpty()) view.DrawEmpty();
        else view.DrawStack(slot.item.data.sprite, slot.quantity);
    }

    // --- Highlight Logic ---
    // Called by ToolbarSelector when the selected index changes
    private void UpdateHighlight(int newlySelectedIndex)
    {
        // Debug.Log($"[InventoryUIManager] Updating Highlight for Toolbar Index: {newlySelectedIndex}");
        if (_toolbarViews == null) return;

        for (int i = 0; i < _toolbarViews.Length; i++)
        {
            if (_toolbarViews[i] != null) // Check view exists
            {
                _toolbarViews[i].SetSelected(i == newlySelectedIndex, selectedColor, normalColor);
            }
        }
    }

    // Helper to find the SlotView associated with a container index
    private SlotView GetViewForIndex(int index)
    {
        if (index < 0) return null;
        if (index < _toolbarViews.Length) return _toolbarViews[index]; // Check toolbar first
        int bagIndex = index - _toolbarViews.Length;                   // Adjust index for bag
        if (bagIndex < _bagViews.Length) return _bagViews[bagIndex];   // Check bag
        return null; // Index out of range for both toolbar and bag views
    }
}
// --- End of script: Assets/Logic/Inventory/UI/InventoryUIManager.cs ---

// --- Start of script: Assets/Logic/Inventory/UI/ItemDetailUI.cs ---
using UnityEngine;
using UnityEngine.UI;

/// <summary>Very simple inspector window.  Expand later with attachment slots.</summary>
public class ItemDetailUI : MonoBehaviour
{
    [Header("Widgets")]
    [SerializeField] private Image iconImage;
    [SerializeField] private Text  nameText;
    [SerializeField] private Text  quantityText;
    [SerializeField] private GameObject root;   // panel root to toggle

    private int inspectedSlot = -1;

    internal void ShowFor(InventoryItem item, int qty, int slotIndex)
    {
        inspectedSlot = slotIndex;

        iconImage.sprite = item.data.sprite;
        nameText.text    = item.data.itemName;
        quantityText.text = $"x{qty}";

        root.SetActive(true);
    }

    public void Hide() => root.SetActive(false);
}
// --- End of script: Assets/Logic/Inventory/UI/ItemDetailUI.cs ---

// --- Start of script: Assets/Logic/Inventory/UI/SlotView.cs ---
using System;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

// Removed namespace

[RequireComponent(typeof(CanvasGroup))]
internal class SlotView : MonoBehaviour,
                            IBeginDragHandler, IDragHandler, IEndDragHandler,
                            IDropHandler,    IPointerClickHandler
{
    [Header("Visuals")]
    [SerializeField] private Image backgroundImage;
    [SerializeField] private Image iconImage;
    [SerializeField] private Text  quantityText;

    [Header("Runtime")]
    [SerializeField] private int slotIndex;

    // References
    private InventoryUIManager ui;
    private Canvas             rootCanvas;
    private CanvasGroup        cg;

    // Drag state
    private GameObject dragGhost;
    private Color      iconOrigColor;
    private Color      txtOrigColor;

    // REMOVED: Static DraggingChanged event

    internal void Setup(int idx, InventoryUIManager manager) { slotIndex = idx; ui = manager; }

    private void Awake()
    {
        rootCanvas = GetComponentInParent<Canvas>();
        cg = GetComponent<CanvasGroup>();
        if (cg == null) cg = gameObject.AddComponent<CanvasGroup>();
        if (iconImage == null) Debug.LogError($"SlotView ({gameObject.name}) missing Icon Image!", this);
        if (quantityText == null) Debug.LogError($"SlotView ({gameObject.name}) missing Quantity Text!", this);
        if (rootCanvas == null) Debug.LogError($"SlotView ({gameObject.name}) missing parent Canvas!", this);
    }

    // Drawing methods (DrawEmpty, DrawStack, SetSelected) remain the same...
    internal void DrawEmpty() { if (iconImage) { iconImage.sprite = null; iconImage.enabled = false; iconImage.raycastTarget = false; } if(quantityText) { quantityText.enabled = false; quantityText.text = ""; } }
    internal void DrawStack(Sprite icon, int qty) { if (iconImage) { iconImage.sprite = icon; iconImage.enabled = true; iconImage.raycastTarget = true; } else return; if(quantityText) { bool show = qty > 1; quantityText.enabled = show; quantityText.text = show ? qty.ToString() : ""; } }
    internal void SetSelected(bool isSelected, Color selectedColor, Color normalColor) { if(backgroundImage) backgroundImage.color = isSelected ? selectedColor : normalColor; }


    // --- Drag and Drop Handlers ---
    public void OnBeginDrag(PointerEventData eventData)
    {
        if (!iconImage || !iconImage.enabled || !iconImage.sprite || rootCanvas == null) return;

        // Create Ghost (same as before)
        dragGhost = new GameObject("DragGhost", typeof(RectTransform), typeof(CanvasGroup), typeof(Image));
        var rt  = dragGhost.GetComponent<RectTransform>();
        var img = dragGhost.GetComponent<Image>();
        var ghostCg = dragGhost.GetComponent<CanvasGroup>();
        img.sprite = iconImage.sprite; img.raycastTarget = false; ghostCg.blocksRaycasts = false; ghostCg.ignoreParentGroups = true;
        rt.SetParent(rootCanvas.transform, false); rt.SetAsLastSibling(); rt.sizeDelta = this.GetComponent<RectTransform>().sizeDelta; rt.position = eventData.position;

        // Fade Original (same as before)
        iconOrigColor = iconImage.color; txtOrigColor = quantityText.color;
        var halfAlphaIcon = iconOrigColor; halfAlphaIcon.a *= 0.5f; var halfAlphaText = txtOrigColor; halfAlphaText.a *= 0.5f;
        iconImage.color = halfAlphaIcon; if (quantityText.enabled) quantityText.color = halfAlphaText;
        cg.blocksRaycasts = false;

        // --- Call CursorController Directly ---
        CursorController.Instance.SetDragging(true);
        // --- End Call ---
    }

    public void OnDrag(PointerEventData eventData) { if (dragGhost) dragGhost.transform.position = eventData.position; }

    public void OnEndDrag(PointerEventData eventData)
    {
        // Clean up Ghost (same as before)
        if (dragGhost) Destroy(dragGhost); dragGhost = null;

        // Restore Original (same as before)
        if(iconImage) iconImage.color = iconOrigColor; if(quantityText) quantityText.color = txtOrigColor; if (cg != null) cg.blocksRaycasts = true;

        // --- Call CursorController Directly ---
        CursorController.Instance.SetDragging(false);
        // --- End Call ---
    }

    public void OnDrop(PointerEventData eventData) // Logic remains the same
    {
        GameObject draggedObject = eventData.pointerDrag; if (draggedObject == null) return;
        SlotView sourceSlotView = draggedObject.GetComponent<SlotView>();
        if (sourceSlotView == null || sourceSlotView.slotIndex == this.slotIndex) return;
        if (ui != null) ui.RequestMergeOrSwap(sourceSlotView.slotIndex, this.slotIndex);
    }

    public void OnPointerClick(PointerEventData eventData) // Logic remains the same
    {
        if (eventData.button == PointerEventData.InputButton.Left) { if (ui != null) ui.RequestInspect(slotIndex); }
    }
}
// --- End of script: Assets/Logic/Inventory/UI/SlotView.cs ---

// --- Start of script: Assets/Logic/Inventory/UI/ToolbarSelector.cs ---
// Assets/YourProjectName/Scripts/Inventory/UI/ToolbarSelector.cs
using UnityEngine;
using System;

/// <summary>
/// Manages the selected index for a toolbar UI representation.
/// Fires OnIndexChanged when the index changes.
/// Does NOT directly interact with inventory logic anymore.
/// </summary>
public class ToolbarSelector : MonoBehaviour
{
    // Configurable in Inspector - how many slots does this UI represent?
    [SerializeField] private int slotCount = 9;
    public int SlotCount => slotCount;

    public int CurrentIndex { get; private set; } = 0;

    // Event for UI and PlayerInventory to listen to
    public event Action<int> OnIndexChanged; // new index (0 to SlotCount-1)

    /// <summary>
    /// Sets the current index, clamping it and invoking the event if changed.
    /// </summary>
    /// <param name="idx">The desired index.</param>
    /// <param name="force">Force invoke event even if index is the same.</param>
    public void SetIndex(int idx, bool force = false)
    {
        idx = Mathf.Clamp(idx, 0, slotCount - 1);
        if (!force && idx == CurrentIndex) return;

        CurrentIndex = idx;
        OnIndexChanged?.Invoke(CurrentIndex);
    }

    /// <summary>
    /// Steps the index by a delta, wrapping around.
    /// </summary>
    /// <param name="delta">+1 for next, -1 for previous.</param>
    public void Step(int delta)
    {
        if (slotCount <= 0) return;
        // Correct modulo for negative numbers
        int newIndex = (CurrentIndex + delta % slotCount + slotCount) % slotCount;
        SetIndex(newIndex);
    }
}
// --- End of script: Assets/Logic/Inventory/UI/ToolbarSelector.cs ---

// --- Start of script: Assets/Logic/Items/Core/EquipabbleBehavior.cs ---
// --- Assets/Logic/Items/Core/EquipabbleBehavior.cs ---
using UnityEngine;

public abstract class EquippableBehavior : MonoBehaviour, IItemInputReceiver, IEquippableInstance {
    protected InventoryItem runtimeItem { get; private set; }
    public InventoryItem RuntimeItemInstance => runtimeItem;

    protected IEquipmentHolder ownerEquipmentHolder { get; private set; }
    protected IAimProvider ownerAimProvider { get; private set; }
    
    // Keep PlayerGrabController accessible for derived classes like HandsBehavior
    protected PlayerGrabController playerGrabController { get; private set; }


    public virtual void Initialize(InventoryItem itemInstance, IEquipmentHolder holder, IAimProvider aimProvider) {
        this.runtimeItem = itemInstance;
        this.ownerEquipmentHolder = holder;
        this.ownerAimProvider = aimProvider;

        // Find PlayerGrabController - it's a common need for interaction
        if (holder is Component componentHolder)
        {
            PlayerManager pm = componentHolder.GetComponentInParent<PlayerManager>();
            if (pm != null)
            {
                this.playerGrabController = pm.GrabController;
            }
        }
        if (this.playerGrabController == null)
        {
            // Fallback if PlayerManager context isn't directly available via holder
            this.playerGrabController = FindFirstObjectByType<PlayerGrabController>();
        }
        if (this.playerGrabController == null && !(this is HandsBehavior)) // HandsBehavior specifically needs it
        {
            // Only log error if a non-Hands behavior couldn't find it, as HandsBehavior will log its own critical error.
            // Debug.LogWarning($"[{GetType().Name} on {gameObject.name}] PlayerGrabController not found. Some interactions might be limited.", this);
        }


        bool isConsideredFallback = (this is HandsBehavior) || itemInstance == null || itemInstance.data == null;

        if (this.ownerEquipmentHolder == null && !isConsideredFallback) {
            Debug.LogError($"[{GetType().Name} on {gameObject.name}] Initialize ERROR: Null IEquipmentHolder for non-fallback item '{itemInstance?.data?.itemName}'!", this);
            this.enabled = false; return;
        }
        if (this.ownerAimProvider == null) { 
            Debug.LogError($"[{GetType().Name} on {gameObject.name}] Initialize ERROR: Null IAimProvider!", this);
            this.enabled = false; return;
        }
    }

    // --- Input Handlers (Default implementations) ---
    public virtual void OnFire1Down() { }
    public virtual void OnFire1Hold() { }
    public virtual void OnFire1Up() { }
    public virtual void OnFire2Down() { }
    public virtual void OnFire2Hold() { }
    public virtual void OnFire2Up() { }
    public virtual void OnUtilityDown() { }
    public virtual void OnUtilityUp() { }
    public virtual void OnReloadDown() { }

    /// <summary>
    /// Base implementation for the Store action.
    /// Most equippables (like weapons) might only allow pulling from inventory if not grabbing.
    /// HandsBehavior will override this for full grab/store/pull functionality.
    /// </summary>
    public virtual void OnStoreDown()
    {
        if (playerGrabController == null) return;

        if (playerGrabController.IsGrabbing)
        {
            // If any equippable is active AND player is somehow also grabbing via PGC (unusual state),
            // default to trying to store what PGC is holding.
            playerGrabController.HandleStoreAction(); // PGC's HandleStoreAction will try to store.
        }
        else
        {
            // Default behavior for non-Hands equippables:
            // Allow pulling an item from inventory into the grab slot.
            playerGrabController.HandleStoreAction(); // PGC's HandleStoreAction will try to pull.
        }
    }

    protected virtual void OnEnable() { }
    protected virtual void OnDisable() { }
}
// --- End of script: Assets/Logic/Items/Core/EquipabbleBehavior.cs ---

// --- Start of script: Assets/Logic/Items/Core/EquipmentController.cs ---
using UnityEngine;
using System.Collections.Generic;
using System;
using System.Linq;

[DisallowMultipleComponent]
public class EquipmentController : MonoBehaviour {

    [Header("Core Setup")]
    [SerializeField] private Transform itemHolder;
    [SerializeField] private EquipmentRegistry equipmentRegistry;

    [Header("Animation (Optional)")]
    [SerializeField] private EquipTransitionAnimator equipAnimator;

    // Cached references set in Awake
    private IEquipmentHolder _equipmentHolder;
    private IAimProvider _aimProvider;

    // Runtime state
    private readonly Dictionary<string, RuntimeEquippable> _instantiatedEquipmentCache = new();
    private RuntimeEquippable _currentActiveEquipment;
    private IItemInputReceiver _currentInputReceiver;
    private InventoryItem _equippedItemLogical; // The item PlayerInventory *thinks* is equipped

    // Public accessors
    public InventoryItem EquippedItemLogical => _equippedItemLogical;
    public RuntimeEquippable CurrentVisualEquipment => _currentActiveEquipment;
    public EquippableBehavior CurrentEquippableBehavior => _currentActiveEquipment?.GetComponent<EquippableBehavior>();


    private void Awake() {
        if (itemHolder == null) Debug.LogError("[EquipmentController] Item Holder Transform is not assigned!", this);
        if (equipmentRegistry == null) Debug.LogError("[EquipmentController] Equipment Registry SO is not assigned!", this);

        // Get contexts via PlayerManager (preferred) or fallback
        PlayerManager playerManager = GetComponentInParent<PlayerManager>();
        if (playerManager != null) {
            _equipmentHolder = playerManager.Inventory;
            _aimProvider = playerManager.Look as IAimProvider;

            if (_equipmentHolder == null) Debug.LogError($"[EC on {gameObject.name}] PlayerManager's 'Inventory' (IEquipmentHolder) is null on {playerManager.name}!", this);
            if (_aimProvider == null && playerManager.Look != null) Debug.LogError($"[EC on {gameObject.name}] PlayerManager's 'Look' on {playerManager.Look.name} does not implement IAimProvider!", this);
            else if(_aimProvider == null && playerManager.Look == null) Debug.LogWarning($"[EC on {gameObject.name}] PlayerManager ({playerManager.name}) has a null 'Look' component.", this);

        } else {
            _equipmentHolder = GetComponentInParent<PlayerInventory>(true);
            _aimProvider = GetComponentInParent<PlayerLook>(true);
            Debug.LogWarning($"[EC on {gameObject.name}] PlayerManager not found in parent. Using fallback GetComponentInParent searches.", this);
        }

        // Final validation of essential contexts
        if (_equipmentHolder == null) Debug.LogError($"[EC on {gameObject.name}] CRITICAL: Could not find IEquipmentHolder component!", this);
        if (_aimProvider == null) Debug.LogError($"[EC on {gameObject.name}] CRITICAL: Could not find IAimProvider component!", this);
        if (equipmentRegistry == null) { Debug.LogError($"[EC on {gameObject.name}] CRITICAL: EquipmentRegistry is null!", this); this.enabled = false; return; }

        // Pre-instantiate fallback/hands prefab
        InstantiateFallbackPrefab();
    }

    /// <summary>
    /// Called by PlayerManager.Start after all components are likely initialized.
    /// Subscribes to inventory changes and performs the initial equip.
    /// </summary>
    public void ManualStart() {
        if (_equipmentHolder != null) {
            // Subscribe to changes in the selected inventory item
            _equipmentHolder.OnEquippedItemChanged -= HandleEquipRequest; // Ensure no duplicates
            _equipmentHolder.OnEquippedItemChanged += HandleEquipRequest;

            // Perform initial equip based on inventory state
            HandleEquipRequest(_equipmentHolder.GetCurrentEquippedItem());
        } else {
             Debug.LogError($"[EC ManualStart on {gameObject.name}] CRITICAL: IEquipmentHolder is null! Cannot subscribe or perform initial equip.", this);
        }
    }

    private void OnEnable() {
        // Re-subscribe and re-equip if re-enabled after initial start
        if (Application.isPlaying && _equipmentHolder != null) {
            _equipmentHolder.OnEquippedItemChanged -= HandleEquipRequest;
            _equipmentHolder.OnEquippedItemChanged += HandleEquipRequest;
            // Re-sync with current inventory selection
            HandleEquipRequest(_equipmentHolder.GetCurrentEquippedItem());
        }
    }

    private void OnDisable() {
         // Unsubscribe to prevent memory leaks or errors
         if (_equipmentHolder != null) {
            _equipmentHolder.OnEquippedItemChanged -= HandleEquipRequest;
        }
    }

    // --- Input Forwarding Methods ---
    public void HandleFire1Down() => PassInput(r => r.OnFire1Down());
    public void HandleFire1Up() => PassInput(r => r.OnFire1Up());
    public void HandleFire1Hold() => PassInput(r => r.OnFire1Hold());
    public void HandleFire2Down() => PassInput(r => r.OnFire2Down());
    public void HandleFire2Up() => PassInput(r => r.OnFire2Up());
    public void HandleFire2Hold() => PassInput(r => r.OnFire2Hold());
    public void HandleReloadDown() => PassInput(r => r.OnReloadDown());
    // HandleStoreDown is removed as Store action is now handled centrally
    public void HandleUtilityDown() => PassInput(r => r.OnUtilityDown());
    public void HandleUtilityUp() => PassInput(r => r.OnUtilityUp());

    /// <summary>
    /// Forwards an input action to the current active equipment's IItemInputReceiver.
    /// </summary>
    private void PassInput(Action<IItemInputReceiver> inputAction) {
        if (_currentActiveEquipment != null && _currentActiveEquipment.gameObject.activeSelf) {
             // Get receiver each time in case the component structure changes dynamically
             _currentInputReceiver = _currentActiveEquipment.GetComponent<IItemInputReceiver>();
             if (_currentInputReceiver != null) {
                try {
                    inputAction?.Invoke(_currentInputReceiver);
                } catch (Exception e) {
                    Debug.LogError($"Error executing input action on '{_currentActiveEquipment.name}': {e.Message}\n{e.StackTrace}", _currentActiveEquipment);
                }
             }
             // else: Active equipment doesn't implement IItemInputReceiver (e.g., passive item)
        }
    }

    /// <summary>
    /// Public entry point called by PlayerManager when the selected inventory item changes
    /// or when the grab state forces an equip change.
    /// </summary>
    public void HandleEquipRequest(InventoryItem newItemFromInventory) {
        _equippedItemLogical = newItemFromInventory; // Update the logical item state
        Equip(_equippedItemLogical); // Trigger the visual equip process
    }

    /// <summary>
    /// Determines the correct RuntimeEquippable prefab to use based on the InventoryItem.
    /// Falls back to the Hands prefab if the item is null, has no specific prefab registered,
    /// or is a CarPartData without a specific viewmodel override.
    /// </summary>
    private RuntimeEquippable DetermineTargetPrefab(InventoryItem item) {
        if (equipmentRegistry == null) {
            Debug.LogError($"[EC DetermineTargetPrefab] EquipmentRegistry is null!", this);
            return null; // Critical error
        }

        // If no item or no item data, use fallback
        if (item == null || item.data == null) {
            return equipmentRegistry.FallbackPrefab;
        }

        // If it's a car part, default to hands unless explicitly registered
        if (item.data is CarPartData) {
            RuntimeEquippable specificCarPartPrefab = equipmentRegistry.GetPrefabForItem(item.data);
            // If the registry returns null or the *same* fallback prefab for this car part, use the fallback.
            if (specificCarPartPrefab == null || specificCarPartPrefab == equipmentRegistry.FallbackPrefab) {
                 return equipmentRegistry.FallbackPrefab;
            }
             // Otherwise, use the specific prefab registered for this car part (rare case, e.g., a tool-like part).
             return specificCarPartPrefab;
        }

        // For other item types, get the registered prefab or fallback if none exists
        return equipmentRegistry.GetPrefabForItem(item.data); // GetPrefabForItem handles fallback internally
    }

    /// <summary>
    /// Core logic to switch the visually equipped item.
    /// Deactivates the old item, activates/initializes the new one.
    /// </summary>
    private void Equip(InventoryItem itemToEquipLogically) {
        RuntimeEquippable targetPrefab = DetermineTargetPrefab(itemToEquipLogically);

        // Handle critical error: No prefab determined (even fallback is missing)
        if (targetPrefab == null) {
             Debug.LogError($"[EC Equip] CRITICAL: No target prefab could be determined for item '{itemToEquipLogically?.data?.itemName ?? "NULL/Empty Slot"}' (Fallback Prefab might be missing in Registry!). Equipment system disabled.", this);
             if (_currentActiveEquipment != null) _currentActiveEquipment.gameObject.SetActive(false);
             _currentActiveEquipment = null; _currentInputReceiver = null;
             this.enabled = false; // Disable controller if unrecoverable
             return;
        }

        // --- Avoid unnecessary swaps ---
        // Check if requested item *and* prefab match the current active one
        EquippableBehavior currentBehavior = CurrentEquippableBehavior;
        bool isSameItemInstance = (currentBehavior != null && currentBehavior.RuntimeItemInstance == itemToEquipLogically);
        bool isSamePrefab = (_currentActiveEquipment != null && _currentActiveEquipment.name == targetPrefab.name); // Compare prefab names

        // If the prefab is the same AND the logical item instance is the same, do nothing.
        if (isSamePrefab && isSameItemInstance) {
            // Debug.Log($"[EC Equip] Already equipped: {targetPrefab.name} with same item instance.");
            return;
        }
        // --- End Check ---


        // Get or create the instance of the target prefab
        RuntimeEquippable targetInstance = GetOrCreateInstance(targetPrefab);
        if (targetInstance == null) {
             Debug.LogError($"[EC Equip] Failed to get or create instance for prefab '{targetPrefab.name}'. Aborting equip.", this);
             // Optionally try to switch back to fallback?
             if (_currentActiveEquipment != null) _currentActiveEquipment.gameObject.SetActive(false);
             _currentActiveEquipment = null; _currentInputReceiver = null;
             return;
        }

        // Deactivate the currently active equipment if it's different
        if (_currentActiveEquipment != null && _currentActiveEquipment != targetInstance) {
            _currentActiveEquipment.gameObject.SetActive(false);
            // Optional: Call an OnUnequipped method on the behavior if needed
        }

        // Set the new active equipment
        _currentActiveEquipment = targetInstance;

        // Activate and Initialize the new equipment
        if (!_currentActiveEquipment.gameObject.activeSelf) {
            _currentActiveEquipment.gameObject.SetActive(true);
        }

        // Initialize the behavior component on the newly activated equipment
        // It's crucial to pass the correct InventoryItem instance representing the equipped item.
        // For the fallback/hands state, itemToEquipLogically will be null.
        try {
            _currentActiveEquipment.Initialize(itemToEquipLogically, _equipmentHolder, _aimProvider);
        } catch (Exception e) {
            Debug.LogError($"Error during Initialize on '{_currentActiveEquipment.name}': {e.Message}\n{e.StackTrace}", _currentActiveEquipment);
            // Consider disabling the equipment or the controller if init fails critically
        }

        // Cache the input receiver for the new equipment
        _currentInputReceiver = _currentActiveEquipment.GetComponent<IItemInputReceiver>();

        // Play animation if available
        if (equipAnimator) equipAnimator.Play(null); // Consider passing callback if needed
    }

    /// <summary>
    /// Retrieves an instantiated equipment prefab from the cache or instantiates it if not found.
    /// </summary>
    private RuntimeEquippable GetOrCreateInstance(RuntimeEquippable prefab) {
        if (prefab == null) { Debug.LogError($"[EC GetOrCreateInstance] Prefab is null.", this); return null; }

        // Use item code if available, otherwise fallback to prefab name or instance ID for cache key
        string cacheKey = !string.IsNullOrEmpty(prefab.ItemCode) ? prefab.ItemCode : prefab.name;
        if(string.IsNullOrEmpty(cacheKey)) {
             Debug.LogWarning($"[EC GetOrCreateInstance] Prefab '{prefab}' has no ItemCode or name. Using InstanceID as cache key.", prefab);
             cacheKey = prefab.GetInstanceID().ToString();
        }

        if (_instantiatedEquipmentCache.TryGetValue(cacheKey, out RuntimeEquippable cachedInstance)) {
            // Ensure the cached instance hasn't been destroyed
            if (cachedInstance != null) return cachedInstance;
            else {
                 // Instance was destroyed, remove from cache and log warning
                 _instantiatedEquipmentCache.Remove(cacheKey);
                 Debug.LogWarning($"[EC GetOrCreateInstance] Cached instance for key '{cacheKey}' (Prefab: {prefab.name}) was destroyed. Re-instantiating.", this);
            }
        }
        // Instance not found or was destroyed, instantiate a new one
        return InstantiateAndCacheEquipment(prefab, cacheKey);
    }

    /// <summary>
    /// Instantiates the equipment prefab, parents it, sets its name, caches it, and returns the instance.
    /// </summary>
    private RuntimeEquippable InstantiateAndCacheEquipment(RuntimeEquippable prefab, string cacheKey) {
        if (prefab == null || itemHolder == null) { Debug.LogError($"[EC InstantiateAndCache] Instantiate fail: Null prefab or itemHolder.", prefab); return null; }
        try {
            RuntimeEquippable newInstance = Instantiate(prefab, itemHolder);
            newInstance.gameObject.name = prefab.name; // Keep original prefab name for easier debugging
            newInstance.gameObject.SetActive(false); // Start inactive, Equip method will activate
            _instantiatedEquipmentCache[cacheKey] = newInstance;
            return newInstance;
        } catch (Exception e) {
             Debug.LogError($"[EC InstantiateAndCache] Failed to instantiate prefab '{prefab.name}': {e.Message}\n{e.StackTrace}", prefab);
             return null;
        }
    }

     /// <summary>
    /// Instantiates the fallback prefab defined in the registry.
    /// </summary>
    private void InstantiateFallbackPrefab() {
         if (equipmentRegistry != null && equipmentRegistry.FallbackPrefab != null) {
            RuntimeEquippable fallbackPrefab = equipmentRegistry.FallbackPrefab;
            string fallbackCacheKey = !string.IsNullOrEmpty(fallbackPrefab.ItemCode) ? fallbackPrefab.ItemCode : fallbackPrefab.name;
             if(string.IsNullOrEmpty(fallbackCacheKey)) {
                 fallbackCacheKey = fallbackPrefab.GetInstanceID().ToString(); // Use InstanceID if no name/code
            }
            // Only instantiate if not already in cache
            if (!string.IsNullOrEmpty(fallbackCacheKey) && !_instantiatedEquipmentCache.ContainsKey(fallbackCacheKey)) {
                 InstantiateAndCacheEquipment(fallbackPrefab, fallbackCacheKey);
            }
        } else { Debug.LogWarning($"[EC on {gameObject.name}] No Fallback Prefab assigned in Equipment Registry. 'Hands' state might not work.", this); }
    }

    /// <summary>
    /// Destroys all cached equipment instances. Used during cleanup or scene changes.
    /// </summary>
    public void ClearInstantiatedCache() {
        foreach (var kvp in _instantiatedEquipmentCache.ToList()) { // ToList allows modification during iteration
            if (kvp.Value != null) Destroy(kvp.Value.gameObject);
        }
        _instantiatedEquipmentCache.Clear();
        _currentActiveEquipment = null;
        _currentInputReceiver = null;
    }
}
// --- End of script: Assets/Logic/Items/Core/EquipmentController.cs ---

// --- Start of script: Assets/Logic/Items/Core/EquipmentRegistry.cs ---
using System.Collections.Generic;
using UnityEngine;
using System.Linq;

[System.Serializable]
public class EquipmentMapping
{
    public ItemData itemDefinition; // The ScriptableObject defining the item
    public RuntimeEquippable prefab; // The prefab to instantiate/activate
}

[CreateAssetMenu(menuName = "Registry/Equipment Registry")]
public class EquipmentRegistry : ScriptableObject
{
    [SerializeField] private List<EquipmentMapping> equipmentMappings = new List<EquipmentMapping>();
    [SerializeField] private RuntimeEquippable fallbackHandsPrefab; // The prefab for unarmed state

    private Dictionary<ItemData, RuntimeEquippable> _lookup;

    private void OnEnable()
    {
        // Build lookup dictionary for fast access
        _lookup = equipmentMappings.Where(m => m.itemDefinition != null && m.prefab != null)
                                    .ToDictionary(m => m.itemDefinition, m => m.prefab);
    }

    public RuntimeEquippable GetPrefabForItem(ItemData itemData)
    {
        if (itemData != null && _lookup != null && _lookup.TryGetValue(itemData, out var prefab))
        {
            return prefab;
        }
        // Return fallback if itemData is null or not found in the registry
        return fallbackHandsPrefab;
    }

    public RuntimeEquippable FallbackPrefab => fallbackHandsPrefab;
}
// --- End of script: Assets/Logic/Items/Core/EquipmentRegistry.cs ---

// --- Start of script: Assets/Logic/Items/Core/IEquipmentHolder.cs ---
// In Assets/Scripts/Player/Equipment/IEquipmentHolder.cs (or your path)
using System;

/// <summary>
/// Interface for an entity that can hold and manage equipment and inventory.
/// Typically implemented by the PlayerInventory component or an AI equivalent.
/// </summary>
public interface IEquipmentHolder {
    // --- Equipment Selection & State ---
    event Action<InventoryItem> OnEquippedItemChanged;
    InventoryItem GetCurrentEquippedItem();
    ItemContainer GetContainerForInventory(); // Main inventory data container

    // --- Inventory Interaction Requests ---
    bool RequestAddItemToInventory(InventoryItem itemToAdd);
    bool CanAddItemToInventory(InventoryItem itemToCheck, int quantity = 1);
    bool RequestConsumeItem(ItemData itemData, int amount = 1);
    bool HasItemInInventory(ItemData itemData, int amount = 1);
}
// --- End of script: Assets/Logic/Items/Core/IEquipmentHolder.cs ---

// --- Start of script: Assets/Logic/Items/Core/IItemInputReceiver.cs ---
using UnityEngine;

public interface IItemInputReceiver
{
    // Fire1 (LMB)
    void OnFire1Down();
    void OnFire1Hold();
    void OnFire1Up();

    // Fire2 (RMB)
    void OnFire2Down();
    void OnFire2Hold();
    void OnFire2Up();

    // Utility (E/F) - Renamed from UtilityPerformed/Canceled for consistency
    void OnUtilityDown();
    void OnUtilityUp();

    // Reload (R)
    void OnReloadDown();

    // Store (T) - NEW METHOD
    void OnStoreDown(); 
}
// --- End of script: Assets/Logic/Items/Core/IItemInputReceiver.cs ---

// --- Start of script: Assets/Logic/Items/Core/RuntimeEquippable.cs ---
using UnityEngine;

[DisallowMultipleComponent]
public sealed class RuntimeEquippable : MonoBehaviour {
    [SerializeField] private string itemCode;
    private IEquippableInstance instanceBehavior;
    public string ItemCode => itemCode;

    private void Awake() {
        instanceBehavior = GetComponent<IEquippableInstance>();
        if (instanceBehavior == null) Debug.LogError($"[RE] Missing IEquippableInstance on {gameObject.name}!", this);
    }

    // Signature matches the new IEquippableInstance
    public void Initialize(InventoryItem itemInstance, IEquipmentHolder holder, IAimProvider aimProvider) {
        if (instanceBehavior != null) {
            instanceBehavior.Initialize(itemInstance, holder, aimProvider);
        } else {
             Debug.LogError($"[RE] Cannot forward Initialize on {gameObject.name}: IEquippableInstance missing!", this);
        }
    }
}
// --- End of script: Assets/Logic/Items/Core/RuntimeEquippable.cs ---

// --- Start of script: Assets/Logic/Items/Data/ItemData.cs ---
using UnityEngine;
using System.Collections.Generic;

public abstract class ItemData : ScriptableObject {
    [Header("Basic Info")]
    public string itemName = "New Item";
    [Tooltip("Unique code for this item type. Used for lookups, e.g., in registries.")]
    public string itemCode = "default_item_code";
    public Sprite sprite;
    [TextArea] public string description;

    [Header("Inventory & World")]
    public ItemCategory category = ItemCategory.Generic;
    [Tooltip("Prefab to instantiate when this item is in the world. For generic items, this is often a 'WorldItem' prefab. For Car Parts, this is the 'PartInstance' prefab itself (e.g., EngineInstance prefab).")]
    public GameObject worldPrefab; // This is the key prefab
    public bool stackable = false;
    [Min(1)] public int maxStack = 1;
    public float weightKg = 0.1f;
    [Tooltip("If true, this item might be restricted from certain small inventories (e.g., player's main bag) and might require special handling or storage (e.g., vehicle trunk, hands-only carry).")]
    public bool isBulky = false;

    protected virtual void OnValidate() {
        if (string.IsNullOrEmpty(itemCode)) {
            itemCode = name.ToLowerInvariant().Replace(" ", "_").Replace("(", "").Replace(")", "");
        }
        if (!stackable) {
            maxStack = 1;
        } else {
            if (maxStack <= 0) maxStack = 1;
        }
    }
}
// --- End of script: Assets/Logic/Items/Data/ItemData.cs ---

// --- Start of script: Assets/Logic/Items/Weapons/HandsItemData.cs ---
using UnityEngine;

[CreateAssetMenu(fileName = "NewHandsItem", menuName = "Items/Hands")]
public class HandsItemData : ItemData
{
    // Optional: define special stats for hands
    public float punchCooldown = 0.5f;
    public float grabReach = 2.0f;
}
// --- End of script: Assets/Logic/Items/Weapons/HandsItemData.cs ---

// --- Start of script: Assets/Logic/Items/Weapons/ToolItemData.cs ---
// ========================
// ToolItemData.cs
// ========================
using UnityEngine;

[CreateAssetMenu(fileName = "NewToolItem", menuName = "Items/Tool")]
public class ToolItemData : ItemData
{
    private void OnEnable()
    {
        category = ItemCategory.Tool;
    }
}
// --- End of script: Assets/Logic/Items/Weapons/ToolItemData.cs ---

// --- Start of script: Assets/Logic/Player/Effects/FootstepController.cs ---
using UnityEngine;
using KinematicCharacterController;

[RequireComponent(typeof(AudioSource))]
public class FootstepController : MonoBehaviour
{
    [Header("Audio")]
    public AudioClip[] footstepClips;

    [Header("Step Timing")]
    public float stepInterval = 0.5f;
    public float velocityStepInfluence = 0.3f;
    public float minSpeedToStep = 0.1f;

    private AudioSource audioSource;
    private MyCharacterController characterController;

    private float stepTimer;
    private int lastPlayedIndex = -1;
    private bool wasGroundedLastFrame = true;

    private void Awake()
    {
        audioSource = GetComponent<AudioSource>();
        characterController = GetComponent<MyCharacterController>();
    }

    private void Update()
    {
        if (characterController == null || footstepClips == null || footstepClips.Length == 0)
            return;

        bool isGrounded = characterController.Motor.GroundingStatus.IsStableOnGround;
        Vector3 velocity = characterController.Velocity;
        float horizontalSpeed = new Vector3(velocity.x, 0f, velocity.z).magnitude;

        // LANDING SOUND
        if (!wasGroundedLastFrame && isGrounded)
        {
            PlayFootstep();
        }

        // REGULAR FOOTSTEPS
        if (isGrounded && horizontalSpeed > minSpeedToStep)
        {
            float dynamicInterval = stepInterval / (1f + horizontalSpeed * velocityStepInfluence);

            stepTimer += Time.deltaTime;
            if (stepTimer >= dynamicInterval)
            {
                PlayFootstep();
                stepTimer = 0f;
            }
        }
        else
        {
            stepTimer = 0f;
        }

        wasGroundedLastFrame = isGrounded;
    }

    private void PlayFootstep()
    {
        if (footstepClips.Length == 0)
            return;

        int index;
        do
        {
            index = Random.Range(0, footstepClips.Length);
        } while (index == lastPlayedIndex && footstepClips.Length > 1);

        lastPlayedIndex = index;

        audioSource.PlayOneShot(footstepClips[index]);
    }
}
// --- End of script: Assets/Logic/Player/Effects/FootstepController.cs ---

// --- Start of script: Assets/Logic/Player/Effects/Headbob.cs ---
using UnityEngine;

[RequireComponent(typeof(Transform))]
public class HeadBob : MonoBehaviour
{
    [Header("Walking Bob")]
    public float walkBobSpeed = 14f;
    public float walkBobAmount = 0.05f;

    [Header("Idle Breathing")]
    public float idleBobSpeed = 1.5f;
    public float idleBobAmount = 0.02f;

    [Header("Settings")]
    public float blendSpeed = 5f;
    public float movementThreshold = 0.1f;

    [Header("References")]
    public MyCharacterController characterController;

    private Vector3 initialLocalPos;
    private float bobTimer = 0f;

    void Start()
    {
        initialLocalPos = transform.localPosition;

        if (characterController == null)
        {
            characterController = GetComponentInParent<MyCharacterController>();
            if (characterController == null)
            {
                Debug.LogWarning("HeadBob couldn't find MyCharacterController in parent.");
            }
        }
    }

    void Update()
    {
        if (characterController == null || characterController.Motor == null) return;

        Vector3 flatVelocity = new Vector3(characterController.Motor.Velocity.x, 0f, characterController.Motor.Velocity.z);
        float movementMagnitude = flatVelocity.magnitude;

        bobTimer += Time.deltaTime;

        if (movementMagnitude > movementThreshold)
        {
            // Walking bob
            float bobX = Mathf.Sin(bobTimer * walkBobSpeed) * walkBobAmount;
            float bobY = Mathf.Cos(bobTimer * walkBobSpeed * 2f) * walkBobAmount;
            Vector3 targetPos = initialLocalPos + new Vector3(bobX, bobY, 0f);
            transform.localPosition = Vector3.Lerp(transform.localPosition, targetPos, Time.deltaTime * blendSpeed);
        }
        else
        {
            // Idle breathing
            float bobX = Mathf.Cos(bobTimer * idleBobSpeed) * idleBobAmount;
            float bobY = Mathf.Sin(bobTimer * idleBobSpeed) * idleBobAmount;
            Vector3 targetPos = initialLocalPos + new Vector3(bobX, bobY, 0f);
            transform.localPosition = Vector3.Lerp(transform.localPosition, targetPos, Time.deltaTime * blendSpeed);
        }
    }
}
// --- End of script: Assets/Logic/Player/Effects/Headbob.cs ---

// --- Start of script: Assets/Logic/Player/Grab/.PlayerGrabController.cs ---
// ────────────────────────────────────────────────────────────────────────────
//  PlayerGrabController.cs   (drop in Assets/Logic/Player/Grab/)
// ────────────────────────────────────────────────────────────────────────────
using UnityEngine;

/// <summary>
/// One-file grab / move / rotate / drop controller.
/// Keeps the original public API so existing code compiles.
/// </summary>
[RequireComponent(typeof(PlayerManager))]
public sealed class PlayerGrabController : MonoBehaviour
{
    // ────────────────────────────────────────────────────  inspector ────────
    [Header("Raycast layers & reach")]
    [SerializeField] float     interactionReach    = 3f;
    [SerializeField] LayerMask grabbableMask       = 0;
    [SerializeField] LayerMask mountMask           = 0;

    [Header("Hold distance (scroll)")]
    [SerializeField] float holdDefault = 1.6f;
    [SerializeField] float holdMin     = 0.4f;
    [SerializeField] float holdMax     = 3.5f;
    [SerializeField] float scrollSpeed = 0.3f;      // wheel units → metres

    [Header("Movement & collision")]
    [SerializeField] bool  smoothFollow      = true;
    [SerializeField] float smoothSpeed       = 15f;
    [SerializeField] LayerMask worldMask     = ~0;   // collide with everything by default
    [SerializeField] float sweepSkin         = 0.02f;
    [SerializeField] float teleportDistance  = 1.0f; // “stuck” threshold

    [Header("Rotation (MMB)")]
    [SerializeField] float rotationDegPerPx  = 110f;

    // ────────────────────────────────────────────────────  public API ───────
    public  bool IsGrabbing                 => _grabbed != null;
    public  IGrabbable CurrentGrabbedItem   => _grabbed;
    public  event System.Action<bool,IGrabbable> OnGrabStateChanged;

    //  (public methods below, exactly like the old file) ─────────────────────
    public void InitializeController(PlayerManager mgr) => Initialise(mgr);
    public bool TryGrabOrDetachWorldObject()            => GrabOrDetach();
    public void DropGrabbedItemWithLMB()                => DropHeld();
    public void AdjustGrabbedItemDistance(float d)      => ScrollDistance(d);
    public void HandleStoreAction()                     => StoreOrPull();
    public bool TryAttachGrabbedPart()                  => TryAttachPart();
    public void StartGrabRotation()                     => _rotating = IsGrabbing;
    public void EndGrabRotation()                       => _rotating = false;
    public void ApplyGrabbedItemRotationInput(Vector2 d)=> RotateHeld(d);

    // ────────────────────────────────────────────────────  private state ────
    PlayerManager     _pm;
    IAimProvider      _aim;
    PlayerInventory   _inv;
    InteractionController _interact;

    IGrabbable  _grabbed;
    Transform   _grabTf;
    Rigidbody   _grabRb;
    Collider[]  _grabCols;

    bool        _rbWasKinematic, _rbHadGravity;
    RigidbodyInterpolation _rbInterp;
    CollisionDetectionMode _rbCCD;

    bool        _rotating;
    float       _holdDist;
    Quaternion  _heldRot;

    Transform   _anchor;            // child of camera

    // ────────────────────────────────────────────────────  unity plumbing ───
    void Awake()
    {
        if (TryGetComponent(out PlayerManager pm)) Initialise(pm);
    }

    void FixedUpdate()
    {
        if (!IsGrabbing || _grabRb == null || !_grabRb.isKinematic) return;

        // 1) anchor stays in front of camera
        _anchor.localPosition = new Vector3(0, 0, _holdDist);

        // 2) where we want to be
        Vector3 wantPos = _anchor.position;
        Vector3 curPos  = _grabRb.position;
        Vector3 delta   = wantPos - curPos;
        Vector3 nextPos = wantPos;

        // Sweep-test for blocking geometry
        if (delta.sqrMagnitude > 1e-6f &&
            _grabRb.SweepTest(delta.normalized, out var hit, delta.magnitude, QueryTriggerInteraction.Ignore))
        {
            nextPos = curPos + delta.normalized * Mathf.Max(0, hit.distance - sweepSkin);
        }

        // Teleport if hopelessly far
        if (Vector3.Distance(nextPos, wantPos) > teleportDistance)
            nextPos = wantPos;

        // 3) move & rotate
        if (smoothFollow)
        {
            _grabRb.MovePosition(Vector3.Lerp(curPos, nextPos, smoothSpeed * Time.fixedDeltaTime));
            _grabRb.MoveRotation(Quaternion.Slerp(_grabRb.rotation, _heldRot,  smoothSpeed * Time.fixedDeltaTime));
        }
        else
        {
            _grabRb.MovePosition(nextPos);
            _grabRb.MoveRotation(_heldRot);
        }
    }

    // ───────────────────────────────────── initialisation helper ────────────
    void Initialise(PlayerManager pm)
    {
        _pm  = pm;
        _aim = pm.Look;
        _inv = pm.Inventory;
        _interact = FindFirstObjectByType<InteractionController>();

        _holdDist = holdDefault;

        if (!_anchor)
        {
            _anchor = new GameObject("HoldAnchor").transform;
            _anchor.SetParent(_aim.GetLookTransform(), false);
            _anchor.localPosition = new Vector3(0, 0, _holdDist);
        }
    }

    // ─────────────────────────────────────────── grab / detach  ─────────────
    bool GrabOrDetach()
    {
        if (IsGrabbing)
        {
            if (TryAttachPart()) return true;
            DropHeld();
            return true;
        }
        return TryGrabFromScene();
    }

    bool TryGrabFromScene()
    {
        Ray ray = _aim.GetLookRay();

        // a) detach from MountPoint
        if (mountMask.value != 0 &&
            Physics.Raycast(ray, out var mHit, interactionReach, mountMask,
                            QueryTriggerInteraction.Collide))
        {
            var m = mHit.collider.GetComponentInParent<MountPoint>();
            if (m && m.CurrentlyAttachedPart)
            {
                BeginGrab(m.Detach(), mHit.distance);
                return true;
            }
        }

        // b) generic grabbable
        if (grabbableMask.value != 0 &&
            Physics.Raycast(ray, out var gHit, interactionReach, grabbableMask,
                            QueryTriggerInteraction.Collide))
        {
            var g = gHit.collider.GetComponentInParent<IGrabbable>();
            if (g != null && g.CanGrab())
            {
                BeginGrab(g, gHit.distance);
                return true;
            }
        }
        return false;
    }

    void BeginGrab(IGrabbable g, float hitDist)
    {
        // cache refs
        _grabbed = g;
        _grabTf  = g.GetTransform();
        _grabRb  = _grabTf.GetComponent<Rigidbody>();
        _grabCols= _grabTf.GetComponentsInChildren<Collider>(true);

        // cache & override RB
        if (_grabRb)
        {
            _rbWasKinematic = _grabRb.isKinematic;
            _rbHadGravity   = _grabRb.useGravity;
            _rbInterp       = _grabRb.interpolation;
            _rbCCD          = _grabRb.collisionDetectionMode;

            _grabRb.isKinematic            = true;
            _grabRb.useGravity             = false;
            _grabRb.interpolation          = RigidbodyInterpolation.Interpolate;
            _grabRb.collisionDetectionMode = CollisionDetectionMode.ContinuousSpeculative;
        }

        // ignore player collider
        if (_pm.CharacterController)
        {
            var pc = _pm.CharacterController.GetComponent<Collider>();
            foreach (var c in _grabCols) if (c) Physics.IgnoreCollision(pc, c, true);
        }

        _holdDist   = Mathf.Clamp(hitDist, holdMin, holdMax);
        _anchor.localPosition = new Vector3(0, 0, _holdDist);
        _heldRot    = _grabTf.rotation;
        _rotating   = false;

        _grabbed.OnGrabbed(_aim.GetLookTransform());
        OnGrabStateChanged?.Invoke(true, _grabbed);
    }

    void DropHeld()
    {
        if (!IsGrabbing) return;

        if (_grabRb)
        {
            _grabRb.isKinematic            = _rbWasKinematic;
            _grabRb.useGravity             = _rbHadGravity;
            _grabRb.interpolation          = _rbInterp;
            _grabRb.collisionDetectionMode = _rbCCD;

            if (!_grabRb.isKinematic)
            {
                var vel = _aim.GetLookRay().direction * 2f;
                _grabRb.linearVelocity  = vel;
                _grabRb.angularVelocity = Random.insideUnitSphere * 0.5f;
            }
        }

        // restore player collisions
        if (_pm.CharacterController)
        {
            var pc = _pm.CharacterController.GetComponent<Collider>();
            foreach (var c in _grabCols) if (c) Physics.IgnoreCollision(pc, c, false);
        }

        _grabbed.OnDropped(_grabRb ? _grabRb.linearVelocity : Vector3.zero);
        ClearGrabState(invokeEvent:true);
    }

    void ClearGrabState(bool invokeEvent)
    {
        var old = _grabbed;

        _grabbed = null;
        _grabTf  = null;
        _grabRb  = null;
        _grabCols= null;
        _rotating= false;
        _holdDist= holdDefault;
        _anchor.localPosition = new Vector3(0, 0, _holdDist);
        _heldRot = Quaternion.identity;

        if (invokeEvent && old != null) OnGrabStateChanged?.Invoke(false, old);
    }

    // ─────────────────────────────────────────── rotation / scroll ──────────
    void RotateHeld(Vector2 delta)
    {
        if (!IsGrabbing || !_rotating) return;
        var cam = _aim.GetLookTransform();
        _heldRot =
            Quaternion.AngleAxis(-delta.x * rotationDegPerPx * Time.deltaTime, Vector3.up) *
            Quaternion.AngleAxis( delta.y * rotationDegPerPx * Time.deltaTime, cam.right) *
            _heldRot;
    }

    void ScrollDistance(float scroll)
    {
        if (!IsGrabbing || _rotating) return;
        _holdDist = Mathf.Clamp(_holdDist + scroll * scrollSpeed, holdMin, holdMax);
        _anchor.localPosition = new Vector3(0, 0, _holdDist);
    }

    // ───────────────────────────────────────────── attach part ──────────────
    bool TryAttachPart()
    {
        if (!IsGrabbing || !(_grabbed is PartInstance part) || _interact == null) return false;

        var info = _interact.CurrentLookTargetInfo;
        if (info.HasTarget && info.Mount && info.Mount.IsCompatible(part))
        {
            if (info.Mount.TryAttach(part)) { ClearGrabState(invokeEvent:true); return true; }
        }
        return false;
    }

    // ───────────────────────────────────────── store / pull from inv ────────
    void StoreOrPull()
    {
        if (IsGrabbing) TryStoreHeld();
        else            TryPullAndGrab();
    }

    void TryStoreHeld()
    {
        if (!IsGrabbing || _inv == null) { DropHeld(); return; }

        var item = _grabbed.GetInventoryItemData();
        if (item == null || item.data == null) { DropHeld(); return; }

        bool ok = false;
        int sel = _inv.GetSelectedToolbarIndex();

        if (sel >= 0 && _inv.TryStoreItemInSpecificSlot(item, sel)) ok = true;
        else if (!item.data.isBulky) ok = _inv.RequestAddItemToInventory(item);

        if (ok)
        {
            _grabbed.OnStored();
            Destroy(_grabTf.gameObject);
            ClearGrabState(invokeEvent:true);
        }
        else DropHeld();
    }

    bool TryPullAndGrab()
    {
        if (_inv == null) return false;

        int sel = _inv.GetSelectedToolbarIndex();
        if (sel < 0) return false;

        if (!_inv.TryPullItemFromSlot(sel, out var pulled) ||
            pulled?.data?.worldPrefab == null) return false;

        var ray = _aim.GetLookRay();
        _holdDist = holdDefault;
        Vector3 pos = ray.GetPoint(_holdDist);
        Quaternion rot = _aim.GetLookTransform().rotation;

        var go = Instantiate(pulled.data.worldPrefab, pos, rot);
        if (!go) return false;

        var g = go.GetComponentInChildren<IGrabbable>();
        if (g == null) { Destroy(go); return false; }

        if      (g is ItemInstance ii) ii.Initialize(pulled);
        else if (g is WorldItem  wi) wi.Initialize(pulled);

        BeginGrab(g, _holdDist);
        return true;
    }
}
// --- End of script: Assets/Logic/Player/Grab/.PlayerGrabController.cs ---

// --- Start of script: Assets/Logic/Player/Grab/PlayerGrabController.cs ---
// ────────────────────────────────────────────────────────────────────────────
//  PlayerGrabController.cs   (drop in Assets/Logic/Player/Grab/)
// ────────────────────────────────────────────────────────────────────────────
using UnityEngine;

/// <summary>
/// One-file grab / move / rotate / drop controller.
/// Keeps the original public API so existing code compiles.
/// </summary>
[RequireComponent(typeof(PlayerManager))]
public sealed class PlayerGrabController : MonoBehaviour
{
    // ────────────────────────────────────────────────────  inspector ────────
    [Header("Raycast layers & reach")]
    [SerializeField] float     interactionReach    = 3f;
    [SerializeField] LayerMask grabbableMask       = 0;
    [SerializeField] LayerMask mountMask           = 0;

    [Header("Hold distance (scroll)")]
    [SerializeField] float holdDefault = 1.6f;
    [SerializeField] float holdMin     = 0.4f;
    [SerializeField] float holdMax     = 3.5f;
    [SerializeField] float scrollSpeed = 0.3f;      // wheel units → metres

    [Header("Movement & collision")]
    [SerializeField] bool  smoothFollow      = true;
    [SerializeField] float smoothSpeed       = 15f;
    [SerializeField] LayerMask worldMask     = ~0;   // collide with everything by default
    [SerializeField] float sweepSkin         = 0.02f;
    [SerializeField] float teleportDistance  = 1.0f; // “stuck” threshold

    [Header("Rotation (MMB)")]
    [SerializeField] float rotationDegPerPx  = 110f;

    // ────────────────────────────────────────────────────  public API ───────
    public  bool IsGrabbing                 => _grabbed != null;
    public  IGrabbable CurrentGrabbedItem   => _grabbed;
    public  event System.Action<bool,IGrabbable> OnGrabStateChanged;

    //  (public methods below, exactly like the old file) ─────────────────────
    public void InitializeController(PlayerManager mgr) => Initialise(mgr);
    public bool TryGrabOrDetachWorldObject()            => GrabOrDetach();
    public void DropGrabbedItemWithLMB()                => DropHeld();
    public void AdjustGrabbedItemDistance(float d)      => ScrollDistance(d);
    public void HandleStoreAction()                     => StoreOrPull();
    public bool TryAttachGrabbedPart()                  => TryAttachPart();
    public void StartGrabRotation()                     => _rotating = IsGrabbing;
    public void EndGrabRotation()                       => _rotating = false;
    public void ApplyGrabbedItemRotationInput(Vector2 d)=> RotateHeld(d);

    // ────────────────────────────────────────────────────  private state ────
    PlayerManager     _pm;
    IAimProvider      _aim;
    PlayerInventory   _inv;
    InteractionController _interact;

    IGrabbable  _grabbed;
    Transform   _grabTf;
    Rigidbody   _grabRb;
    Collider[]  _grabCols;

    bool        _rbWasKinematic, _rbHadGravity;
    RigidbodyInterpolation _rbInterp;
    CollisionDetectionMode _rbCCD;

    bool        _rotating;
    float       _holdDist;
    Quaternion  _heldRot;

    Transform   _anchor;            // child of camera

    // ────────────────────────────────────────────────────  unity plumbing ───
    void Awake()
    {
        if (TryGetComponent(out PlayerManager pm)) Initialise(pm);
    }

    void FixedUpdate()
    {
        if (!IsGrabbing || _grabRb == null || !_grabRb.isKinematic) return;

        // 1) anchor stays in front of camera
        _anchor.localPosition = new Vector3(0, 0, _holdDist);

        // 2) where we want to be
        Vector3 wantPos = _anchor.position;
        Vector3 curPos  = _grabRb.position;
        Vector3 delta   = wantPos - curPos;
        Vector3 nextPos = wantPos;

        // Sweep-test for blocking geometry
        if (delta.sqrMagnitude > 1e-6f &&
            _grabRb.SweepTest(delta.normalized, out var hit, delta.magnitude, QueryTriggerInteraction.Ignore))
        {
            nextPos = curPos + delta.normalized * Mathf.Max(0, hit.distance - sweepSkin);
        }

        // Teleport if hopelessly far
        if (Vector3.Distance(nextPos, wantPos) > teleportDistance)
            nextPos = wantPos;

        // 3) move & rotate
        if (smoothFollow)
        {
            _grabRb.MovePosition(Vector3.Lerp(curPos, nextPos, smoothSpeed * Time.fixedDeltaTime));
            _grabRb.MoveRotation(Quaternion.Slerp(_grabRb.rotation, _heldRot,  smoothSpeed * Time.fixedDeltaTime));
        }
        else
        {
            _grabRb.MovePosition(nextPos);
            _grabRb.MoveRotation(_heldRot);
        }
    }

    // ───────────────────────────────────── initialisation helper ────────────
    void Initialise(PlayerManager pm)
    {
        _pm  = pm;
        _aim = pm.Look;
        _inv = pm.Inventory;
        _interact = FindFirstObjectByType<InteractionController>();

        _holdDist = holdDefault;

        if (!_anchor)
        {
            _anchor = new GameObject("HoldAnchor").transform;
            _anchor.SetParent(_aim.GetLookTransform(), false);
            _anchor.localPosition = new Vector3(0, 0, _holdDist);
        }
    }

    // ─────────────────────────────────────────── grab / detach  ─────────────
    bool GrabOrDetach()
    {
        if (IsGrabbing)
        {
            if (TryAttachPart()) return true;
            DropHeld();
            return true;
        }
        return TryGrabFromScene();
    }

    bool TryGrabFromScene()
    {
        Ray ray = _aim.GetLookRay();

        // a) detach from MountPoint
        if (mountMask.value != 0 &&
            Physics.Raycast(ray, out var mHit, interactionReach, mountMask,
                            QueryTriggerInteraction.Collide))
        {
            var m = mHit.collider.GetComponentInParent<MountPoint>();
            if (m && m.CurrentlyAttachedPart)
            {
                BeginGrab(m.Detach(), mHit.distance);
                return true;
            }
        }

        // b) generic grabbable
        if (grabbableMask.value != 0 &&
            Physics.Raycast(ray, out var gHit, interactionReach, grabbableMask,
                            QueryTriggerInteraction.Collide))
        {
            var g = gHit.collider.GetComponentInParent<IGrabbable>();
            if (g != null && g.CanGrab())
            {
                BeginGrab(g, gHit.distance);
                return true;
            }
        }
        return false;
    }

    void BeginGrab(IGrabbable g, float hitDist)
    {
        // cache refs
        _grabbed = g;
        _grabTf  = g.GetTransform();
        _grabRb  = _grabTf.GetComponent<Rigidbody>();
        _grabCols= _grabTf.GetComponentsInChildren<Collider>(true);

        // cache & override RB
        if (_grabRb)
        {
            _rbWasKinematic = _grabRb.isKinematic;
            _rbHadGravity   = _grabRb.useGravity;
            _rbInterp       = _grabRb.interpolation;
            _rbCCD          = _grabRb.collisionDetectionMode;

            _grabRb.isKinematic            = true;
            _grabRb.useGravity             = false;
            _grabRb.interpolation          = RigidbodyInterpolation.Interpolate;
            _grabRb.collisionDetectionMode = CollisionDetectionMode.ContinuousSpeculative;
        }

        // ignore player collider
        if (_pm.CharacterController)
        {
            var pc = _pm.CharacterController.GetComponent<Collider>();
            foreach (var c in _grabCols) if (c) Physics.IgnoreCollision(pc, c, true);
        }

        _holdDist   = Mathf.Clamp(hitDist, holdMin, holdMax);
        _anchor.localPosition = new Vector3(0, 0, _holdDist);
        _heldRot    = _grabTf.rotation;
        _rotating   = false;

        _grabbed.OnGrabbed(_aim.GetLookTransform());
        OnGrabStateChanged?.Invoke(true, _grabbed);
    }

    void DropHeld()
    {
        if (!IsGrabbing) return;

        if (_grabRb)
        {
            _grabRb.isKinematic            = _rbWasKinematic;
            _grabRb.useGravity             = _rbHadGravity;
            _grabRb.interpolation          = _rbInterp;
            _grabRb.collisionDetectionMode = _rbCCD;

            if (!_grabRb.isKinematic)
            {
                var vel = _aim.GetLookRay().direction * 2f;
                _grabRb.linearVelocity  = vel;
                _grabRb.angularVelocity = Random.insideUnitSphere * 0.5f;
            }
        }

        // restore player collisions
        if (_pm.CharacterController)
        {
            var pc = _pm.CharacterController.GetComponent<Collider>();
            foreach (var c in _grabCols) if (c) Physics.IgnoreCollision(pc, c, false);
        }

        _grabbed.OnDropped(_grabRb ? _grabRb.linearVelocity : Vector3.zero);
        ClearGrabState(invokeEvent:true);
    }

    void ClearGrabState(bool invokeEvent)
    {
        var old = _grabbed;

        _grabbed = null;
        _grabTf  = null;
        _grabRb  = null;
        _grabCols= null;
        _rotating= false;
        _holdDist= holdDefault;
        _anchor.localPosition = new Vector3(0, 0, _holdDist);
        _heldRot = Quaternion.identity;

        if (invokeEvent && old != null) OnGrabStateChanged?.Invoke(false, old);
    }

    // ─────────────────────────────────────────── rotation / scroll ──────────
    void RotateHeld(Vector2 delta)
    {
        if (!IsGrabbing || !_rotating) return;
        var cam = _aim.GetLookTransform();
        _heldRot =
            Quaternion.AngleAxis(-delta.x * rotationDegPerPx * Time.deltaTime, Vector3.up) *
            Quaternion.AngleAxis( delta.y * rotationDegPerPx * Time.deltaTime, cam.right) *
            _heldRot;
    }

    void ScrollDistance(float scroll)
    {
        if (!IsGrabbing || _rotating) return;
        _holdDist = Mathf.Clamp(_holdDist + scroll * scrollSpeed, holdMin, holdMax);
        _anchor.localPosition = new Vector3(0, 0, _holdDist);
    }

    // ───────────────────────────────────────────── attach part ──────────────
    bool TryAttachPart()
    {
        if (!IsGrabbing || !(_grabbed is PartInstance part) || _interact == null) return false;

        var info = _interact.CurrentLookTargetInfo;
        if (info.HasTarget && info.Mount && info.Mount.IsCompatible(part))
        {
            if (info.Mount.TryAttach(part)) { ClearGrabState(invokeEvent:true); return true; }
        }
        return false;
    }

    // ───────────────────────────────────────── store / pull from inv ────────
    void StoreOrPull()
    {
        if (IsGrabbing) TryStoreHeld();
        else            TryPullAndGrab();
    }

    void TryStoreHeld()
    {
        if (!IsGrabbing || _inv == null) { DropHeld(); return; }

        var item = _grabbed.GetInventoryItemData();
        if (item == null || item.data == null) { DropHeld(); return; }

        bool ok = false;
        int sel = _inv.GetSelectedToolbarIndex();

        if (sel >= 0 && _inv.TryStoreItemInSpecificSlot(item, sel)) ok = true;
        else if (!item.data.isBulky) ok = _inv.RequestAddItemToInventory(item);

        if (ok)
        {
            _grabbed.OnStored();
            Destroy(_grabTf.gameObject);
            ClearGrabState(invokeEvent:true);
        }
        else DropHeld();
    }

    bool TryPullAndGrab()
    {
        if (_inv == null) return false;

        int sel = _inv.GetSelectedToolbarIndex();
        if (sel < 0) return false;

        if (!_inv.TryPullItemFromSlot(sel, out var pulled) ||
            pulled?.data?.worldPrefab == null) return false;

        var ray = _aim.GetLookRay();
        _holdDist = holdDefault;
        Vector3 pos = ray.GetPoint(_holdDist);
        Quaternion rot = _aim.GetLookTransform().rotation;

        var go = Instantiate(pulled.data.worldPrefab, pos, rot);
        if (!go) return false;

        var g = go.GetComponentInChildren<IGrabbable>();
        if (g == null) { Destroy(go); return false; }

        if      (g is ItemInstance ii) ii.Initialize(pulled);
        else if (g is WorldItem  wi) wi.Initialize(pulled);

        BeginGrab(g, _holdDist);
        return true;
    }
}
// --- End of script: Assets/Logic/Player/Grab/PlayerGrabController.cs ---

// --- Start of script: Assets/Logic/Player/Movement/CharacterMotor.cs ---
using UnityEngine;

public class CharacterMotor : MonoBehaviour
{
    private Vector3 moveDirection;
    private Rigidbody rb;

    [Header("Movement Settings")]
    public float walkingSpeed = 2.5f;
    public float runningSpeed = 5f;
    public float acceleration = 2.5f;

    [Header("Directional Speed Multipliers")]
    public float forwardMultiplier = 1f;
    public float backwardMultiplier = 0.5f;
    public float strafeMultiplier = 0.75f;

    [Header("Air Control Settings")]
    [Range(0f, 1f)]
    public float airControlFactor = 0.1f;
    public float airDragFactor = 0.1f;

    [Header("Ground Drag Settings")]
    public float groundDragFactor = 5f;

    [Header("Jump Settings")]
    public float jumpForce = 6.5f;
    public float gravityMultiplier = 2f;
    public float groundCheckDistance = 0.2f;

    [Header("Debug")]
    public bool isGrounded;
    private bool isRunning;

    void Awake()
    {
        rb = GetComponent<Rigidbody>();
    }

    void FixedUpdate()
    {
        CheckGrounded();
        ApplyExtraGravity();
        ApplyAirDrag();
        Move();
    }

    public void SetMoveDirection(Vector3 direction, bool running)
    {
        moveDirection = direction;
        isRunning = running;
    }

    public void Move()
    {
        // Determine direction relative to character's forward
        Vector3 localMoveDir = transform.InverseTransformDirection(moveDirection.normalized);
        float directionMultiplier;

        if (localMoveDir.z > 0.7f) // Mostly forward
            directionMultiplier = forwardMultiplier;
        else if (localMoveDir.z < -0.3f) // Mostly backward
            directionMultiplier = backwardMultiplier;
        else // Mostly sideways
            directionMultiplier = strafeMultiplier;

        float baseSpeed = isRunning ? runningSpeed : walkingSpeed;
        float targetSpeed = baseSpeed * directionMultiplier;
        Vector3 desiredVelocity = moveDirection * targetSpeed;

        if (isGrounded)
        {
            if (moveDirection != Vector3.zero)
            {
                Vector3 velocityChange = desiredVelocity - rb.linearVelocity;
                velocityChange.y = 0f;

                Vector3 clampedForce = Vector3.ClampMagnitude(velocityChange, acceleration);
                rb.AddForce(clampedForce, ForceMode.VelocityChange);
            }
            else
            {
                // Apply manual ground drag
                Vector3 horizontalVelocity = new Vector3(rb.linearVelocity.x, 0f, rb.linearVelocity.z);
                Vector3 groundDrag = -horizontalVelocity * groundDragFactor;
                rb.AddForce(groundDrag, ForceMode.Acceleration);
            }
        }
        else
        {
            Vector3 horizontalVelocity = new Vector3(rb.linearVelocity.x, 0f, rb.linearVelocity.z);
            Vector3 airVelocityChange = desiredVelocity - horizontalVelocity;
            airVelocityChange.y = 0f;

            Vector3 clampedAirForce = Vector3.ClampMagnitude(airVelocityChange, acceleration * airControlFactor);
            rb.AddForce(clampedAirForce, ForceMode.VelocityChange);
        }
    }

    public void Jump()
    {
        if (!isGrounded) return;

        rb.linearVelocity = new Vector3(rb.linearVelocity.x, 0f, rb.linearVelocity.z);
        rb.AddForce(Vector3.up * jumpForce, ForceMode.VelocityChange);
    }

    public void Rotate(float x)
    {
        transform.rotation = Quaternion.Euler(0f, x, 0f);
    }

    private void CheckGrounded()
    {
        Vector3 origin = transform.position + Vector3.up * 0.1f;
        isGrounded = Physics.Raycast(origin, Vector3.down, groundCheckDistance + 0.1f);
    }

    private void ApplyExtraGravity()
    {
        if (!isGrounded)
        {
            rb.AddForce(Physics.gravity * gravityMultiplier, ForceMode.Acceleration);
        }
    }

    private void ApplyAirDrag()
    {
        if (!isGrounded)
        {
            Vector3 horizontalVelocity = new Vector3(rb.linearVelocity.x, 0f, rb.linearVelocity.z);
            Vector3 drag = -horizontalVelocity * airDragFactor;
            rb.AddForce(drag, ForceMode.Acceleration);
        }
    }

    public bool IsGrounded => isGrounded;
    public Vector3 CurrentVelocity => rb.linearVelocity;
}
// --- End of script: Assets/Logic/Player/Movement/CharacterMotor.cs ---

// --- Start of script: Assets/Logic/Player/Movement/MyCharacterController.cs ---
using UnityEngine;
using KinematicCharacterController;
using System.Collections.Generic;

// Interface ICharacterController from KCC remains
public class MyCharacterController : MonoBehaviour, ICharacterController
{
    public KinematicCharacterMotor Motor;

    [Header("Movement Settings")]
    public float walkSpeed = 2.5f;
    public float runSpeed = 5f;
    public float slowSpeed = 1.5f;
    public float crouchSpeed = 1.2f;
    public float acceleration = 10f;
    public float airControlMultiplier = 0.3f;
    public float maxAirSpeed = 5f;

    [Header("Jumping")]
    public float jumpForce = 6f;
    public float groundGraceTime = 0.15f;

    [Header("Crouch")]
    public float standingHeight = 2f;
    public float crouchedHeight = 1f;
    public float capsuleRadius = 0.5f;
    [Tooltip("Speed at which capsule height changes")]
    public float crouchTransitionSpeed = 10f;

    [Header("Head")]
    [Tooltip("Speed at which the visual head follows capsule height")]
    public float headFollowSpeed = 15f;

    [Header("Gravity")]
    public Vector3 gravity = new Vector3(0, -25f, 0);

    [Header("Debug")]
    public bool isCrouching;
    public float smoothedHeight { get; private set; }

    // Public read-only properties for state if needed externally
    public Vector3 Velocity { get; private set; }
    public bool IsSprinting { get; private set; }
    public bool IsSlowWalking { get; private set; }


    // Internal state variables
    private Vector2 _moveInputAxis; // Store raw axis input
    private Vector3 _lookDirection = Vector3.forward;
    private bool _jumpRequested;
    private bool _jumpConsumed;
    private float _timeSinceLastGrounded = Mathf.Infinity;
    private float _timeSinceJumpRequested = Mathf.Infinity;
    private bool _isCrouchHeld; // Changed from _shouldBeCrouching
    private bool _forceSlowWalk; // Keep this for external control
    private float _currentSpeed;
    private List<Collider> _ignored = new(); // For KCC collision filtering

    private float _visualHeadHeight;

    private void Awake()
    {
        Motor.CharacterController = this;
        smoothedHeight = standingHeight;
        _visualHeadHeight = standingHeight; // Initialize visual height
    }

    // --- NEW Public Methods for Input ---

    public void SetMoveInput(Vector2 moveAxis)
    {
        _moveInputAxis = moveAxis;
    }

    public void SetLookDirection(Vector3 worldLookDirection) // Called by PlayerManager
    {
        if (worldLookDirection.sqrMagnitude > 0.01f)
            _lookDirection = worldLookDirection.normalized;
    }

    public void OnJumpPressed() // Called by PlayerManager on Jump event
    {
        _jumpRequested = true;
        _timeSinceJumpRequested = 0f;
    }

    public void SetSprint(bool value) // Called by PlayerManager on Sprint event start/cancel
    {
        IsSprinting = value;
    }

    public void SetCrouch(bool value) // Called by PlayerManager on Crouch event start/cancel
    {
        _isCrouchHeld = value;
    }

     public void SetSlowWalk(bool value) // Called by PlayerManager on SlowWalk event start/cancel
    {
        IsSlowWalking = value;
    }

    public void ForceSlowWalk(bool value) // Keep this for external systems (e.g., aiming)
    {
         _forceSlowWalk = value;
    }

    // --- KCC Interface Implementation ---

    public void UpdateVelocity(ref Vector3 currentVelocity, float deltaTime)
    {
        _timeSinceLastGrounded += deltaTime;
        _timeSinceJumpRequested += deltaTime;

        // Calculate current target speed based on state
        if (_isCrouchHeld)
        {
            _currentSpeed = crouchSpeed;
        }
        else
        {
            _currentSpeed = (_forceSlowWalk || IsSlowWalking) ? slowSpeed : (IsSprinting ? runSpeed : walkSpeed);
        }

        // Transform move input axis to world space direction based on look direction
        Vector3 inputDirection = new Vector3(_moveInputAxis.x, 0f, _moveInputAxis.y).normalized;
        Vector3 right = Vector3.Cross(Motor.CharacterUp, _lookDirection).normalized; // Ensure normalization
        Vector3 forward = Vector3.Cross(right, Motor.CharacterUp).normalized;      // Ensure normalization
        Vector3 moveDirectionWorld = (right * inputDirection.x + forward * inputDirection.z);
        // Normalize moveDirectionWorld only if input is non-zero to avoid normalizing zero vector
        if (moveDirectionWorld.sqrMagnitude > 0.01f)
            moveDirectionWorld.Normalize();


        if (Motor.GroundingStatus.IsStableOnGround)
        {
            _timeSinceLastGrounded = 0f;
            _jumpConsumed = false; // Reset jump flag when grounded

            // Calculate target velocity on ground
            Vector3 targetVelocity = moveDirectionWorld * _currentSpeed;

            // Smoothly interpolate towards the target velocity
            // Using Lerp for acceleration feel
            currentVelocity = Vector3.Lerp(currentVelocity, targetVelocity, 1f - Mathf.Exp(-acceleration * deltaTime));

            // Handle jumping
            if (_jumpRequested && _timeSinceJumpRequested <= groundGraceTime)
            {
                // Calculate jump direction before applying force
                Vector3 jumpDirection = Motor.CharacterUp;
                if (Motor.GroundingStatus.GroundNormal.sqrMagnitude > 0f)
                {
                    // Optional: Jump slightly away from slope normal
                    jumpDirection = (jumpDirection + Motor.GroundingStatus.GroundNormal * 0.1f).normalized;
                }

                // Apply jump force
                Motor.ForceUnground(0.1f); // Slightly unground to ensure liftoff
                currentVelocity += jumpDirection * jumpForce - Vector3.Project(currentVelocity, Motor.CharacterUp); // Add jump vel, remove existing vertical

                _jumpConsumed = true;
                _jumpRequested = false;
            }
        }
        else // In Air
        {
            // Air control: Add horizontal acceleration
            Vector3 horizontalVelocity = Vector3.ProjectOnPlane(currentVelocity, Motor.CharacterUp);
            Vector3 airAcceleration = moveDirectionWorld * (acceleration * airControlMultiplier); // Accel based on input

            // Calculate new horizontal velocity limited by max air speed
            Vector3 newHorizontalVelocity = horizontalVelocity + airAcceleration * deltaTime;
            if (newHorizontalVelocity.magnitude > maxAirSpeed)
            {
                newHorizontalVelocity = newHorizontalVelocity.normalized * maxAirSpeed;
            }

            // Apply horizontal change and gravity
            currentVelocity = newHorizontalVelocity + Vector3.Project(currentVelocity, Motor.CharacterUp); // Keep existing vertical
            currentVelocity += gravity * deltaTime; // Apply gravity

            // Coyote time jump
            if (!_jumpConsumed && _jumpRequested && _timeSinceLastGrounded <= groundGraceTime)
            {
                 // Calculate jump direction
                 Vector3 jumpDirection = Motor.CharacterUp;
                 // Apply jump force
                 currentVelocity += jumpDirection * jumpForce - Vector3.Project(currentVelocity, Motor.CharacterUp);

                 _jumpConsumed = true;
                 _jumpRequested = false;
            }
        }

         // Reset jump request if it wasn't consumed quickly enough
         if (_timeSinceJumpRequested > groundGraceTime * 2f) // Allow slightly more time than grace period
         {
             _jumpRequested = false;
         }

        Velocity = currentVelocity; // Update stored Velocity every frame
    }

    public void UpdateRotation(ref Quaternion currentRotation, float deltaTime)
    {
        // KCC usually handles rotation based on velocity or look direction.
        // If you need custom rotation logic, implement it here.
        // For FPS, usually the root object (this transform) rotates only around Y based on PlayerLook.
        // Let PlayerLook handle Y rotation of the parent, KCC handles movement.
        // So, often empty for FPS unless specific needs arise.
    }

    public void BeforeCharacterUpdate(float deltaTime)
    {
        // Called before Motor velocity/rotation updates. Good place for input processing
        // IF you weren't using the event-driven approach. Now largely handled by events.
    }

    public void AfterCharacterUpdate(float deltaTime)
    {
        // Update capsule height based on crouch state
        float targetHeight = _isCrouchHeld ? crouchedHeight : standingHeight;
        // Use SmoothDamp for smoother visual transition (optional, Lerp is also fine)
        // smoothedHeight = Mathf.SmoothDamp(smoothedHeight, targetHeight, ref _capsuleResizeVelocity, 0.1f, crouchTransitionSpeed, deltaTime);
        smoothedHeight = Mathf.Lerp(smoothedHeight, targetHeight, 1f - Mathf.Exp(-crouchTransitionSpeed * deltaTime)); // Exponential lerp is often nice

        // Prevent resizing if obstructed (KCC doesn't do this automatically for capsule height changes)
        // TODO: Add obstruction check before setting Motor capsule dimensions if needed

        float center = smoothedHeight * 0.5f;
        Motor.SetCapsuleDimensions(capsuleRadius, smoothedHeight, center);
        isCrouching = Mathf.Abs(smoothedHeight - crouchedHeight) < 0.05f; // Update debug flag

        // Update visual head height smoothly following capsule top
        // Offset slightly below the absolute top for better feel
        float targetVisualHeight = smoothedHeight - 0.1f;
        _visualHeadHeight = Mathf.Lerp(_visualHeadHeight, targetVisualHeight, 1f - Mathf.Exp(-headFollowSpeed * deltaTime));
    }

    // --- Helper Methods ---
    public Vector3 GetSmoothedHeadWorldPosition()
    {
        // Use the smoothed visual head height
        return transform.position + Vector3.up * _visualHeadHeight;
    }

    public Vector3 GetVelocity() => Velocity; // Getter remains useful

    // --- KCC Collision Callbacks ---
    public void PostGroundingUpdate(float deltaTime) { }
    public void OnGroundHit(Collider hitCollider, Vector3 hitNormal, Vector3 hitPoint, ref HitStabilityReport stabilityReport) { }
    public void OnMovementHit(Collider hitCollider, Vector3 hitNormal, Vector3 hitPoint, ref HitStabilityReport stabilityReport) { }
    public void ProcessHitStabilityReport(Collider hitCollider, Vector3 hitNormal, Vector3 hitPoint, Vector3 position, Quaternion rotation, ref HitStabilityReport report) { }
    public void OnDiscreteCollisionDetected(Collider hitCollider) { }
    public bool IsColliderValidForCollisions(Collider coll) => !_ignored.Contains(coll); // Basic ignore list
    public void AddIgnoredCollider(Collider coll) { if (!_ignored.Contains(coll)) _ignored.Add(coll); }
    public void RemoveIgnoredCollider(Collider coll) { _ignored.Remove(coll); }
}
// --- End of script: Assets/Logic/Player/Movement/MyCharacterController.cs ---

// --- Start of script: Assets/Logic/Projectile/Bullet/556Behavior.cs ---
using UnityEngine;

public class NineMMBehavior : BulletBehavior
{
    // Use Awake instead of Start to modify bullet speed in the derived class
    protected override void Start()
    {
        base.Start();  // Call base class Awake method if it exists
    }

    protected override void OnHit(RaycastHit hit)
    {
        base.OnHit(hit);

        // Apply 9mm bullet damage
        IDamageable damageable = hit.collider.GetComponentInParent<IDamageable>();
        if (damageable != null)
        {
            damageable.TakeDamage(15f, hit.point, velocity.normalized); // Specific damage for 9mm
        }
    }
}
// --- End of script: Assets/Logic/Projectile/Bullet/556Behavior.cs ---

// --- Start of script: Assets/Logic/Projectile/Bullet/BulletAudioHandler.cs ---
using UnityEngine;

[RequireComponent(typeof(AudioSource))]
public class BulletAudioHandler : MonoBehaviour
{
    [Header("Audio Clips")]
    [SerializeField] private AudioClip impactClip;       // "Bullet impact sound"

    [Header("Volume Settings")]
    [SerializeField] private float impactVolume = 0.8f;

    private AudioSource audioSource;

    private void Awake()
    {
        audioSource = GetComponent<AudioSource>();
        audioSource.playOnAwake = false;
    }

    // Play impact sound when the bullet hits something
    public void PlayImpactSound()
    {
        if (impactClip != null)
        {
            audioSource.PlayOneShot(impactClip, impactVolume);
        }
    }
}
// --- End of script: Assets/Logic/Projectile/Bullet/BulletAudioHandler.cs ---

// --- Start of script: Assets/Logic/Projectile/Bullet/BulletBehavior.cs ---
using UnityEngine;

public class BulletBehavior : ProjectileBehavior
{
    [Header("Settings")]
    [SerializeField] protected float impactForceMultiplier = 1f;

    protected bool hasLaunched = false;
    protected Vector3 velocity;

    [Header("References")]
    protected BulletAudioHandler audioHandler;
    protected HoleDecalSpawner holeDecalSpawner;

    protected virtual void Start()
    {
        audioHandler = GetComponent<BulletAudioHandler>();
        holeDecalSpawner = GetComponent<HoleDecalSpawner>();
    }

    private void FixedUpdate()
    {
        if (!hasLaunched) return;

        // Apply gravity (optional for realism)
        Vector3 gravity = new Vector3(0f, -9.81f, 0f);
        velocity += gravity * Time.fixedDeltaTime;
        Vector3 movement = velocity * Time.fixedDeltaTime;

        Vector3 currentPosition = transform.position;
        Vector3 nextPosition = currentPosition + movement;

        // Raycast to detect collision
        int interactableLayer = LayerMask.NameToLayer("Interactable");
        int everythingExceptInteractables = ~(1 << interactableLayer);

        if (Physics.Raycast(currentPosition, movement.normalized, out RaycastHit hit, movement.magnitude, everythingExceptInteractables, QueryTriggerInteraction.Ignore))
        {
            OnHit(hit);
        }
        else
        {
            transform.position = nextPosition;
            if (velocity != Vector3.zero)
                transform.rotation = Quaternion.LookRotation(velocity);
        }
    }

    public override void Launch(Vector3 direction, float force)
    {
        if (hasLaunched) return;

        hasLaunched = true;
        velocity = direction.normalized * force;
        transform.rotation = Quaternion.LookRotation(direction);
    }

    protected virtual void OnHit(RaycastHit hit)
    {
        // Apply impact force if possible
        if (hit.rigidbody != null)
        {
            Vector3 force = velocity * impactForceMultiplier;
            hit.rigidbody.AddForceAtPosition(force, hit.point, ForceMode.Impulse);
        }

        // Deal damage
        IDamageable damageable = hit.collider.GetComponentInParent<IDamageable>();
        if (damageable != null)
        {
            damageable.TakeDamage(10f, hit.point, velocity.normalized);
        }

        // Play impact sound
        audioHandler?.PlayImpactSound();

        // Spawn decal
        if (holeDecalSpawner != null)
        {
            holeDecalSpawner.SpawnDecal(hit.point, hit.normal, hit.transform);
        }

        // Immediately destroy bullet
        Destroy(gameObject);
    }
}
// --- End of script: Assets/Logic/Projectile/Bullet/BulletBehavior.cs ---

// --- Start of script: Assets/Logic/Projectile/Bullet/NineMMBehavior.cs ---
using UnityEngine;

public class NineMMBulletProjectile : BulletBehavior
{
    // Use Awake instead of Start to modify bullet speed in the derived class
    protected override void Start()
    {
        base.Start();  // Call base class Awake method if it exists
    }

    protected override void OnHit(RaycastHit hit)
    {
        base.OnHit(hit);

        // Apply 9mm bullet damage
        IDamageable damageable = hit.collider.GetComponentInParent<IDamageable>();
        if (damageable != null)
        {
            damageable.TakeDamage(15f, hit.point, velocity.normalized); // Specific damage for 9mm
        }
    }
}
// --- End of script: Assets/Logic/Projectile/Bullet/NineMMBehavior.cs ---

// --- Start of script: Assets/Logic/Vehicles/Core/FirearmInstance.cs ---
using UnityEngine;

/// <summary>
/// Represents a firearm existing as a grabbable object in the world.
/// Inherits ItemInstance to handle data and grabbing.
/// Holds FirearmRuntimeState but performs no active simulation when dropped.
/// </summary>
[RequireComponent(typeof(Rigidbody))]
[RequireComponent(typeof(Collider))]
public class FirearmInstance : ItemInstance { // Inherit directly from ItemInstance

    // No simulation variables needed for a dropped firearm instance

    protected override void Awake() {
        base.Awake();
        // No firearm-specific Awake logic needed here typically
    }

    /// <summary>
    /// Initialize: Calls base, then validates the specific state type.
    /// </summary>
    public override void Initialize(InventoryItem itemInstance) {
        base.Initialize(itemInstance); // Sets ItemInstanceData, name, calls UpdatePhysicsForDrop
        if (!this.enabled) return; // Check if base Initialize failed

        // Validate that the runtime state is the correct type after base Initialize
        if (GetRuntimeState<FirearmRuntimeState>() == null) {
             // This indicates an issue with the InventoryItem provided (likely missing state or wrong type)
             Debug.LogError($"[{gameObject.name}] FirearmInstance initialized but FirearmRuntimeState is missing or invalid! Check Spawner/Item creation.", this);
             enabled = false; // Disable if state is wrong
        }
        // No other Firearm-specific initialization needed for the *dropped* instance.
    }

    // Optional: Override UpdateInventoryItemRuntimeState if needed, but typically
    // the state doesn't change while the firearm is just lying on the ground.
    // protected override void UpdateInventoryItemRuntimeState() {
    //     base.UpdateInventoryItemRuntimeState();
    //     // If there were any state changes possible while dropped (unlikely for firearm), sync here.
    // }

     // Optional: Override OnGrabbed/OnDropped/OnStored if FirearmInstance needs
     // specific behavior beyond the base ItemInstance implementation during these events.
     // public override void OnGrabbed(Transform grabberTransform) { base.OnGrabbed(grabberTransform); /* Firearm specific grab logic? */ }
     // public override void OnDropped(Vector3 dropVelocity) { base.OnDropped(dropVelocity); /* Firearm specific drop logic? */ }
     // public override void OnStored() { base.OnStored(); /* Firearm specific store logic? */ }
}
// --- End of script: Assets/Logic/Vehicles/Core/FirearmInstance.cs ---

// --- Start of script: Assets/Logic/Vehicles/Core/ItemInstance.cs ---
// --- Assets/Logic/Vehicles/Core/ItemInstance.cs ----------------------
using UnityEngine;

/// <summary>
/// Abstract base class for ANY item that exists physically in the world
/// and can be grabbed. Holds InventoryItem data and manages basic physics/grabbing.
/// </summary>
[RequireComponent(typeof(Collider))]
public abstract class ItemInstance : MonoBehaviour, IGrabbable {

    [Tooltip("The core data for this instance. Set via Initialize.")]
    [SerializeField] // For Debug Inspector viewing
    protected InventoryItem itemInstanceData;
    public InventoryItem ItemInstanceData => itemInstanceData; // Read-only public access

    // Common components
    protected Rigidbody _rigidbody;
    protected Collider[] _colliders;
    protected bool _originalRigidbodyKinematicState;
    protected bool _originalRigidbodyGravityState;
    // Cache other original physics properties if needed (e.g., drag, angularDrag, constraints)
    // protected float _originalDrag;
    // protected float _originalAngularDrag;
    protected int _originalLayer;


    /// <summary>
    /// Base Awake: Finds components, caches physics state.
    /// </summary>
    protected virtual void Awake() {
        _rigidbody = GetComponent<Rigidbody>(); 
        if (_rigidbody != null) {
            _originalRigidbodyKinematicState = _rigidbody.isKinematic;
            _originalRigidbodyGravityState = _rigidbody.useGravity;
            // _originalDrag = _rigidbody.drag;
            // _originalAngularDrag = _rigidbody.angularDrag;
        }
        else { // Sensible defaults if no RB, though IGrabbable usually implies a physics object
            _originalRigidbodyKinematicState = true; 
            _originalRigidbodyGravityState = false;
        }
        _colliders = GetComponentsInChildren<Collider>(true);
        _originalLayer = gameObject.layer;
    }

    /// <summary>
    /// Main Initialization method for ALL ItemInstances. Assigns the authoritative InventoryItem data.
    /// Derived classes override to perform specific setup *after* calling base.Initialize().
    /// </summary>
    public virtual void Initialize(InventoryItem itemDataToAssign) {
        if (!ValidateItemInstance_Base(itemDataToAssign, gameObject.name)) {
             Debug.LogError($"[{gameObject.name}] Initialize failed: Invalid InventoryItem.", this);
             enabled = false; return;
        }
        this.itemInstanceData = itemDataToAssign;
        gameObject.name = $"ItemInst_{itemInstanceData.data?.itemName ?? GetType().Name}";
        
        // If this item is instantiated directly into the world (not via player grabbing then dropping),
        // ensure its physics state is correctly set based on its original prefab settings.
        UpdatePhysicsForInitialSpawn();
        enabled = true;
    }

    /// <summary>
    /// VIRTUAL: Updates the state object within ItemInstanceData FROM internal variables if needed,
    /// just before the item state is read (e.g., grabbing, storing).
    /// Base implementation checks for nulls. Derived classes override if they cache state.
    /// </summary>
    protected virtual void UpdateInventoryItemRuntimeState() {
        if (this.itemInstanceData == null || this.itemInstanceData.runtime == null) {
            // This is okay if the item type simply has no runtime state.
        }
    }

    /// <summary>
    /// Base validation for InventoryItem structure.
    /// </summary>
    protected bool ValidateItemInstance_Base(InventoryItem itemInstance, string contextObjectName) {
         if (itemInstance == null) { Debug.LogError($"[{contextObjectName}] Validate FAIL: Null InventoryItem!", this); return false; }
         if (itemInstance.data == null) { Debug.LogError($"[{contextObjectName}] Validate FAIL: ItemData is null!", this); return false; }
         return true;
    }

    /// <summary>
    /// Sets the Rigidbody state when the item is initially spawned into the world
    /// (e.g., by an ItemSpawner, not when dropped by player after grabbing).
    /// </summary>
    protected void UpdatePhysicsForInitialSpawn() {
        if (_rigidbody != null) {
            _rigidbody.isKinematic = _originalRigidbodyKinematicState;
            _rigidbody.useGravity = _originalRigidbodyGravityState;
            // _rigidbody.drag = _originalDrag;
            // _rigidbody.angularDrag = _originalAngularDrag;
        }
    }

    /// <summary>
    /// Sets the Rigidbody state when the item is grabbed by the player.
    /// It's important that the _original... states are cached *before* this is called if not already done in Awake.
    /// </summary>
    protected void UpdatePhysicsForGrab() {
        if (_rigidbody != null) {
            // Cache current state if not already done (e.g. if Awake didn't run or was overridden)
            // This is a safety net, Awake should handle the primary caching.
            if(!Application.isPlaying || Time.frameCount < 2) // rough check if awake might not have set them yet
            {
                 _originalRigidbodyKinematicState = _rigidbody.isKinematic;
                 _originalRigidbodyGravityState = _rigidbody.useGravity;
            }

            _rigidbody.isKinematic = true;
            _rigidbody.useGravity = false;
            // Optionally, you might want to set drag/angularDrag to 0 while held
            // _rigidbody.drag = 0f;
            // _rigidbody.angularDrag = 0.05f; // Small angular drag can help stabilize
        }
    }


    // --- Getters ---
    public T GetItemData<T>() where T : ItemData => ItemInstanceData?.data as T;
    public T GetRuntimeState<T>() where T : class, IRuntimeState => ItemInstanceData?.runtime as T;

    #region IGrabbable Implementation (public virtual methods)

    public virtual InventoryItem GetInventoryItemData() {
        if (ItemInstanceData == null) { Debug.LogError($"[{gameObject.name}] GetInventoryItemData: ItemInstanceData is NULL!", this); return null; }
        UpdateInventoryItemRuntimeState(); 
        return this.ItemInstanceData;
    }

    public virtual Transform GetTransform() { return this.transform; }

    public virtual bool CanGrab() { return this.enabled && ItemInstanceData != null; }

    public virtual void OnGrabbed(Transform grabberTransform) {
        UpdateInventoryItemRuntimeState(); 
        UpdatePhysicsForGrab(); 
    }

    /// <summary>
    /// Called by PlayerGrabController when the item is dropped.
    /// PlayerGrabController is responsible for making the Rigidbody dynamic and applying initial velocities.
    /// This method should handle unparenting and any item-specific logic on being dropped.
    /// </summary>
    public virtual void OnDropped(Vector3 dropVelocity) {
        transform.SetParent(null);
        // DO NOT call UpdatePhysicsForInitialSpawn() or UpdatePhysicsForDrop() here if PGC manages the drop physics state.
        // The Rigidbody's kinematic and gravity state should have already been set by PlayerGrabController.
        // If you need to restore other specific Rigidbody properties (like constraints, drag, if modified by OnGrabbed),
        // do that here selectively, ensuring not to override isKinematic or useGravity.
        // For example:
        // if (_rigidbody != null) {
        //     _rigidbody.drag = _originalDrag;
        //     _rigidbody.angularDrag = _originalAngularDrag;
        // }
    }

    public virtual void OnStored() { /* Called just before Destroy after storing */ }

    #endregion
}
// --- End of script: Assets/Logic/Vehicles/Core/ItemInstance.cs ---

// --- Start of script: Assets/Logic/Vehicles/Core/MountPoint.cs ---
using UnityEngine;
using System.Linq; // For Any

/// <summary>
/// Represents a connection point on a PartInstance where other parts can be attached.
/// Handles compatibility checks and attachment/detachment logic.
/// </summary>
public class MountPoint : MonoBehaviour {

    [Tooltip("Unique ID for this mount point within its parent PartData (e.g., 'EngineOutput', 'WheelHub_FL'). MUST match an ID in the ParentPartInstance's CarPartData.providedMountPoints list.")]
    public string mountPointDefinitionID; // Set this in the Inspector on the prefab

    private MountPointDefinition _definition; // Cached definition

    // --- Properties ---
    /// <summary>
    /// The PartInstance that owns this MountPoint.
    /// </summary>
    public PartInstance ParentPartInstance { get; private set; }

    /// <summary>
    /// The PartInstance currently attached to this MountPoint (null if empty).
    /// </summary>
    public PartInstance CurrentlyAttachedPart { get; private set; }

    /// <summary>
    /// Gets the MountPointDefinition associated with this mount point ID from the ParentPartInstance's data.
    /// Caches the result for performance.
    /// </summary>
    public MountPointDefinition Definition {
        get {
            // Only search if definition is null AND we have a valid parent
            if (_definition == null && ParentPartInstance != null) {
                // Use the correct generic GetItemData method inherited by PartInstance
                CarPartData parentDef = ParentPartInstance.GetItemData<CarPartData>();
                if (parentDef != null) {
                    if (parentDef.providedMountPoints != null) {
                        _definition = parentDef.providedMountPoints.Find(mpd => mpd.mountPointID == mountPointDefinitionID);
                        if (_definition == null) {
                             // Keep warning, this is a setup error
                             Debug.LogWarning($"MountPoint '{mountPointDefinitionID}' on '{ParentPartInstance.name}' not found in its CarPartData.providedMountPoints list. Check definition IDs.", ParentPartInstance);
                        }
                    } else {
                         Debug.LogWarning($"MountPoint '{mountPointDefinitionID}' on '{ParentPartInstance.name}': Parent CarPartData '{parentDef.name}' has a null providedMountPoints list.", ParentPartInstance);
                    }
                }
                // else: ParentPartInstance doesn't have CarPartData (shouldn't happen if validation is correct)
            }
            return _definition;
        }
    }

    /// <summary>
    /// Initializes the MountPoint with its parent PartInstance.
    /// Called by PartInstance during its setup.
    /// </summary>
    public void Initialize(PartInstance parent) {
        this.ParentPartInstance = parent;
        // Validate required fields
        if (string.IsNullOrEmpty(mountPointDefinitionID)) {
            Debug.LogError($"MountPoint on '{parent?.name ?? "Unknown Parent"}' is missing its required 'Mount Point Definition ID'!", this);
        }
        _definition = null; // Clear cached definition on re-initialization
    }

    /// <summary>
    /// Checks if the given partToAttach is compatible with this MountPoint's definition.
    /// </summary>
    public bool IsCompatible(PartInstance partToAttach) {
        // Ensure definition is resolved and part exists
        MountPointDefinition currentDef = this.Definition; // Use property to resolve if needed
        if (currentDef == null) {
             Debug.LogWarning($"[{ParentPartInstance?.name ?? "UnknownParent"}.{mountPointDefinitionID}] IsCompatible check failed: MountPointDefinition is unresolved. Check ID and parent's data.", this);
             return false;
        }
        if (partToAttach == null) {
             // Debug.LogWarning($"[{ParentPartInstance?.name ?? "UnknownParent"}.{mountPointDefinitionID}] IsCompatible check failed: partToAttach is null.", this);
             return false;
        }

        // Ensure part to attach has valid data
        CarPartData dataOfPartToAttach = partToAttach.GetItemData<CarPartData>();
        if (dataOfPartToAttach == null) {
             Debug.LogWarning($"[{ParentPartInstance?.name ?? "UnknownParent"}.{mountPointDefinitionID}] IsCompatible check failed: Part '{partToAttach.name}' is missing CarPartData.", partToAttach);
             return false;
        }

        // Check if already occupied
        if (CurrentlyAttachedPart != null) return false;

        // Check PartType compatibility
        // If acceptedPartTypes list is empty, it accepts *any* PartType (use carefully).
        bool typeMatch = !currentDef.acceptedPartTypes.Any() || currentDef.acceptedPartTypes.Contains(dataOfPartToAttach.partTypeEnum);
        if (!typeMatch) {
            // Debug.Log($"Type mismatch: Mount '{mountPointDefinitionID}' accepts [{string.Join(",", Definition.acceptedPartTypes)}] but got {dataOfPartToAttach.partTypeEnum}");
            return false;
        }

        // Optional: Check required interfaces (using Reflection, can be slow)
        if (currentDef.requiredInterfaces != null && currentDef.requiredInterfaces.Count > 0) {
            foreach (string interfaceName in currentDef.requiredInterfaces) {
                if (string.IsNullOrEmpty(interfaceName)) continue;
                // Robust type lookup requires searching assemblies if not in default
                System.Type interfaceType = System.Type.GetType(interfaceName, false); // false = don't throw exception
                 if (interfaceType == null) {
                     // Try searching loaded assemblies (more robust but slower first time)
                     // interfaceType = AppDomain.CurrentDomain.GetAssemblies()
                     //                  .SelectMany(asm => asm.GetTypes())
                     //                  .FirstOrDefault(t => t.IsInterface && t.Name == interfaceName);
                      Debug.LogWarning($"MountPoint '{mountPointDefinitionID}': Could not find required interface type '{interfaceName}'. Check spelling/assembly.", this);
                      // Decide: fail compatibility or ignore missing interface? Fail is safer.
                      return false;
                 }

                if (!interfaceType.IsInterface) {
                     Debug.LogWarning($"MountPoint '{mountPointDefinitionID}': Required interface name '{interfaceName}' is not actually an interface type.", this);
                     return false;
                }

                // Check if the PartInstance's script implements the interface
                if (!interfaceType.IsAssignableFrom(partToAttach.GetType())) {
                    // Debug.Log($"Part {dataOfPartToAttach.itemName} ({partToAttach.GetType().Name}) does not implement required interface {interfaceName} for mount {mountPointDefinitionID}");
                    return false; // Interface requirement not met
                }
            }
        }

        // All checks passed
        return true;
    }

    /// <summary>
    /// Attempts to attach the given part to this mount point.
    /// Performs compatibility check, parents the transform, and notifies connected parts.
    /// </summary>
    /// <returns>True if attachment was successful, false otherwise.</returns>
    public bool TryAttach(PartInstance partToAttach) {
        if (!IsCompatible(partToAttach)) {
            // Debug.Log($"Attach failed: {partToAttach?.name ?? "NullPart"} not compatible with {ParentPartInstance?.name ?? "NullParent"}.{mountPointDefinitionID}");
            return false;
        }

        CurrentlyAttachedPart = partToAttach;
        Transform partTransform = partToAttach.transform;

        // Attach physically
        partTransform.SetParent(this.transform, false); // Use worldPositionStays = false
        partTransform.localPosition = Vector3.zero;   // Snap to mount point origin
        partTransform.localRotation = Quaternion.identity; // Snap to mount point rotation

        // Notify parts about connection (simplistic remote ID handling)
        string remoteMountID = "unknown_connection"; // TODO: Implement proper handshake if needed
        ParentPartInstance?.OnPartConnected(this.mountPointDefinitionID, partToAttach, remoteMountID);
        partToAttach.OnPartConnected(remoteMountID, this.ParentPartInstance, this.mountPointDefinitionID);

        // Update vehicle hierarchy
        partToAttach.SetOwningVehicle(ParentPartInstance?.OwningVehicle); // Propagate VehicleRoot
        ParentPartInstance?.OwningVehicle?.RegisterPart(partToAttach, partToAttach.ItemInstanceData); // Register with vehicle

        // Debug.Log($"Attached {partToAttach.name} to {ParentPartInstance?.name ?? "Root?"} at {mountPointDefinitionID}");
        return true;
    }

    /// <summary>
    /// Detaches the currently attached part, if any.
    /// Unparents the transform, notifies parts, and unregisters from the vehicle.
    /// </summary>
    /// <returns>The detached PartInstance, or null if nothing was attached.</returns>
    public PartInstance Detach() {
        if (CurrentlyAttachedPart == null) return null;

        PartInstance detachedPart = CurrentlyAttachedPart;
        CurrentlyAttachedPart = null; // Clear reference first

        // Notify parts about disconnection (simplistic remote ID handling)
        string remoteMountID = "unknown_connection";
        ParentPartInstance?.OnPartDisconnected(this.mountPointDefinitionID, detachedPart);
        detachedPart.OnPartDisconnected(remoteMountID, this.ParentPartInstance);

        // Unregister from vehicle and clear owning vehicle reference
        ParentPartInstance?.OwningVehicle?.UnregisterPart(detachedPart);
        detachedPart.SetOwningVehicle(null);

        // Unparent and let physics take over (OnDropped will be called by interaction logic)
        detachedPart.transform.SetParent(null, true); // Keep world position

        // Debug.Log($"Detached {detachedPart.name} from {ParentPartInstance?.name ?? "Root?"} at {mountPointDefinitionID}");
        return detachedPart;
    }

    // --- Gizmo Visualization ---
    void OnDrawGizmosSelected() {
        MountPointDefinition currentDef = this.Definition; // Use property to ensure it's resolved
        if (currentDef != null) {
            Gizmos.color = currentDef.gizmoColor;
            Gizmos.matrix = transform.localToWorldMatrix;
            Gizmos.DrawWireSphere(Vector3.zero, currentDef.gizmoRadius);
            Gizmos.DrawRay(Vector3.zero, Vector3.forward * currentDef.gizmoRadius * 2f); // Show orientation Z+
            Gizmos.color = Color.red; // X axis
            Gizmos.DrawRay(Vector3.zero, Vector3.right * currentDef.gizmoRadius * 1.5f);
             Gizmos.color = Color.green; // Y axis
            Gizmos.DrawRay(Vector3.zero, Vector3.up * currentDef.gizmoRadius * 1.5f);
        } else {
            // Draw small red sphere if definition is missing/invalid
            Gizmos.color = Color.red;
            Gizmos.matrix = transform.localToWorldMatrix;
            Gizmos.DrawWireSphere(Vector3.zero, 0.03f);
        }
    }
}
// --- End of script: Assets/Logic/Vehicles/Core/MountPoint.cs ---

// --- Start of script: Assets/Logic/Vehicles/Core/PartInstance.cs ---
using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Abstract base for simulated vehicle parts. Inherits ItemInstance for base data/grabbing,
/// adds vehicle context (OwningVehicle), connection logic, and simulation tick hooks.
/// </summary>
public abstract class PartInstance : ItemInstance { // Inherit ItemInstance

    public VehicleRoot OwningVehicle { get; private set; }

    protected Dictionary<string, PartInstance> _connectedParts = new Dictionary<string, PartInstance>();
    protected List<MountPoint> _selfMountPoints = new List<MountPoint>();

    // Awake inherited from ItemInstance is usually sufficient

    /// <summary>
    /// PartInstance specific initialization AFTER base ItemInstance setup.
    /// Sets OwningVehicle, validates part-specific data, sets up mounts/physics.
    /// </summary>
    public virtual void Initialize(InventoryItem itemInstance, VehicleRoot vehicleRoot) {
        // Call base Initialize FIRST (assigns ItemInstanceData, basic validation, physics)
        base.Initialize(itemInstance);
        if (!this.enabled) return; // Check if base failed

        // Set PartInstance specific fields
        this.OwningVehicle = vehicleRoot;

        // Part-specific validation (ensure it's CarPartData and has IPartRuntimeState)
        if (!(GetItemData<ItemData>() is CarPartData)) { Debug.LogError($"[{gameObject.name}] PartInstance Error: ItemData not CarPartData!", this); enabled = false; return; }
        if (!(GetRuntimeState<IRuntimeState>() is IPartRuntimeState)) { Debug.LogError($"[{gameObject.name}] PartInstance Error: Runtime state not IPartRuntimeState!", this); enabled = false; return; }

        SetupMountsAndPhysics(); // Setup mounts

        // Call hook for derived class specific transient setup
        InitializeTransientState();
    }

    /// <summary> VIRTUAL HOOK for derived setup after Initialize </summary>
    protected virtual void InitializeTransientState() { }

    // UpdateInventoryItemRuntimeState inherited - override if derived part caches state

    protected void SetupMountsAndPhysics() { _selfMountPoints.Clear(); GetComponentsInChildren<MountPoint>(true, _selfMountPoints); foreach (var mp in _selfMountPoints) mp?.Initialize(this); UpdatePhysicsState(); }
    protected new void UpdatePhysicsState() { // Use 'new' as signature matches protected ItemInstance method
        if (_rigidbody != null) { bool k = (OwningVehicle != null) || _originalRigidbodyKinematicState; bool g = (OwningVehicle == null) && _originalRigidbodyGravityState; if (_rigidbody.isKinematic != k) _rigidbody.isKinematic = k; if (_rigidbody.useGravity != g) _rigidbody.useGravity = g; }
    }
    public virtual void OnPartConnected(string l, PartInstance c, string r) { if (!string.IsNullOrEmpty(l)) _connectedParts[l] = c; }
    public virtual void OnPartDisconnected(string l, PartInstance d) { if (!string.IsNullOrEmpty(l)) _connectedParts.Remove(l); }
    public virtual void SetOwningVehicle(VehicleRoot v) { this.OwningVehicle = v; UpdatePhysicsState(); foreach (var kvp in _connectedParts) kvp.Value?.SetOwningVehicle(v); }

    // --- Simulation Hooks (Specific to PartInstance) ---
    public virtual void PrePhysicsSimulateTick(float dt) { }
    public virtual void PostPhysicsSimulateTick(float dt) { }
    // --- End Simulation Hooks ---

    protected T GetConnectedPartViaInterface<T>(string id) where T : class { if (string.IsNullOrEmpty(id)) return null; if (_connectedParts.TryGetValue(id, out var p)) return p as T; return null; }
    protected PartInstance GetConnectedPart(string id) { if (string.IsNullOrEmpty(id)) return null; if (_connectedParts.TryGetValue(id, out var p)) return p; return null; }

    // --- Override IGrabbable ---
    public override bool CanGrab() { return this.OwningVehicle == null; } // Only grab unattached parts
    public override void OnGrabbed(Transform grabberTransform) { base.OnGrabbed(grabberTransform); /* Part specific layer logic? */ }
    public override void OnDropped(Vector3 dropVelocity) { base.OnDropped(dropVelocity); /* Part specific layer logic? */ }
}
// --- End of script: Assets/Logic/Vehicles/Core/PartInstance.cs ---

// --- Start of script: Assets/Logic/Vehicles/Core/VehicleRoot.cs ---
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

[RequireComponent(typeof(Rigidbody))]
public class VehicleRoot : MonoBehaviour {
    [Tooltip("The ScriptableObject defining the chassis of this vehicle.")]
    public CarPartData chassisDataDefinition; // Assign your Chassis CarPartData SO here

    private PartInstance _chassisInstance;
    private List<PartInstance> _allVehicleParts = new List<PartInstance>();
    public IReadOnlyList<PartInstance> AllVehicleParts => _allVehicleParts.AsReadOnly();
    public Rigidbody Rigidbody { get; private set; }

    public float ThrottleIntent { get; private set; }
    public float BrakeIntent { get; private set; }
    public float SteeringIntent { get; private set; }
    public int DesiredGear { get; private set; }
    public bool IgnitionEngaged { get; private set; }

    public EngineInstance PrimaryEngine { get; private set; }
    public GearboxInstance PrimaryGearbox { get; private set; }

    void Awake() {
        Rigidbody = GetComponent<Rigidbody>();
        if (Rigidbody == null) {
            Debug.LogError("VehicleRoot on " + gameObject.name + " requires a Rigidbody component!", this);
            enabled = false; return;
        }

        if (chassisDataDefinition != null && chassisDataDefinition.worldPrefab != null) {
            GameObject chassisObject = Instantiate(chassisDataDefinition.worldPrefab, transform.position, transform.rotation, transform);
            chassisObject.name = $"{chassisDataDefinition.itemName}_Instance_RootChassis";
            _chassisInstance = chassisObject.GetComponent<PartInstance>();

            if (_chassisInstance != null) {
                // Create the InventoryItem for the chassis.
                // Chassis typically doesn't have complex runtime state beyond durability/wear from its PartInstance.
                IPartRuntimeState chassisRuntimeState = chassisDataDefinition.CreateDefaultRuntimeState();
                InventoryItem chassisInvItem = new InventoryItem(chassisDataDefinition, chassisRuntimeState);
                // RegisterPart now takes InventoryItem
                RegisterPart(_chassisInstance, chassisInvItem);
            } else {
                Debug.LogError("Chassis prefab '" + chassisDataDefinition.worldPrefab.name + "' is missing a PartInstance derived component!", this);
            }
        } else {
            Debug.LogError("ChassisDataDefinition or its worldPrefab not assigned to VehicleRoot on " + gameObject.name, this);
        }
    }

    void Start() {
        DiscoverPrimaryComponents();
    }

    public void UpdateDriverIntentions(float throttle, float brake, float steer, int gear, bool ignition) {
        this.ThrottleIntent = Mathf.Clamp01(throttle);
        this.BrakeIntent = Mathf.Clamp01(brake);
        this.SteeringIntent = Mathf.Clamp(steer, -1f, 1f);
        this.DesiredGear = gear;
        this.IgnitionEngaged = ignition;
    }

    /// <summary>
    /// Registers a PartInstance with this vehicle.
    /// The PartInstance should already have its GameObject instantiated.
    /// </summary>
    /// <param name="partInstance">The PartInstance component on the part's GameObject.</param>
    /// <param name="itemInstanceData">The InventoryItem containing the CarPartData and IPartRuntimeState for this part.</param>
    public void RegisterPart(PartInstance partInstance, InventoryItem itemInstanceData) {
        if (partInstance == null) { Debug.LogWarning("Attempted to register a null partInstance.", this); return; }
        if (itemInstanceData == null || itemInstanceData.data == null || itemInstanceData.runtime == null) {
            Debug.LogError($"Attempted to register part '{partInstance.name}' with invalid InventoryItem data.", this);
            return;
        }
        if (!_allVehicleParts.Contains(partInstance)) {
            _allVehicleParts.Add(partInstance);
            partInstance.Initialize(itemInstanceData, this); // Initialize with its data and this VehicleRoot
            // If a new part is added at runtime, primary components might need rediscovery
            if (Application.isPlaying && Time.timeSinceLevelLoad > 0.1f) DiscoverPrimaryComponents();
        }
    }

    public void UnregisterPart(PartInstance partInstance) {
        if (partInstance == null) return;
        if (_allVehicleParts.Remove(partInstance)) {
            partInstance.SetOwningVehicle(null); // Notify part it's no longer attached
            if (Application.isPlaying) DiscoverPrimaryComponents();
        }
    }

    private void DiscoverPrimaryComponents() {
        PrimaryEngine = _allVehicleParts.OfType<EngineInstance>().FirstOrDefault();
        PrimaryGearbox = _allVehicleParts.OfType<GearboxInstance>().FirstOrDefault();
    }

    void FixedUpdate() {
        if (_allVehicleParts.Count == 0 && _chassisInstance == null) return;

        foreach (PartInstance part in _allVehicleParts) {
            if (part != null && part.gameObject.activeInHierarchy) // Ensure part still exists
                part.PrePhysicsSimulateTick(Time.fixedDeltaTime);
        }
        // UNITY PHYSICS SIMULATION
        foreach (PartInstance part in _allVehicleParts) {
            if (part != null && part.gameObject.activeInHierarchy)
                part.PostPhysicsSimulateTick(Time.fixedDeltaTime);
        }
    }
}
// --- End of script: Assets/Logic/Vehicles/Core/VehicleRoot.cs ---

// --- Start of script: Assets/Logic/Items/Behaviours/Bow/BowAudioHandler.cs ---
using UnityEngine;

[RequireComponent(typeof(AudioSource))]
public class BowAudioHandler : MonoBehaviour
{
    [Header("Audio Clips")]
    [SerializeField] private AudioClip drawStartClip;
    [SerializeField] private AudioClip drawLoopClip;
    [SerializeField] private AudioClip releaseStringClip; // "Twang"
    [SerializeField] private AudioClip shootClip;         // "Airburst" / Whoosh
    [SerializeField] private AudioClip dryFireClip;       // NEW: Clip for when no arrows
    [SerializeField] private AudioClip cancelDrawClip;    // Optional: Clip for cancelling draw

    [Header("Volumes")]
    [SerializeField] [Range(0f, 1f)] private float drawStartVolume = 1f;
    [SerializeField] [Range(0f, 1f)] private float loopVolume = 0.8f;
    [SerializeField] [Range(0f, 1f)] private float releaseVolume = 1f;
    [SerializeField] [Range(0f, 1f)] private float shootVolume = 1f;
    [SerializeField] [Range(0f, 1f)] private float dryFireVolume = 0.9f; // NEW
    [SerializeField] [Range(0f, 1f)] private float cancelVolume = 0.7f;  // Optional

    private AudioSource audioSource;
    private bool isLooping = false;

    private void Awake()
    {
        audioSource = GetComponent<AudioSource>();
        audioSource.playOnAwake = false;
        audioSource.loop = false; // Ensure loop is off by default
    }

    public void PlayDrawStart()
    {
        StopLoop(); // Stop any existing loop
        PlayClip(drawStartClip, drawStartVolume, false);
    }

    public void StartLoop()
    {
        // Start loop only if clip exists and not already looping
        if (drawLoopClip != null && !isLooping)
        {
            PlayClip(drawLoopClip, loopVolume, true); // Set loop to true
            isLooping = true;
        }
    }

    public void StopLoop()
    {
        if (isLooping)
        {
            // Only stop if the looping clip is currently assigned and playing
            if (audioSource.clip == drawLoopClip && audioSource.isPlaying)
            {
                audioSource.Stop();
            }
            isLooping = false;
            audioSource.loop = false; // Turn loop off
        }
    }

    public void PlayRelease()
    {
        StopLoop(); // Make sure loop stops on release

        // Play the string release sound using PlayOneShot for overlap potential
        if (releaseStringClip != null)
            audioSource.PlayOneShot(releaseStringClip, releaseVolume);

        // Play the arrow whoosh sound using PlayOneShot
        if (shootClip != null)
            audioSource.PlayOneShot(shootClip, shootVolume);
    }

    // --- NEW METHOD ---
    public void PlayDryFire()
    {
        StopLoop(); // Shouldn't be looping, but safety check
        // Play the dry fire sound using PlayOneShot
        if (dryFireClip != null)
            audioSource.PlayOneShot(dryFireClip, dryFireVolume);
    }

    // --- Optional Cancel Sound ---
    public void PlayCancel()
    {
         StopLoop(); // Ensure loop stops if cancelling
         if(cancelDrawClip != null)
            audioSource.PlayOneShot(cancelDrawClip, cancelVolume);
    }


    // Helper method to reduce repetition
    private void PlayClip(AudioClip clip, float volume, bool loop)
    {
        if (clip == null) return;

        audioSource.clip = clip;
        audioSource.volume = volume;
        audioSource.loop = loop;
        audioSource.Play();
    }
}
// --- End of script: Assets/Logic/Items/Behaviours/Bow/BowAudioHandler.cs ---

// --- Start of script: Assets/Logic/Items/Behaviours/Bow/BowBehaviour.cs ---
// In Assets/Scripts/Items/Behaviours/Bow/BowBehavior.cs (or your path)
using UnityEngine;
using System.Collections;

public class BowBehavior : EquippableBehavior {
    [Header("Component References")]
    [SerializeField] private Transform arrowSpawnPoint;
    [SerializeField] private BowDrawEffect drawEffect;
    [SerializeField] private BowAudioHandler audioHandler;
    [SerializeField] private BowArrowVisualEffect arrowVisualEffect;

    [Header("Bow Settings")]
    [SerializeField] private float maxPullTime = 1.5f;
    [SerializeField] private float minShootThreshold = 0.85f;
    [SerializeField] private float baseShootForce = 40f;
    [SerializeField] private float shotCooldown = 0.5f;
    [SerializeField] private float drawTimeToSlow = 0.1f;

    [Header("Ammo Settings")]
    [Tooltip("Assign the specific Arrow ItemData SO required by this bow.")]
    [SerializeField] private ItemData requiredArrowData;

    // Runtime State
    private bool isDrawing, isCooldown, isHoldingAim;
    private float drawStartTime, currentPowerPercent;

    // Required Player Components
    private MyCharacterController characterController; // Still needed for slow walk

    // CORRECTED Initialize signature
    public override void Initialize(InventoryItem itemInstance, IEquipmentHolder holder, IAimProvider aimProvider) {
        // Call base.Initialize FIRST to set runtimeItem, ownerEquipmentHolder, ownerAimProvider
        base.Initialize(itemInstance, holder, aimProvider);

        // --- Validate contexts critical for BowBehavior specifically ---
        if (this.runtimeItem == null || this.runtimeItem.data == null) {
            Debug.LogError($"[BowBehavior on {gameObject.name}] Initialize ERROR: Null ItemInstance or ItemData from base class! Cannot function.", this);
            this.enabled = false;
            return;
        }

        // --- Find Character Controller (using PlayerManager or fallback if holder is PlayerManager) ---
        // ownerEquipmentHolder is already set by base.Initialize
        if (this.ownerEquipmentHolder is PlayerManager playerManagerHolder) { // If the holder itself is PlayerManager
            characterController = playerManagerHolder.CharacterController;
        } else if (this.ownerEquipmentHolder is PlayerInventory playerInventoryHolder) { // Common case
            PlayerManager pm = playerInventoryHolder.GetComponentInParent<PlayerManager>();
            if (pm != null) characterController = pm.CharacterController;
        }
        
        if (characterController == null) { // Fallback if not found via holder's hierarchy
            characterController = GetComponentInParent<PlayerManager>()?.CharacterController ?? GetComponentInParent<MyCharacterController>();
        }

        if (characterController == null) {
             Debug.LogWarning($"[BowBehavior on {gameObject.name}] CharacterController not found - slow walk effect disabled. Holder: {this.ownerEquipmentHolder?.GetType().Name}", this);
        }
        // --- End Find Character Controller ---

        drawEffect ??= GetComponent<BowDrawEffect>();
        audioHandler ??= GetComponent<BowAudioHandler>();
        arrowVisualEffect ??= GetComponentInChildren<BowArrowVisualEffect>(true);

        if (arrowSpawnPoint == null) Debug.LogError($"[BowBehavior on {gameObject.name}] Arrow Spawn Point missing!", this);
        if (requiredArrowData == null) Debug.LogError($"[BowBehavior on {gameObject.name}] Required Arrow Data missing!", this);

        ResetState();
        arrowVisualEffect?.SetArrowVisibility(false);
    }

    // ... (Rest of BowBehavior: Update, Input Handlers, Core Logic, Cooldown, Helpers, OnDisable - All remain the same) ...
    // Ensure methods like Shoot use `this.ownerEquipmentHolder` and `this.ownerAimProvider`.
    private void Update() { if (!isDrawing) return; float drawDur = Time.time - drawStartTime; currentPowerPercent = Mathf.Clamp01(drawDur / maxPullTime); drawEffect?.UpdateDraw(currentPowerPercent); arrowVisualEffect?.UpdateDraw(currentPowerPercent); if (currentPowerPercent >= 1.0f) audioHandler?.StartLoop(); }
    public override void OnFire2Down() { isHoldingAim = true; if (!isDrawing && !isCooldown) TryStartDrawing(); }
    public override void OnFire2Up() { isHoldingAim = false; if (isDrawing) CancelDrawing(); }
    public override void OnFire1Down() { if (isDrawing && currentPowerPercent >= minShootThreshold) Shoot(currentPowerPercent); }
    private void TryStartDrawing() { if (requiredArrowData == null || ownerEquipmentHolder == null) return; if (!ownerEquipmentHolder.HasItemInInventory(requiredArrowData)) { audioHandler?.PlayDryFire(); return; } StartDrawing(); }
    private void StartDrawing() { isDrawing = true; drawStartTime = Time.time; currentPowerPercent = 0f; CancelInvoke(nameof(ApplySlowWalk)); Invoke(nameof(ApplySlowWalk), drawTimeToSlow); audioHandler?.PlayDrawStart(); arrowVisualEffect?.SetArrowVisibility(true); }
    private void CancelDrawing() { if (!isDrawing) return; CancelInvoke(nameof(ApplySlowWalk)); characterController?.ForceSlowWalk(false); ResetState(); drawEffect?.StopDraw(); audioHandler?.StopLoop(); audioHandler?.PlayCancel(); arrowVisualEffect?.SetArrowVisibility(false); arrowVisualEffect?.UpdateDraw(0f); }
    private void Shoot(float powerPercent) {
        if (ownerEquipmentHolder == null || ownerAimProvider == null || arrowSpawnPoint == null || requiredArrowData == null) {
            Debug.LogError($"[Bow on {gameObject.name}] Cannot shoot: Missing required contexts or data. Holder: {ownerEquipmentHolder != null}, Aimer: {ownerAimProvider != null}", this);
            StartCooldown(); ResetState(); return;
        }
        if (!ownerEquipmentHolder.RequestConsumeItem(requiredArrowData, 1)) {
            Debug.LogWarning($"[Bow on {gameObject.name}] Failed to consume arrow before shooting.", this);
            CancelDrawing(); return;
        }
        CancelInvoke(nameof(ApplySlowWalk));
        characterController?.ForceSlowWalk(false);
        ResetState();
        drawEffect?.StopDraw();
        audioHandler?.PlayRelease();
        audioHandler?.StopLoop();
        arrowVisualEffect?.SetArrowVisibility(false);
        arrowVisualEffect?.UpdateDraw(0f);
        GameObject projectilePrefabToSpawn = null;
        var arrowDataSpecific = requiredArrowData as ArrowItemData;
        if (arrowDataSpecific != null && arrowDataSpecific.projectilePrefab != null) {
            projectilePrefabToSpawn = arrowDataSpecific.projectilePrefab;
        }
        else if (requiredArrowData.worldPrefab != null && requiredArrowData.worldPrefab.GetComponentInChildren<ProjectileBehavior>() != null) {
             projectilePrefabToSpawn = requiredArrowData.worldPrefab;
        }
        if (projectilePrefabToSpawn == null) {
            Debug.LogError($"[Bow on {gameObject.name}] Arrow Data '{requiredArrowData.itemName}' missing a suitable projectile prefab!", this);
            StartCooldown(); return;
        }
        Ray lookRay = ownerAimProvider.GetLookRay();
        Vector3 target = ownerAimProvider.GetAimHitPoint();
        Vector3 dir = (target - arrowSpawnPoint.position).normalized;
        if ((target - arrowSpawnPoint.position).sqrMagnitude < 0.1f || Vector3.Dot(dir, lookRay.direction) < 0.1f) dir = lookRay.direction;
        float force = baseShootForce * powerPercent;
        GameObject projGO = Instantiate(projectilePrefabToSpawn, arrowSpawnPoint.position, Quaternion.LookRotation(dir));
        ProjectileBehavior projBehavior = projGO.GetComponent<ProjectileBehavior>();
        if (projBehavior != null) {
            projBehavior.Launch(dir, force);
        } else {
             Debug.LogError($"[Bow on {gameObject.name}] Instantiated projectile '{projectilePrefabToSpawn.name}' is missing ProjectileBehavior script!", projGO);
        }
        StartCooldown();
    }
    private void StartCooldown() { isCooldown = true; CancelInvoke(nameof(EndCooldown)); Invoke(nameof(EndCooldown), shotCooldown); }
    private void EndCooldown() { isCooldown = false; if (isHoldingAim) TryStartDrawing(); }
    private void ApplySlowWalk() { if (isDrawing && characterController != null) characterController.ForceSlowWalk(true); }
    private void ResetState() { isDrawing = false; drawStartTime = 0f; currentPowerPercent = 0f; }
    protected override void OnDisable() { base.OnDisable(); CancelInvoke(); if (characterController != null) characterController.ForceSlowWalk(false); ResetState(); isHoldingAim = false; isCooldown = false; drawEffect?.StopDraw(); audioHandler?.StopLoop(); arrowVisualEffect?.SetArrowVisibility(false); arrowVisualEffect?.UpdateDraw(0f); }
    public override void OnFire1Hold() { } public override void OnFire1Up() { } public override void OnFire2Hold() { } public override void OnUtilityDown() { } public override void OnUtilityUp() { } public override void OnReloadDown() { }
}
// --- End of script: Assets/Logic/Items/Behaviours/Bow/BowBehaviour.cs ---

// --- Start of script: Assets/Logic/Items/Behaviours/Bow/BowDrawEffect.cs ---
using UnityEngine;

public class BowDrawEffect : MonoBehaviour
{
    [Header("Target to Affect")]
    [Tooltip("The transform that will be moved by draw effects (usually the bow model root). If null, this GameObject will be affected.")]
    [SerializeField] private Transform target;

    [Header("Draw Positions")]
    [SerializeField] private Vector3 restLocalPosition = new Vector3(0f, 0f, 0f);
    [SerializeField] private Vector3 drawnLocalPosition = new Vector3(0.05f, 0.05f, -0.2f);

    [Header("Draw Rotations")]
    [SerializeField] private Vector3 restLocalEulerAngles = new Vector3(0f, 0f, 0f);
    [SerializeField] private Vector3 drawnLocalEulerAngles = new Vector3(-5f, 3f, 0f); // just an example

    [Header("Shake Settings")]
    [SerializeField] private float shakeIntensity = 0.005f;
    [SerializeField] private float shakeSpeed = 30f;

    [Header("Return Settings")]
    [SerializeField] private float returnSpeed = 5f;

    private float targetPullAmount = 0f;
    private float currentPullAmount = 0f;
    private bool isPulling = false;

    private void Awake()
    {
        if (target == null)
            target = transform;

        target.localPosition = restLocalPosition;
        target.localRotation = Quaternion.Euler(restLocalEulerAngles);
    }

    /// <summary>Call this every frame while pulling to update effect (value should be 0–1).</summary>
    public void UpdateDraw(float normalizedPull)
    {
        isPulling = true;
        targetPullAmount = Mathf.Clamp01(normalizedPull);
    }

    /// <summary>Call when pulling stops (either fire or cancel).</summary>
    public void StopDraw()
    {
        isPulling = false;
    }

    private void Update()
    {
        if (isPulling)
        {
            currentPullAmount = Mathf.Lerp(currentPullAmount, targetPullAmount, Time.deltaTime * 12f);
        }
        else
        {
            currentPullAmount = Mathf.MoveTowards(currentPullAmount, 0f, Time.deltaTime * returnSpeed);
        }

        // Interpolate position
        Vector3 basePosition = Vector3.Lerp(restLocalPosition, drawnLocalPosition, currentPullAmount);

        if (isPulling && currentPullAmount > 0.1f)
        {
            float shakePower = shakeIntensity * currentPullAmount;
            basePosition += new Vector3(
                (Mathf.PerlinNoise(Time.time * shakeSpeed, 0f) - 0.5f),
                (Mathf.PerlinNoise(0f, Time.time * shakeSpeed) - 0.5f),
                0f
            ) * shakePower;
        }

        // Interpolate rotation
        Quaternion baseRotation = Quaternion.Lerp(
            Quaternion.Euler(restLocalEulerAngles),
            Quaternion.Euler(drawnLocalEulerAngles),
            currentPullAmount
        );

        target.localPosition = basePosition;
        target.localRotation = baseRotation;
    }
}
// --- End of script: Assets/Logic/Items/Behaviours/Bow/BowDrawEffect.cs ---

// --- Start of script: Assets/Logic/Items/Behaviours/Bow/BowVisualController.cs ---
using UnityEngine;

public class BowArrowVisualEffect : MonoBehaviour
{
    [Header("Arrow Visual")]
    [SerializeField] private GameObject visualArrow;
    
    [Header("Arrow Transform")]
    [SerializeField] private Transform arrowTransform;
    [SerializeField] private Transform stringTransform;

    [Tooltip("How far back the arrow moves on full draw (in local units).")]
    [SerializeField] private float drawDistance = 0.2f;

    private Vector3 initialLocalPosition;
    private Vector3 initialLocalPosition2;
    private Vector3 initialLocalPosition3;
    private bool isArrowVisible = false;

    private void Awake()
    {
        if (arrowTransform != null)
            initialLocalPosition = arrowTransform.localPosition;

        if (stringTransform != null)
            initialLocalPosition2 = stringTransform.localPosition;
    }

    public void SetArrowVisibility(bool visible)
    {
        isArrowVisible = visible;
        if (visualArrow != null)
            visualArrow.SetActive(visible);
    }

    public void UpdateDraw(float normalizedPull)
    {
        if (arrowTransform == null) return;

        float offset = drawDistance * normalizedPull;
        arrowTransform.localPosition = initialLocalPosition - Vector3.forward * offset;

        stringTransform.localPosition = initialLocalPosition2 - Vector3.forward * offset;
    }
}
// --- End of script: Assets/Logic/Items/Behaviours/Bow/BowVisualController.cs ---

// --- Start of script: Assets/Logic/Items/Behaviours/Firearms/ADSController.cs ---
// In Assets/Scripts/Player/Equipment/ADSController.cs (or your path)
using UnityEngine;

/// <summary>
/// Manages the Aim Down Sights (ADS) transition for an equippable item's viewmodel.
/// Lerps the position and rotation of the 'adsPivot' transform to align a specific
/// 'weaponAimPoint' (e.g., the sight) with a calculated camera anchor point.
/// Relies on an IAimProvider for camera information.
/// </summary>
public class ADSController : MonoBehaviour {
    #region Inspector Fields
    [Header("Core References")]
    [Tooltip("The root Transform of the viewmodel (e.g., holding Pistol visuals) that gets moved/rotated for ADS.")]
    [SerializeField] private Transform adsPivot;
    // Note: weaponAimPoint is set dynamically via SetWeaponAimPoint

    [Header("ADS Configuration")]
    [Tooltip("How quickly the viewmodel transitions between hip and ADS poses.")]
    [SerializeField] private float adsSpeed = 15f; // Increased default speed slightly
    // Note: The proximity threshold for alignment isn't explicitly used in the current lerp logic,
    // but could be added for snapping or different interpolation methods.
    #endregion

    #region Private Fields
    // Dynamic reference to the specific point on the weapon model that should align with the camera anchor
    private Transform weaponAimPoint;

    // Pose captured when not aiming
    private Vector3 _hipFireLocalPosition = Vector3.zero;
    private Quaternion _hipFireLocalRotation = Quaternion.identity;

    // Runtime state
    private bool _isAiming = false; // Internal flag controlled by Start/StopAiming
    private bool _isInitialized = false; // Tracks if essential references are set

    // Dependencies
    private IAimProvider _aimProvider; // Provides camera transform and look direction
    private Vector3 _cameraAnchorOffset = Vector3.zero; // Offset from camera where the weaponAimPoint should align
    #endregion

    #region Public Properties
    /// <summary>
    /// Gets whether the controller is currently in the Aiming Down Sights state.
    /// </summary>
    public bool IsAiming => _isAiming;
    #endregion

    #region Unity Lifecycle
    void Awake() {
        _isAiming = false; // Ensure starting state
        _isInitialized = false;

        // Find required IAimProvider dependency
        _aimProvider = GetComponentInParent<IAimProvider>(); // Search hierarchy
        if (_aimProvider == null) Debug.LogError($"[{GetType().Name} on {gameObject.name}] IAimProvider component not found in parents!", this);

        // Validate essential Inspector reference
        if (adsPivot == null) Debug.LogError($"[{GetType().Name} on {gameObject.name}] ADS Pivot transform not assigned!", this);
        else {
            // Capture initial hip pose in Awake *after* validating adsPivot exists
            CaptureHipPose();
        }

        // Initial check, requires weaponAimPoint to be set later via SetWeaponAimPoint
        CheckInitialization();
    }

    void OnEnable() {
        // It's generally safer to capture/reset pose OnEnable in case the object was
        // disabled and re-enabled, potentially with transform changes.
        if (adsPivot != null) {
             CaptureHipPose(); // Recapture in case something moved it while disabled
             // Reset visual state immediately
             adsPivot.localPosition = _hipFireLocalPosition;
             adsPivot.localRotation = _hipFireLocalRotation;
        }
        _isAiming = false; // Ensure ADS is off when enabled
        CheckInitialization(); // Re-check if weaponAimPoint was set while disabled
    }

    void OnDisable() {
        // Reset state when disabled
        _isAiming = false;
        _isInitialized = false; // Mark as uninitialized as dependencies might change/become invalid
    }

    void Update() {
        // Only update if initialized (requires adsPivot, aimProvider, and weaponAimPoint)
        if (!_isInitialized || adsPivot == null || weaponAimPoint == null || _aimProvider == null) {
            // If aiming was requested but we aren't initialized, try to return to hip pose visually
            if (_isAiming && adsPivot != null) {
                 LerpToHipPose();
            }
            return; // Do nothing further if not ready
        }

        // Perform transitions based on the aiming state
        if (_isAiming) {
            AlignToAnchor();
        } else {
            LerpToHipPose();
        }

        // Optional: Debug draw line for the anchor point
        // Transform currentCameraTransform = _aimProvider.GetLookTransform();
        // if (currentCameraTransform != null) {
        //     Vector3 dynamicAnchorPosition = currentCameraTransform.position + (currentCameraTransform.rotation * _cameraAnchorOffset);
        //     Debug.DrawLine(dynamicAnchorPosition, dynamicAnchorPosition + currentCameraTransform.forward * 0.1f, Color.red); // Short line from anchor
        // }
    }
    #endregion

    #region ADS Alignment Logic
    /// <summary>
    /// Smoothly moves the adsPivot to align the weaponAimPoint with the calculated camera anchor.
    /// </summary>
    private void AlignToAnchor() {
        Transform cam = _aimProvider.GetLookTransform();
        Transform holder = adsPivot; // Use local variable for clarity

        // Need all references to proceed
        if (cam == null || holder == null || weaponAimPoint == null) {
             if (Time.frameCount % 120 == 0) // Log warning occasionally
                Debug.LogWarning("[ADSController] Cannot AlignToAnchor: Missing Camera, Holder, or WeaponAimPoint.", this);
            LerpToHipPose(); // Attempt to return to safety (hip)
            return;
        }

        // 1. Calculate World-Space Anchor Point (camera position + offset relative to camera rotation)
        Vector3 anchorPos = cam.position + (cam.rotation * _cameraAnchorOffset);

        // 2. Calculate Ideal World Position for the Pivot
        // Find the weapon aim point's position relative to the pivot (in pivot's local space)
        Vector3 localOffsetFromPivotToAimPoint = holder.InverseTransformPoint(weaponAimPoint.position);
        // Determine where the pivot *should* be in world space so that its local offset matches the anchor
        Vector3 idealWorldPosForPivot = anchorPos - holder.TransformDirection(localOffsetFromPivotToAimPoint); // Use TransformDirection for offset vector

        // 3. Convert Ideal World Position to Pivot's Parent's Local Space
        Vector3 idealLocalPosForPivot = holder.parent != null
            ? holder.parent.InverseTransformPoint(idealWorldPosForPivot)
            : idealWorldPosForPivot; // Use world space if no parent

        // 4. Lerp Pivot Position
        holder.localPosition = Vector3.Lerp(holder.localPosition, idealLocalPosForPivot, Time.deltaTime * adsSpeed);

        // 5. Lerp Pivot Rotation
        // Option A: Lerp towards camera's rotation (simple alignment)
        // Quaternion targetRotation = Quaternion.LookRotation(cam.forward, cam.up); // Basic forward align
        // if (holder.parent != null) targetRotation = Quaternion.Inverse(holder.parent.rotation) * targetRotation; // Convert to local if parented
        // holder.localRotation = Quaternion.Slerp(holder.localRotation, targetRotation, Time.deltaTime * adsSpeed);

        // Option B: Lerp towards a predefined ADS local rotation (often simpler and more stable visually)
        // You might need another field like 'Quaternion adsLocalRotation' set based on weapon type.
        // For now, let's lerp back towards the initial hip rotation for simplicity.
        // Replace _hipFireLocalRotation with 'adsTargetLocalRotation' if you define one.
        holder.localRotation = Quaternion.Slerp(holder.localRotation, _hipFireLocalRotation, Time.deltaTime * adsSpeed);
    }

    /// <summary>
    /// Smoothly moves the adsPivot back to its original captured hip-fire position and rotation.
    /// </summary>
    private void LerpToHipPose() {
        if (adsPivot != null) {
            adsPivot.localPosition = Vector3.Lerp(adsPivot.localPosition, _hipFireLocalPosition, Time.deltaTime * adsSpeed);
            adsPivot.localRotation = Quaternion.Slerp(adsPivot.localRotation, _hipFireLocalRotation, Time.deltaTime * adsSpeed);
        }
    }

    /// <summary>
    /// Captures the current local position and rotation of the adsPivot to use as the hip-fire target pose.
    /// Call this when the weapon is first equipped or when attachments might change the hip pose.
    /// </summary>
    public void CaptureHipPose() {
       if (adsPivot != null) {
            _hipFireLocalPosition = adsPivot.localPosition;
            _hipFireLocalRotation = adsPivot.localRotation;
        } else {
             Debug.LogWarning("[ADSController] Cannot capture hip pose - adsPivot is null.", this);
        }
    }
    #endregion

    #region State Control & Configuration
    /// <summary>Starts the ADS transition.</summary>
    public void StartAiming() { if(_isInitialized) _isAiming = true; else Debug.LogWarning("[ADSController] Cannot StartAiming - Not Initialized.", this); }

    /// <summary>Stops the ADS transition.</summary>
    public void StopAiming() { _isAiming = false; }

    /// <summary>Immediately stops aiming, regardless of current transition.</summary>
    public void ForceStopAiming() { _isAiming = false; if(adsPivot != null) { adsPivot.localPosition = _hipFireLocalPosition; adsPivot.localRotation = _hipFireLocalRotation; } } // Snap back instantly

    // IsAiming is now a public property

    /// <summary>
    /// Sets the specific Transform on the weapon model that should align with the camera anchor during ADS.
    /// Typically called by AttachmentController when sights change.
    /// </summary>
    public void SetWeaponAimPoint(Transform newAimPoint) {
        // Only update and re-check initialization if the point actually changes
        if (weaponAimPoint != newAimPoint) {
             weaponAimPoint = newAimPoint; // Can be null if no sight is attached
             CheckInitialization(); // Re-evaluate if we are ready now
             // Debug.Log($"[ADSController] Weapon Aim Point set to: {weaponAimPoint?.name ?? "NULL"}");
        }
    }

    /// <summary>
    /// Sets the offset from the camera's origin where the WeaponAimPoint should align.
    /// Allows different weapons/sights to sit differently relative to the camera.
    /// Typically called by AttachmentController.
    /// </summary>
    public void SetCameraAnchorOffset(Vector3 offset) {
        _cameraAnchorOffset = offset;
    }
    #endregion

    #region Internal Methods
    /// <summary>
    /// Checks if all required dependencies (adsPivot, _aimProvider, weaponAimPoint) are set.
    /// Updates the _isInitialized flag.
    /// </summary>
    private void CheckInitialization() {
        _isInitialized = adsPivot != null && _aimProvider != null && weaponAimPoint != null;
        // if (!_isInitialized && Time.time > 0.5f) { // Optional: Log warning if not initialized after a short time
             // Debug.LogWarning($"[ADSController] Not Initialized. Pivot: {adsPivot != null}, AimProvider: {_aimProvider != null}, WeaponAimPoint: {weaponAimPoint != null}");
        // }
    }
    #endregion
}
// --- End of script: Assets/Logic/Items/Behaviours/Firearms/ADSController.cs ---

// --- Start of script: Assets/Logic/Items/Behaviours/Firearms/AttachmentController.cs ---
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// Manages firearm attachments: visuals, state listening, effect aggregation,
/// calculating combined STAT MULTIPLIERS, and updating Recoil/ADS/Spread handlers.
/// Handles default visuals (e.g., iron sights) and aim points via Default Attachments.
/// </summary>
public class AttachmentController : MonoBehaviour
{
    // --- Inspector Fields ---
    [Header("Required Scene References")]
    [SerializeField] private Transform attachmentsRoot;
    [Header("Default Values")]
    [SerializeField] private Vector3 defaultCameraAnchorOffset = new Vector3(0, 0, 0.15f);

    // --- References Set by FirearmBehavior ---
    private FirearmItemData def;
    private FirearmRuntimeState state;
    private RecoilHandler recoilHandler;
    private ADSController adsController;
    private SpreadHandler spreadController;

    // --- Internal State ---
    private bool _isInitialized = false;
    private readonly Dictionary<int, GameObject> _activeAttachmentInstances = new Dictionary<int, GameObject>();
    private readonly List<AttachmentStatModifier> _activeStatModifiers = new List<AttachmentStatModifier>();
    private readonly Dictionary<string, GameObject> _defaultAttachmentInstances = new Dictionary<string, GameObject>(); // Key: mountPointTag
    private readonly Dictionary<string, Transform> _mountPoints = new Dictionary<string, Transform>();
    private Transform _currentWeaponAimPoint;
    private Vector3 _currentCameraAnchorOffset;

    // --- Initialization & Lifecycle ---
    private void Awake() { CacheMountPoints(); }
    public void Initialize(FirearmRuntimeState firearmState, FirearmItemData firearmDef, RecoilHandler recoilH, ADSController adsCtrl, SpreadHandler spreadCtrl) { this.state = firearmState; this.def = firearmDef; this.recoilHandler = recoilH; this.adsController = adsCtrl; this.spreadController = spreadCtrl; _isInitialized = false; ValidateInitializationReferences(); ClearDefaultAttachmentVisuals(); ClearRealAttachmentsVisuals(); InstantiateAllDefaultAttachments(); UnsubscribeFromAttachmentChanges(); SubscribeToAttachmentChanges(); RefreshAllAttachments(); if (adsController != null) { adsController.ForceStopAiming(); if (_currentWeaponAimPoint != null) { adsController.SetWeaponAimPoint(_currentWeaponAimPoint); adsController.SetCameraAnchorOffset(_currentCameraAnchorOffset); } else { Debug.LogError($"[{GetType().Name} on '{this.gameObject.name}'] Post-Initialize: Cannot SetWeaponAimPoint - No aim point found!", this); } } _isInitialized = true; }
    private void OnEnable() { if (_isInitialized) { SetAllDefaultAttachmentsActive(true); RefreshAllAttachments(); } }
    private void OnDisable() { UnsubscribeFromAttachmentChanges(); ClearRealAttachmentsVisuals(); ClearDefaultAttachmentVisuals(); _isInitialized = false; }

    // --- Event Handlers ---
    private void HandleAttachmentSlotChanged(int slotIndex) { if (!_isInitialized) return; if (slotIndex < 0) RefreshAllAttachments(); else RefreshAttachment(slotIndex); }

    // --- Core Attachment Management ---
    private void RefreshAllAttachments() { ClearRealAttachmentsVisuals(); SetAllDefaultAttachmentsActive(true); HashSet<string> usedMountTags = new HashSet<string>(); if (state?.attachments != null) { for (int i = 0; i < state.attachments.Slots.Length; i++) { var slot = state.attachments.Slots[i]; if (slot == null || slot.IsEmpty()) continue; AttachmentItemData attachmentData = slot.item.data as AttachmentItemData; GameObject instantiatedGO = InstantiateSingleRealAttachment(attachmentData, i); if (instantiatedGO != null && attachmentData != null && !string.IsNullOrEmpty(attachmentData.mountPointTag)) { string mountTag = attachmentData.mountPointTag; if (!string.IsNullOrEmpty(mountTag)) { usedMountTags.Add(mountTag); HideDefaultAttachment(mountTag); } } } } UpdateHandlersWithCurrentState(); }
    private void RefreshAttachment(int slotIndex) { if (state?.attachments == null || slotIndex < 0 || slotIndex >= state.attachments.Slots.Length) return; string previousMountTag = GetMountTagForSlot(slotIndex); ClearSingleRealAttachmentVisuals(slotIndex); SetDefaultAttachmentActive(previousMountTag, true); var slot = state.attachments.Slots[slotIndex]; AttachmentItemData newAttachmentData = slot?.item?.data as AttachmentItemData; GameObject newInstanceGO = null; if (newAttachmentData != null) { newInstanceGO = InstantiateSingleRealAttachment(newAttachmentData, slotIndex); } if (newInstanceGO != null && newAttachmentData != null && !string.IsNullOrEmpty(newAttachmentData.mountPointTag)) { HideDefaultAttachment(newAttachmentData.mountPointTag); } UpdateHandlersWithCurrentState(); }

    // --- Visual Instantiation & Cleanup Helpers ---
    private GameObject InstantiateSingleRealAttachment(AttachmentItemData data, int slotIndex) { if (data == null || data.attachmentPrefab == null) return null; if (_mountPoints.TryGetValue(data.mountPointTag, out var mount)) { var go = Instantiate(data.attachmentPrefab, mount.position, mount.rotation, mount); go.transform.localPosition = Vector3.zero; go.transform.localRotation = Quaternion.identity; go.name = data.attachmentPrefab.name + $" (Slot {slotIndex})"; _activeAttachmentInstances[slotIndex] = go; var statModifier = go.GetComponentInChildren<AttachmentStatModifier>(true); if (statModifier != null) { if (!_activeStatModifiers.Contains(statModifier)) { _activeStatModifiers.Add(statModifier); } } return go; } else { Debug.LogWarning($"[{GetType().Name}] Mount point tag '{data.mountPointTag}' not found for attachment '{data.itemName}' slot {slotIndex}.", this); return null; } }
    private void InstantiateSingleDefaultAttachment(string mountTag, GameObject prefab) { if (string.IsNullOrEmpty(mountTag) || prefab == null) return; if (_mountPoints.TryGetValue(mountTag, out var mount)) { if (_defaultAttachmentInstances.TryGetValue(mountTag, out var oldDefaultGO) && oldDefaultGO != null) { Destroy(oldDefaultGO); } var go = Instantiate(prefab, mount.position, mount.rotation, mount); go.transform.localPosition = Vector3.zero; go.transform.localRotation = Quaternion.identity; go.name = prefab.name + " (Default)"; _defaultAttachmentInstances[mountTag] = go; go.SetActive(true); } else { Debug.LogWarning($"[{GetType().Name}] Default Attachment: Mount point tag '{mountTag}' not found.", this); } }
    private void InstantiateAllDefaultAttachments() { if (def != null && def.defaultAttachments != null) { foreach (var mapping in def.defaultAttachments) { InstantiateSingleDefaultAttachment(mapping.mountPointTag, mapping.defaultPrefab); } } }
    private void ClearRealAttachmentsVisuals() { foreach (var kvp in _activeAttachmentInstances.ToList()) { ClearSingleRealAttachmentVisuals(kvp.Key); } _activeAttachmentInstances.Clear(); _activeStatModifiers.Clear(); }
    private void ClearSingleRealAttachmentVisuals(int slotIndex) { if (_activeAttachmentInstances.TryGetValue(slotIndex, out var instanceGO)) { if (instanceGO != null) { var statModifier = instanceGO.GetComponentInChildren<AttachmentStatModifier>(true); if (statModifier != null) _activeStatModifiers.Remove(statModifier); Destroy(instanceGO); } _activeAttachmentInstances.Remove(slotIndex); } }
    private void ClearDefaultAttachmentVisuals() { foreach (var kvp in _defaultAttachmentInstances) { if (kvp.Value != null) { Destroy(kvp.Value); } } _defaultAttachmentInstances.Clear(); }
    private void HideDefaultAttachment(string mountTag) { SetDefaultAttachmentActive(mountTag, false); }
    private void SetDefaultAttachmentActive(string mountTag, bool isActive) { if (!string.IsNullOrEmpty(mountTag) && _defaultAttachmentInstances.TryGetValue(mountTag, out var defaultInstance) && defaultInstance != null) { if(defaultInstance.activeSelf != isActive) { defaultInstance.SetActive(isActive); } } }
    private void SetAllDefaultAttachmentsActive(bool isActive) { foreach(var defaultInstance in _defaultAttachmentInstances.Values) { if (defaultInstance != null && defaultInstance.activeSelf != isActive) { defaultInstance.SetActive(isActive); } } }

    // --- Calculation & Handler Updates ---
    private void UpdateHandlersWithCurrentState() { float combinedRecoilMagnitudeMultiplier = 1.0f; float combinedRecoverySpeedMultiplier = 1.0f; float combinedBaseSpreadMultiplier = 1.0f; float combinedMaxSpreadMultiplier = 1.0f; float combinedSpreadIncreaseMultiplier = 1.0f; float combinedSpreadRecoveryMultiplier = 1.0f; foreach (var modifier in _activeStatModifiers) { if (modifier == null) continue; combinedRecoilMagnitudeMultiplier *= modifier.recoilMagnitudeMultiplier; combinedRecoverySpeedMultiplier *= modifier.recoverySpeedMultiplier; combinedBaseSpreadMultiplier *= modifier.baseSpreadMultiplier; combinedMaxSpreadMultiplier *= modifier.maxSpreadMultiplier; combinedSpreadIncreaseMultiplier *= modifier.spreadIncreaseMultiplier; combinedSpreadRecoveryMultiplier *= modifier.spreadRecoveryMultiplier; } UpdateCurrentAimPointAndOffset(); if (recoilHandler != null) { RecoilPattern baseRecoilPattern = (def?.baseRecoilPattern != null) ? def.baseRecoilPattern : new RecoilPattern(); recoilHandler.SetBaseRecoilPattern(baseRecoilPattern); recoilHandler.SetRecoilModifiers(combinedRecoilMagnitudeMultiplier, combinedRecoverySpeedMultiplier, def?.adsVisualRecoilMultiplier ?? 1.0f); } if (spreadController != null) { SpreadPattern baseSpreadPattern = (def?.baseSpreadPattern != null) ? def.baseSpreadPattern : new SpreadPattern(); spreadController.Initialize(baseSpreadPattern, def?.adsSpreadMultiplier ?? 1.0f); spreadController.SetSpreadModifiers(combinedBaseSpreadMultiplier, combinedMaxSpreadMultiplier, combinedSpreadIncreaseMultiplier, combinedSpreadRecoveryMultiplier); } if (adsController != null) { if (_currentWeaponAimPoint != null) { adsController.SetWeaponAimPoint(_currentWeaponAimPoint); adsController.SetCameraAnchorOffset(_currentCameraAnchorOffset); } else { Debug.LogError($"[{GetType().Name} on '{this.gameObject.name}'] UpdateHandlers: Cannot SetWeaponAimPoint - No aim point found!", this); } } }

    // UPDATED Aim Point Logic - Removed final fallback search
    private void UpdateCurrentAimPointAndOffset()
    {
        Transform finalAimPoint = null;
        AttachmentItemData sightItemData = null;
        bool usingRealSight = false;

        // 1. Check REAL attachments first
        if (state?.attachments != null) {
            foreach (var kvp in _activeAttachmentInstances) {
                GameObject instance = kvp.Value; int slotIdx = kvp.Key;
                if (instance == null || slotIdx >= state.attachments.Slots.Length) continue;
                var slot = state.attachments.Slots[slotIdx]; if (slot == null || slot.IsEmpty()) continue;
                var data = slot.item.data as AttachmentItemData;
                if (data?.attachmentType == AttachmentType.Sight) {
                    var aimPointComponent = instance.GetComponentInChildren<AttachmentAimPoint>(true);
                    if (aimPointComponent != null) {
                        finalAimPoint = aimPointComponent.transform; sightItemData = data; usingRealSight = true; break;
                    } else { Debug.LogWarning($"Real Sight '{data.itemName}' missing AttachmentAimPoint component!", instance); }
                }
            }
        }

        // 2. If NO real sight found, check ACTIVE DEFAULT attachment prefabs (on "SightMount")
        if (finalAimPoint == null) {
            if (_defaultAttachmentInstances.TryGetValue("SightMount", out var defaultInstance) && defaultInstance != null && defaultInstance.activeSelf) {
                 var defaultAimPointComponent = defaultInstance.GetComponentInChildren<AttachmentAimPoint>(true);
                 if (defaultAimPointComponent != null) {
                     finalAimPoint = defaultAimPointComponent.transform; // Use default aim point
                 } else { Debug.LogWarning($"Default attachment on 'SightMount' ({defaultInstance.name}) is missing AttachmentAimPoint component!", defaultInstance); }
            }
        }

        // 3. REMOVED Fallback search on base weapon hierarchy

        // --- Assign the determined Aim Point ---
        _currentWeaponAimPoint = finalAimPoint;
        // Debug.Log($"[{gameObject.name}] Updated Aim Point via '{foundMethod}': {(_currentWeaponAimPoint != null ? _currentWeaponAimPoint.name : "NULL")}");

        // --- Determine Camera Offset ---
        _currentCameraAnchorOffset = (usingRealSight && sightItemData != null && sightItemData.overrideCameraAnchorOffset)
            ? sightItemData.customCameraAnchorOffset
            : ((def != null) ? def.defaultCameraAnchorOffset : Vector3.zero);
    }

    // --- Utility Methods ---
    private void ValidateInitializationReferences() { if (recoilHandler == null) Debug.LogError($"[{GetType().Name}] Init Check Failed: RecoilHandler null!", this); if (adsController == null) Debug.LogError($"[{GetType().Name}] Init Check Failed: ADSController null!", this); if (spreadController == null) Debug.LogError($"[{GetType().Name}] Init Check Failed: SpreadController null!", this); }
    private void CacheMountPoints() { _mountPoints.Clear(); if (attachmentsRoot != null) { foreach (Transform t in attachmentsRoot) { if (t != null && !string.IsNullOrEmpty(t.gameObject.tag)) { _mountPoints[t.gameObject.tag] = t; } } if(_mountPoints.Count == 0) { Debug.LogWarning($"[{GetType().Name} on {gameObject.name}] No child Transforms with Tags found under Attachments Root '{attachmentsRoot.name}'.", attachmentsRoot); } } else { Debug.LogWarning($"[{GetType().Name} on {gameObject.name}] Attachments Root not assigned.", this); } }
    private void SubscribeToAttachmentChanges() { if (state?.attachments != null) { state.attachments.OnSlotChanged -= HandleAttachmentSlotChanged; state.attachments.OnSlotChanged += HandleAttachmentSlotChanged; } }
    private void UnsubscribeFromAttachmentChanges() { if (state?.attachments != null) { state.attachments.OnSlotChanged -= HandleAttachmentSlotChanged; } }
    private string GetMountTagForSlot(int slotIndex) { if (_activeAttachmentInstances.TryGetValue(slotIndex, out var instanceGO) && instanceGO != null) { if(instanceGO.transform.parent != null) { return instanceGO.transform.parent.tag; } } return null; }

} // End of AttachmentController class
// --- End of script: Assets/Logic/Items/Behaviours/Firearms/AttachmentController.cs ---

// --- Start of script: Assets/Logic/Items/Behaviours/Firearms/FirearmAudioHandler.cs ---
using UnityEngine;

[RequireComponent(typeof(AudioSource))]
public class FirearmAudioHandler : MonoBehaviour
{
    [Header("Audio Clips")]
    [SerializeField] private AudioClip fireClip;          // "Gunshot"
    [SerializeField] private AudioClip reloadClip;        // "Reload"
    [SerializeField] private AudioClip dryFireClip;       // "Click" when firing with no ammo

    [Header("Volumes")]
    [SerializeField] private float fireVolume = 1f;
    [SerializeField] private float reloadVolume = 1f;
    [SerializeField] private float dryFireVolume = 0.8f;

    private AudioSource audioSource;
    private bool isReloading = false;

    private void Awake()
    {
        audioSource = GetComponent<AudioSource>();
    }

    // Play fire sound (when the weapon shoots)
    public void PlayFire()
    {
        if (fireClip == null) return;

        audioSource.PlayOneShot(fireClip, fireVolume);
    }

    // Play reload sound (when the weapon reloads)
    public void PlayReload()
    {
        if (reloadClip == null || isReloading) return;

        isReloading = true;
        audioSource.PlayOneShot(reloadClip, reloadVolume);
    }

    // Play dry fire sound (when there’s no ammo)
    public void PlayDryFire()
    {
        if (dryFireClip == null) return;

        audioSource.PlayOneShot(dryFireClip, dryFireVolume);
    }

    // New method: Play the shoot sound
    public void PlayShootSound()
    {
        PlayFire(); // Simply calls the PlayFire method to play the shooting sound
    }

    // Reset reloading state when reload is done
    public void OnReloadComplete()
    {
        isReloading = false;
    }
}
// --- End of script: Assets/Logic/Items/Behaviours/Firearms/FirearmAudioHandler.cs ---

// --- Start of script: Assets/Logic/Items/Behaviours/Firearms/FirearmBehavior.cs ---
using UnityEngine;
using System.Collections;
using System;

public abstract class FirearmBehavior : EquippableBehavior {
    [Header("Core Component References")]
    [SerializeField] private AttachmentController attachmentController;
    [SerializeField] private FirearmAudioHandler audioHandler;
    [SerializeField] private MuzzleFlashHandler muzzleHandler;
    [SerializeField] private RecoilHandler recoilHandler;
    [SerializeField] private ADSController adsController;
    [SerializeField] private SpreadHandler spreadController;
    [SerializeField] protected Transform firePoint;

    // Runtime Data References (set in Initialize)
    private FirearmItemData def;
    private FirearmRuntimeState state;

    // Internal State
    private Coroutine reloadRoutine;
    private Coroutine autoFireRoutine;
    private bool isCooldown = false;
    private bool isReloading = false;
    private float lastShotTime = -1f;
    private bool _isInitialized = false;
    private bool _isADS = false;

    // Removed: _playerGrabController reference is no longer needed here for Store action


    private int MaxBullets => def?.magazineSize ?? 1;
    private float AutoDelay => (def != null && def.fireRate > 0) ? 1f / def.fireRate : 0.1f;
    private bool IsAuto => def != null && def.fireMode == FireMode.Auto;
    private int CurrentAmmo => state?.magazine != null && state.magazine.Size > 0 && !state.magazine[0].IsEmpty() ? state.magazine[0].quantity : 0;


    protected virtual void Awake() {
        // Find components (ensure robust finding)
        attachmentController ??= GetComponent<AttachmentController>();
        audioHandler ??= GetComponentInChildren<FirearmAudioHandler>(true);
        muzzleHandler ??= GetComponentInChildren<MuzzleFlashHandler>(true);
        recoilHandler ??= GetComponentInChildren<RecoilHandler>(true);
        adsController ??= GetComponent<ADSController>();
        spreadController ??= GetComponent<SpreadHandler>();

        // Validate essential components found in Awake
        if (attachmentController == null) Debug.LogError($"[{GetType().Name} on {gameObject.name}] AttachmentController missing!", this);
        if (audioHandler == null) Debug.LogError($"[{GetType().Name} on {gameObject.name}] FirearmAudioHandler missing!", this);
        if (muzzleHandler == null) Debug.LogError($"[{GetType().Name} on {gameObject.name}] MuzzleFlashHandler missing!", this);
        if (recoilHandler == null) Debug.LogError($"[{GetType().Name} on {gameObject.name}] RecoilHandler missing!", this);
        if (adsController == null) Debug.LogError($"[{GetType().Name} on {gameObject.name}] ADSController missing!", this);
        if (spreadController == null) Debug.LogError($"[{GetType().Name} on {gameObject.name}] SpreadController missing!", this);
        if (firePoint == null) Debug.LogError($"[{GetType().Name} on {gameObject.name}] FirePoint missing!", this);
    }

    public override void Initialize(InventoryItem itemInstance, IEquipmentHolder holder, IAimProvider aimProvider) {
        base.Initialize(itemInstance, holder, aimProvider);

        _isInitialized = false; // Reset initialization flag
        StopRunningCoroutines(); // Ensure no old routines are running
        isReloading = false; // Reset reload state

        // Attempt to cast and validate the provided item instance data
        if (this.runtimeItem != null) {
            def = this.runtimeItem.data as FirearmItemData;
            state = this.runtimeItem.runtime as FirearmRuntimeState;

            if (def == null) { Debug.LogError($"[{GetType().Name} on {gameObject.name}] Init ERROR: ItemData is not FirearmItemData!", this); this.enabled = false; return; }
            if (state == null) { Debug.LogError($"[{GetType().Name} on {gameObject.name}] Init ERROR: InventoryItem missing FirearmState!", this); this.enabled = false; return; }
            if (state.magazine == null) { Debug.LogError($"[{GetType().Name} on {gameObject.name}] Init ERROR: FirearmState missing magazine container!", this); this.enabled = false; return; }
            if (state.attachments == null) { Debug.LogError($"[{GetType().Name} on {gameObject.name}] Init ERROR: FirearmState missing attachments container!", this); this.enabled = false; return; }
        } else {
            Debug.LogError($"[{GetType().Name} on {gameObject.name}] Initializing with null InventoryItem from base class. Cannot function as firearm.", this);
            this.enabled = false; return;
        }

        // Validate essential contexts inherited from base class
        if (this.ownerEquipmentHolder == null) { Debug.LogError($"[{GetType().Name} on {gameObject.name}] IEquipmentHolder context (from base) is null!", this); this.enabled = false; return; }
        if (this.ownerAimProvider == null) { Debug.LogError($"[{GetType().Name} on {gameObject.name}] IAimProvider context (from base) is null!", this); this.enabled = false; return; }

        // Re-validate core components (found in Awake) after initialization context is set
        if (attachmentController == null || recoilHandler == null || adsController == null || spreadController == null || firePoint == null || audioHandler == null) {
             Debug.LogError($"[{GetType().Name} on {gameObject.name}] One or more critical firearm components are missing after Initialize. Disabling.", this);
             this.enabled = false; return;
        }

        // Initialize controllers
        attachmentController.Initialize(state, def, recoilHandler, adsController, spreadController);
        SetADSState(false); // Start not aiming

        _isInitialized = true; // Mark as initialized
    }

    protected override void OnEnable() {
        base.OnEnable();
        isCooldown = false;
        // Restore ADS state if the controller still exists and we were initialized
        if (adsController != null && _isInitialized) {
             SetADSState(adsController.IsAiming); // Sync with ADS controller's state
        } else if (_isInitialized) {
            SetADSState(false); // Default to not aiming if controller missing
        }
    }

    protected override void OnDisable() {
        StopRunningCoroutines();
        CancelInvoke();
        isReloading = false;
        if (adsController != null) adsController.ForceStopAiming(); // Ensure ADS stops visually
        SetADSState(false); // Ensure internal state is non-ADS
        _isInitialized = false; // Mark as uninitialized when disabled
        base.OnDisable();
    }

    // --- Input Handlers ---
    public override void OnFire1Down() { if (!CanPerformAction() || isReloading) return; if (IsAuto) StartAutoFire(); else AttemptSingleFire(); }
    public override void OnFire1Up() { StopAutoFire(); }
    public override void OnFire2Down() { if (!CanPerformAction() || isReloading) return; adsController?.StartAiming(); SetADSState(true); }
    public override void OnFire2Up() { if (adsController != null) { adsController.StopAiming(); SetADSState(false); } }
    public override void OnReloadDown() { if (!CanPerformAction()) return; AttemptReload(); }
    // OnStoreDown() is removed from IItemInputReceiver and base EquippableBehavior

    // --- Firing Logic ---
    private void AttemptSingleFire() {
        if (!CanPerformAction() || isCooldown || isReloading) return;
        if (Time.time - lastShotTime < AutoDelay && lastShotTime > 0 && CurrentAmmo > 0) { return; } // Fire rate limit

        if (CurrentAmmo <= 0) {
            audioHandler?.PlayDryFire();
            lastShotTime = Time.time;
        } else {
            PerformShot();
            ConsumeRound();
            StartCooldown();
            lastShotTime = Time.time;
        }
    }

    protected virtual void PerformShot() {
        // Pre-condition checks
        if (!CanPerformAction() || state?.magazine == null || state.magazine.Size == 0 || firePoint == null || ownerAimProvider == null || recoilHandler == null || spreadController == null) {
            Debug.LogWarning($"[{GetType().Name}] PerformShot pre-condition failed.", this); return;
        }
        InventorySlot magSlot = state.magazine[0];
        if (magSlot.IsEmpty()) { audioHandler?.PlayDryFire(); return; } // Check ammo *again* just before firing

        var ammoInvItem = magSlot.item;
        var projData = ammoInvItem?.data as ProjectileItemData;
        if (projData == null || projData.projectilePrefab == null) {
             Debug.LogWarning($"[{GetType().Name}] No projectile data/prefab for ammo '{ammoInvItem?.data?.itemName}'. Dry fire.", this);
             audioHandler?.PlayDryFire(); return;
        }
        if (projData.projectilePrefab.GetComponent<ProjectileBehavior>() == null) {
             Debug.LogError($"[{GetType().Name}] Projectile prefab '{projData.projectilePrefab.name}' missing ProjectileBehavior!", projData.projectilePrefab);
             return; // Don't fire if prefab is invalid
        }

        // Calculate direction
        Ray ray = ownerAimProvider.GetLookRay();
        Vector3 target = ownerAimProvider.GetAimHitPoint();
        Vector3 baseDir = (target - firePoint.position).normalized;
        // Use look direction if target is too close or behind
        if ((target - firePoint.position).sqrMagnitude < 0.1f || Vector3.Dot(baseDir, ray.direction) < 0.1f) {
            baseDir = ray.direction;
        }

        // Apply recoil and spread offsets
        Quaternion recoilOffset = recoilHandler.GetCurrentRecoilOffsetRotation();
        Quaternion spreadOffset = spreadController.GetSpreadOffsetRotation();
        Vector3 finalDir = spreadOffset * recoilOffset * baseDir; // Apply spread first, then recoil visual offset? Or vice versa? Needs testing. Let's try Spread -> Recoil -> BaseDir
        finalDir.Normalize(); // Ensure unit vector

        // Instantiate and Launch
        try {
            ProjectileBehavior p = Instantiate(projData.projectilePrefab, firePoint.position, Quaternion.LookRotation(finalDir)).GetComponent<ProjectileBehavior>();
            if (p != null) {
                p.Launch(finalDir, projData.baseShootForce);
            } else { // Should have been caught earlier, but belt-and-braces
                 Debug.LogError($"[{GetType().Name}] Failed GetComponent<ProjectileBehavior> on instantiated '{projData.projectilePrefab.name}'!", this);
            }
        } catch (Exception e) {
             Debug.LogError($"[{GetType().Name}] Error instantiating projectile '{projData.projectilePrefab.name}': {e.Message}\n{e.StackTrace}", this);
             return; // Stop if instantiation fails
        }


        // Effects
        audioHandler?.PlayShootSound();
        muzzleHandler?.Muzzle();
        recoilHandler.ApplyRecoil();
        spreadController.AddSpread();
    }

    private void ConsumeRound() {
        if (state?.magazine != null && state.magazine.Size > 0 && !state.magazine[0].IsEmpty()) {
            state.magazine[0].ReduceQuantity(1);
            // Optional: Fire an event or update UI directly if needed here
        }
    }
    private void StartAutoFire() { StopAutoFire(); autoFireRoutine = StartCoroutine(AutoFireCoroutine()); }
    private void StopAutoFire() { if (autoFireRoutine != null) { StopCoroutine(autoFireRoutine); autoFireRoutine = null; } }
    private IEnumerator AutoFireCoroutine() {
        while (true) {
            if (!CanPerformAction() || isReloading) yield break;
            if (CurrentAmmo > 0) { PerformShot(); ConsumeRound(); yield return new WaitForSeconds(AutoDelay); }
            else { audioHandler?.PlayDryFire(); yield break; }
        }
    }
    private void StartCooldown() {
        if (IsAuto && def.fireMode == FireMode.Auto) return; // Auto handles its own delay
        isCooldown = true;
        CancelInvoke(nameof(EndCooldown)); // Prevent stacking invokes
        Invoke(nameof(EndCooldown), AutoDelay);
    }
    private void EndCooldown() => isCooldown = false;

    // --- Reloading Logic ---
    private void AttemptReload() {
        if (!CanPerformAction() || isReloading) return; // Already reloading or cannot act
        if (def?.ammoType == null) { Debug.LogWarning($"[{GetType().Name}] Cannot reload: {def?.itemName} missing ammoType.", this); return; }
        if (ownerEquipmentHolder == null) { Debug.LogError($"[{GetType().Name}] Cannot reload: Missing IEquipmentHolder context.", this); return; }
        if (state?.magazine == null || state.magazine.Size == 0) { Debug.LogError($"[{GetType().Name}] Cannot reload: FirearmState magazine container missing.", this); return; }
        if (CurrentAmmo >= MaxBullets) return; // Magazine already full

        // Check if holder actually has the required ammo type
        if (!ownerEquipmentHolder.HasItemInInventory(def.ammoType)) {
            // Debug.Log($"[{GetType().Name}] No '{def.ammoType.itemName}' in inventory.");
            audioHandler?.PlayDryFire(); // Play sound indicating no ammo available
            return;
        }
        // All checks pass, start the reload sequence
        StartReloadSequence();
    }

    private void StartReloadSequence() {
        StopRunningCoroutines(); // Stop firing, etc.
        reloadRoutine = StartCoroutine(ReloadCoroutine());
    }

    private IEnumerator ReloadCoroutine() {
        isReloading = true;
        if (adsController != null) { SetADSState(false); adsController.ForceStopAiming(); } // Force exit ADS
        audioHandler?.PlayReload();
        yield return new WaitForSeconds(def?.reloadTime ?? 1.0f); // Wait for reload duration

        // Re-validate state after yield, as things might have changed (e.g., player died, item unequipped)
        if (!isReloading || !_isInitialized || state?.magazine == null || def == null || ownerEquipmentHolder == null) {
            isReloading = false; // Ensure flag is reset
            reloadRoutine = null;
            yield break; // Abort if state is no longer valid
        }

        // Calculate ammo needed and available
        int needed = MaxBullets - CurrentAmmo;
        ItemContainer mainInv = ownerEquipmentHolder.GetContainerForInventory();
        int available = 0;
        if (mainInv != null) {
            foreach (var s in mainInv.Slots) {
                if (s != null && !s.IsEmpty() && s.item.data == def.ammoType) {
                    available += s.quantity;
                }
            }
        }

        int transfer = Mathf.Min(needed, available); // Amount to actually transfer

        // Perform the transfer
        if (transfer > 0) {
            // Consume from inventory first
            if (ownerEquipmentHolder.RequestConsumeItem(def.ammoType, transfer)) {
                // Add to magazine slot
                InventorySlot magSlot = state.magazine[0];
                if (magSlot.IsEmpty() || magSlot.item?.data != def.ammoType) {
                    // If empty or wrong type, create new item entry
                    magSlot.item = new InventoryItem(def.ammoType);
                    magSlot.quantity = 0; // Ensure quantity starts at 0 before adding
                }
                magSlot.AddQuantity(transfer); // Add the consumed amount
            } else {
                // This should ideally not happen if HasItemInInventory passed and available > 0
                Debug.LogError($"[{GetType().Name}] Failed inventory consumption for {transfer}x'{def.ammoType.itemName}' during reload despite checks!", this);
            }
        }
        // else: No ammo available or needed, just finish the animation/sound timing

        FinishReload(); // Mark reload as complete
    }

    private void FinishReload() {
        isReloading = false;
        reloadRoutine = null;
        audioHandler?.OnReloadComplete();
        // Optional: Auto-enter ADS if player was holding ADS button during reload?
    }

    // --- Utility Methods ---
    private bool CanPerformAction() => _isInitialized && this.enabled && Time.timeScale > 0.01f;
    private void StopRunningCoroutines() {
        StopAutoFire();
        if (reloadRoutine != null) {
            StopCoroutine(reloadRoutine);
            reloadRoutine = null;
            if (isReloading) { isReloading = false; /* Maybe cancel sound? */ }
        }
    }
    private void SetADSState(bool isADS) {
        if (_isADS == isADS && _isInitialized) return;
        _isADS = isADS;
        if (_isInitialized) { // Only update handlers if firearm is ready
            recoilHandler?.SetADS(isADS);
            spreadController?.SetADS(isADS);
        }
    }
}
// --- End of script: Assets/Logic/Items/Behaviours/Firearms/FirearmBehavior.cs ---

// --- Start of script: Assets/Logic/Items/Behaviours/Firearms/MuzzleFlashHandler.cs ---
using System.Collections;
using UnityEngine;

public class MuzzleFlashHandler : MonoBehaviour
{
    [Header("Muzzle Flash Settings")]
    [Tooltip("The ParticleSystem to play for the muzzle flash.")]
    [SerializeField] private ParticleSystem muzzleParticles;

    /// <summary>
    /// Call this to play the muzzle flash particles.
    /// </summary>
    public void Muzzle()
    {
        if (muzzleParticles == null)
        {
            Debug.LogWarning("MuzzleFlashController: No ParticleSystem assigned.");
            return;
        }
        muzzleParticles.Play();
    }
}
// --- End of script: Assets/Logic/Items/Behaviours/Firearms/MuzzleFlashHandler.cs ---

// --- Start of script: Assets/Logic/Items/Behaviours/Firearms/RecoilHandler.cs ---
using UnityEngine;
using Random = UnityEngine.Random;

/// <summary>
/// Applies visual recoil motion and exposes the current rotational offset for aim calculation.
/// Considers base pattern, attachment multipliers, and ADS state.
/// </summary>
public class RecoilHandler : MonoBehaviour
{
    // --- Configuration (Set by AttachmentController) ---
    private RecoilPattern basePattern = new RecoilPattern();
    private float currentMagnitudeMultiplier = 1.0f;
    private float currentRecoverySpeedMultiplier = 1.0f;
    private float adsVisualRecoilMultiplier = 1.0f; // Multiplier when ADS

    // --- Runtime State ---
    [Header("Randomness")]
    [Range(0f, 100f)] public float randomSeed = 0f;

    private Vector3 originalEuler;
    private Vector3 rotOffset = Vector3.zero;
    private Vector3 rotVelocity = Vector3.zero;
    private Vector3 originalPos;
    private Vector3 posOffset = Vector3.zero;
    private Vector3 posVelocity = Vector3.zero;

    private bool isCurrentlyADS = false; // Track ADS state

    private void Awake()
    {
        originalEuler = transform.localEulerAngles;
        originalPos = transform.localPosition;
        if (randomSeed <= 0f) randomSeed = Random.Range(1f, 100f);
        basePattern ??= new RecoilPattern();
    }

    /// <summary>
    /// Sets the base, unmodified recoil pattern.
    /// </summary>
    public void SetBaseRecoilPattern(RecoilPattern newBasePattern)
    {
        this.basePattern = (newBasePattern != null) ? new RecoilPattern(newBasePattern) : new RecoilPattern();
    }

    /// <summary>
    /// Sets the combined multipliers from attachments and the ADS multiplier from definition.
    /// </summary>
    public void SetRecoilModifiers(float magnitudeMultiplier, float recoverySpeedMultiplier, float adsMultiplier)
    {
        this.currentMagnitudeMultiplier = Mathf.Max(0f, magnitudeMultiplier);
        this.currentRecoverySpeedMultiplier = Mathf.Max(0.01f, recoverySpeedMultiplier);
        this.adsVisualRecoilMultiplier = Mathf.Clamp01(adsMultiplier); // Store ADS multiplier
    }

    /// <summary>
    /// Updates the ADS state, affecting recoil magnitude. Called by FirearmBehavior.
    /// </summary>
    public void SetADS(bool isADS)
    {
        isCurrentlyADS = isADS;
    }

    /// <summary>
    /// Applies a single visual recoil kick based on the base pattern and current modifiers/ADS state.
    /// </summary>
    public void ApplyRecoil()
    {
        if (basePattern == null) return;

        // Calculate effective magnitude considering attachments AND ADS state
        float effectiveMagnitude = currentMagnitudeMultiplier;
        if (isCurrentlyADS)
        {
            effectiveMagnitude *= adsVisualRecoilMultiplier; // Apply ADS reduction
        }

        // --- Calculate Random Kick Values ---
        // Vertical component (Pitch)
        float vOff = RandomPattern(basePattern.verticalMin * effectiveMagnitude, basePattern.verticalMax * effectiveMagnitude);
        // Horizontal component (Yaw)
        float hOff = RandomPattern(basePattern.horizontalMin * effectiveMagnitude, basePattern.horizontalMax * effectiveMagnitude);
        // Roll component (Tilt)
        float rOff = RandomPattern(basePattern.rollMin * effectiveMagnitude, basePattern.rollMax * effectiveMagnitude);

        // --- Apply Rotation Offset (Corrected for Standard Axes) ---
        // X controls Roll, Y controls Yaw, Z controls Pitch
        // Negative Z rotation pitches UP
        rotOffset += new Vector3(rOff, hOff, -vOff);
        //                      ^Roll ^Yaw  ^Pitch (Up)

        // --- Positional Kick ---
        float zOff = RandomPattern(basePattern.kickbackMin * effectiveMagnitude, basePattern.kickbackMax * effectiveMagnitude);
        // Kickback is usually along the local forward/backward axis (Z)
        posOffset += new Vector3(0f, 0f, -zOff); // Still standard backward kick along local Z
    }

    /// <summary>
    /// Gets the current rotational offset caused by recoil. Used by FirearmBehavior for aim calculation.
    /// </summary>
    /// <returns>Quaternion representing the current visual rotation offset.</returns>
    public Quaternion GetCurrentRecoilOffsetRotation()
    {
        // Convert the Euler offset to a Quaternion
        return Quaternion.Euler(rotOffset);
    }


    private void Update()
    {
        if (basePattern == null) return;

        // Calculate effective recovery duration
        float effectiveRecoveryDuration = basePattern.recoveryDuration * currentRecoverySpeedMultiplier;
        effectiveRecoveryDuration = Mathf.Max(0.01f, effectiveRecoveryDuration);

        // Recover rotation
        rotOffset = Vector3.SmoothDamp(rotOffset, Vector3.zero, ref rotVelocity, effectiveRecoveryDuration);
        transform.localEulerAngles = originalEuler + rotOffset;

        // Recover position
        posOffset = Vector3.SmoothDamp(posOffset, Vector3.zero, ref posVelocity, effectiveRecoveryDuration);
        transform.localPosition = originalPos + posOffset;
    }

    private float RandomPattern(float min, float max)
    {
         return Random.Range(min, max);
    }
}
// --- End of script: Assets/Logic/Items/Behaviours/Firearms/RecoilHandler.cs ---

// --- Start of script: Assets/Logic/Items/Behaviours/Firearms/RecoilPattern.cs ---
// In Assets/Scripts/Items/Data/Weapons/Shared/RecoilPattern.cs (Example Path)
using UnityEngine;

/// <summary>
/// Defines the characteristics of a single recoil impulse applied after firing.
/// Used by RecoilHandler to generate visual weapon kick.
/// </summary>
[System.Serializable]
public class RecoilPattern {

    #region Inspector Fields
    [Header("Rotation Kick (Degrees)")]
    [Tooltip("Minimum upward rotation.")]
    public float verticalMin = 1.0f;
    [Tooltip("Maximum upward rotation.")]
    public float verticalMax = 2.0f;
    [Tooltip("Minimum horizontal rotation (negative = left).")]
    public float horizontalMin = -1.0f;
    [Tooltip("Maximum horizontal rotation (positive = right).")]
    public float horizontalMax = 1.0f;
    [Tooltip("Minimum roll rotation (negative = left barrel up).")]
    public float rollMin = -0.5f;
    [Tooltip("Maximum roll rotation (positive = right barrel up).")]
    public float rollMax = 0.5f;

    [Header("Positional Kick (Local Space Units)")]
    [Tooltip("Minimum backward kick distance along the local Z axis.")]
    public float kickbackMin = 0.02f;
    [Tooltip("Maximum backward kick distance along the local Z axis.")]
    public float kickbackMax = 0.05f;
    // Add lateral/vertical kick if needed:
    // public float lateralKickRange = 0.01f; // Max left/right positional kick
    // public float verticalKickRange = 0.005f; // Max up/down positional kick

    [Header("Timing (Seconds)")]
    [Tooltip("How long the initial kick-back phase lasts.")]
    [Min(0.01f)] public float recoilDuration = 0.1f;
    [Tooltip("How long it takes for the weapon to return to its resting position after the kick.")]
    [Min(0.01f)] public float recoveryDuration = 0.2f;

    [Header("Easing")]
    [Tooltip("Curve defining the interpolation for both the kick-back and recovery phases (Time 0->1 maps to movement 0->1). Should ideally start at 0,0 and end at 1,1.")]
    public AnimationCurve recoilCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);
    #endregion

    #region Constructors
    /// <summary>
    /// Default constructor. Initializes with default values specified in field initializers.
    /// Required for direct instantiation like 'new RecoilPattern()'.
    /// </summary>
    public RecoilPattern() { }

    /// <summary>
    /// Copy constructor. Creates a deep copy of another RecoilPattern instance.
    /// </summary>
    public RecoilPattern(RecoilPattern other) {
        if (other == null) return; // Safety check

        // Copy value types
        this.verticalMin = other.verticalMin;
        this.verticalMax = other.verticalMax;
        this.horizontalMin = other.horizontalMin;
        this.horizontalMax = other.horizontalMax;
        this.rollMin = other.rollMin;
        this.rollMax = other.rollMax;
        this.kickbackMin = other.kickbackMin;
        this.kickbackMax = other.kickbackMax;
        this.recoilDuration = other.recoilDuration;
        this.recoveryDuration = other.recoveryDuration;

        // Deep copy the AnimationCurve (it's a reference type)
        this.recoilCurve = (other.recoilCurve != null)
            ? new AnimationCurve(other.recoilCurve.keys) // Create new curve with copied keys
            : new AnimationCurve(); // Create a default empty curve if source is null
    }
    #endregion

    #region Validation
    /// <summary>
    /// Clamps values to reasonable ranges. Called by FirearmItemData.OnValidate.
    /// </summary>
    public void Validate() {
        // Ensure Min <= Max for ranges
        verticalMax = Mathf.Max(verticalMin, verticalMax);
        horizontalMax = Mathf.Max(horizontalMin, horizontalMax);
        rollMax = Mathf.Max(rollMin, rollMax);
        kickbackMax = Mathf.Max(kickbackMin, kickbackMax);

        // Ensure positive durations
        recoilDuration = Mathf.Max(0.01f, recoilDuration); // Prevent zero or negative duration
        recoveryDuration = Mathf.Max(0.01f, recoveryDuration);

        // Optional: Add warnings for extreme values if desired
        // if (verticalMax > 15f) Debug.LogWarning("RecoilPattern: High verticalMax value detected.");
    }
    #endregion
}
// --- End of script: Assets/Logic/Items/Behaviours/Firearms/RecoilPattern.cs ---

// --- Start of script: Assets/Logic/Items/Behaviours/Firearms/SpreadHandler.cs ---
using UnityEngine;
using Random = UnityEngine.Random; // Explicitly use UnityEngine.Random

/// <summary>
/// Manages weapon spread (random bullet deviation).
/// Calculates current spread angle based on base stats, firing, ADS, and modifiers.
/// Provides random offsets for bullet trajectory.
/// </summary>
public class SpreadHandler : MonoBehaviour
{
    // --- Configuration (Set via Initialize & SetSpreadModifiers) ---
    private SpreadPattern basePattern = new SpreadPattern();
    private float adsSpreadMultiplier = 1.0f;
    // Combined modifiers from attachments
    private float modBaseSpreadMult = 1.0f;
    private float modMaxSpreadMult = 1.0f;
    private float modSpreadIncreaseMult = 1.0f;
    private float modSpreadRecoveryMult = 1.0f;

    // --- Runtime State ---
    private float currentSpreadAngle = 0f; // Current spread radius in degrees
    private float timeSinceLastShot = float.MaxValue; // Time tracking for recovery delay
    private bool isCurrentlyADS = false;
    private bool _isInitialized = false;

    // --- Properties ---
    public float CurrentSpreadDegrees => currentSpreadAngle; // Expose if needed for UI/debug

    // --- Initialization ---
    public void Initialize(SpreadPattern pattern, float adsMult)
    {
        basePattern = (pattern != null) ? new SpreadPattern(pattern) : new SpreadPattern();
        adsSpreadMultiplier = Mathf.Clamp01(adsMult);

        // Reset modifiers and state
        modBaseSpreadMult = 1.0f;
        modMaxSpreadMult = 1.0f;
        modSpreadIncreaseMult = 1.0f;
        modSpreadRecoveryMult = 1.0f;
        currentSpreadAngle = GetEffectiveBaseSpread(); // Start at base spread
        timeSinceLastShot = float.MaxValue;
        isCurrentlyADS = false;
        _isInitialized = true;
    }

    public void SetSpreadModifiers(float baseMult, float maxMult, float increaseMult, float recoveryMult)
    {
        modBaseSpreadMult = Mathf.Max(0f, baseMult);
        modMaxSpreadMult = Mathf.Max(0f, maxMult);
        modSpreadIncreaseMult = Mathf.Max(0f, increaseMult);
        modSpreadRecoveryMult = Mathf.Max(0.1f, recoveryMult); // Prevent zero recovery rate multiplier

        // Clamp current spread immediately if modifiers changed max/min
        currentSpreadAngle = Mathf.Clamp(currentSpreadAngle, GetEffectiveBaseSpread(), GetEffectiveMaxSpread());
    }

    public void SetADS(bool isADS)
    {
        isCurrentlyADS = isADS;
    }

    // --- Update Logic ---
    private void Update()
    {
        if (!_isInitialized) return;

        timeSinceLastShot += Time.deltaTime;

        // Recover spread if delay has passed
        if (timeSinceLastShot >= basePattern.spreadRecoveryDelay)
        {
            RecoverSpread(Time.deltaTime);
        }
    }

    private void RecoverSpread(float deltaTime)
    {
        float targetSpread = GetEffectiveBaseSpread();
        float recoveryRate = basePattern.spreadRecoveryRate * modSpreadRecoveryMult;

        // Move towards target spread, but don't overshoot
        currentSpreadAngle = Mathf.Max(targetSpread, currentSpreadAngle - recoveryRate * deltaTime);
    }

    // --- Actions ---

    /// <summary>
    /// Increases the current spread due to firing a shot.
    /// </summary>
    public void AddSpread()
    {
        if (!_isInitialized) return;

        float increaseAmount = basePattern.spreadIncreasePerShot * modSpreadIncreaseMult;
        float maxSpread = GetEffectiveMaxSpread();

        currentSpreadAngle = Mathf.Min(maxSpread, currentSpreadAngle + increaseAmount);
        timeSinceLastShot = 0f; // Reset recovery timer
    }

    /// <summary>
    /// Calculates a random rotation offset based on the current spread angle and ADS state.
    /// </summary>
    /// <returns>A Quaternion representing the random deviation.</returns>
    public Quaternion GetSpreadOffsetRotation()
    {
        if (!_isInitialized) return Quaternion.identity;

        float effectiveSpread = currentSpreadAngle;
        if (isCurrentlyADS)
        {
            effectiveSpread *= adsSpreadMultiplier;
        }

        // Ensure minimum spread if calculation results in zero or negative
        effectiveSpread = Mathf.Max(0.01f, effectiveSpread); // Avoid issues with zero spread

        // --- Calculate random point within a circle ---
        // Convert degrees to radians for trig functions
        float spreadRad = Mathf.Deg2Rad * effectiveSpread * 0.5f; // Use half angle for tan

        // Get a random angle and radius (use sqrt for uniform distribution)
        float randomAngle = Random.Range(0f, 2f * Mathf.PI);
        float randomRadius = Mathf.Sqrt(Random.Range(0f, 1f)); // Uniform distribution within the cone base circle

        // Calculate offset using tangent
        float tanSpread = Mathf.Tan(spreadRad);
        float offsetX = randomRadius * Mathf.Cos(randomAngle) * tanSpread;
        float offsetY = randomRadius * Mathf.Sin(randomAngle) * tanSpread;

        // Z component is always 1 (forward direction in local space)
        Vector3 offsetTarget = new Vector3(offsetX, offsetY, 1f);

        // Create rotation that looks towards this offset point from origin
        return Quaternion.LookRotation(offsetTarget.normalized, Vector3.up); // Using LookRotation is convenient
    }

    // --- Helper Methods ---
    private float GetEffectiveBaseSpread()
    {
        return basePattern.baseSpreadAngle * modBaseSpreadMult;
    }

    private float GetEffectiveMaxSpread()
    {
        // Ensure max is always >= base
        return Mathf.Max(GetEffectiveBaseSpread(), basePattern.maxSpreadAngle * modMaxSpreadMult);
    }
}
// --- End of script: Assets/Logic/Items/Behaviours/Firearms/SpreadHandler.cs ---

// --- Start of script: Assets/Logic/Items/Behaviours/Firearms/SpreadPattern.cs ---
using UnityEngine;

/// <summary>
/// Defines the parameters for weapon spread (random inaccuracy).
/// </summary>
[System.Serializable]
public class SpreadPattern
{
    [Header("Angle Settings (Degrees)")]
    [Tooltip("Minimum spread angle when weapon is idle/fully recovered.")]
    [Range(0f, 5f)]
    public float baseSpreadAngle = 0.5f;

    [Tooltip("Maximum spread angle the weapon can reach.")]
    [Range(0.1f, 15f)]
    public float maxSpreadAngle = 5.0f;

    [Header("Bloom & Recovery")]
    [Tooltip("Angle increase added per shot fired.")]
    [Range(0f, 5f)]
    public float spreadIncreasePerShot = 0.75f;

    [Tooltip("Degrees per second the spread angle recovers towards the base spread.")]
    [Range(0.1f, 50f)]
    public float spreadRecoveryRate = 10.0f;

    [Tooltip("Delay (in seconds) after firing before spread starts recovering.")]
    [Range(0f, 1f)]
    public float spreadRecoveryDelay = 0.15f;

    // Constructor for defaults
    public SpreadPattern() { }

    // Copy constructor (important since it's likely used in ItemData)
    public SpreadPattern(SpreadPattern other)
    {
        this.baseSpreadAngle = other.baseSpreadAngle;
        this.maxSpreadAngle = other.maxSpreadAngle;
        this.spreadIncreasePerShot = other.spreadIncreasePerShot;
        this.spreadRecoveryRate = other.spreadRecoveryRate;
        this.spreadRecoveryDelay = other.spreadRecoveryDelay;
    }

    // Optional: Add validation logic here if needed
    public void Validate()
    {
        baseSpreadAngle = Mathf.Max(0f, baseSpreadAngle);
        maxSpreadAngle = Mathf.Max(baseSpreadAngle, maxSpreadAngle); // Max cannot be less than base
        spreadIncreasePerShot = Mathf.Max(0f, spreadIncreasePerShot);
        spreadRecoveryRate = Mathf.Max(0.1f, spreadRecoveryRate);
        spreadRecoveryDelay = Mathf.Max(0f, spreadRecoveryDelay);
    }
}
// --- End of script: Assets/Logic/Items/Behaviours/Firearms/SpreadPattern.cs ---

// --- Start of script: Assets/Logic/Items/Behaviours/Hands/HandsBehavior.cs ---
// --- Assets/Logic/Items/Behaviours/Hands/HandsBehavior.cs ---
using UnityEngine;

public class HandsBehavior : EquippableBehavior {
    // PlayerGrabController is now inherited from EquippableBehavior and set in its Initialize

    public override void Initialize(InventoryItem itemInstance, IEquipmentHolder holder, IAimProvider aimProvider) {
        base.Initialize(itemInstance, holder, aimProvider); // This will find playerGrabController

        if (this.playerGrabController == null) { // playerGrabController is inherited
             Debug.LogError($"[HandsBehavior Initialize] CRITICAL: PlayerGrabController not found via base.Initialize! Hands actions will not function.", this);
             this.enabled = false;
        }
    }

    /// <summary>
    /// Fire1 (LMB) with Hands:
    /// - If PlayerGrabController is holding an item, try to attach it. If attach fails, drop it.
    /// - If PlayerGrabController is NOT holding, try to grab a loose item or detach an installed part.
    /// </summary>
    public override void OnFire1Down() {
        if (playerGrabController == null) return;
        playerGrabController.TryGrabOrDetachWorldObject(); // This method in PGC handles both grab/detach and attach attempts
    }

    /// <summary>
    /// Fire2 (RMB) with Hands:
    /// - If PlayerGrabController is holding an item, drop it.
    /// </summary>
    public override void OnFire2Down() {
         if (playerGrabController == null) return;
         if (playerGrabController.IsGrabbing) {
            playerGrabController.DropGrabbedItemWithLMB(); // Or a generic DropGrabbedItem() if you prefer
         }
     }

    /// <summary>
    /// Store (T) with Hands:
    /// - If PlayerGrabController is holding an item, attempt to store it in inventory.
    /// - If PlayerGrabController is NOT holding, attempt to pull selected toolbar item into hands.
    /// </summary>
    public override void OnStoreDown() {
        if (playerGrabController == null) return;
        // PlayerGrabController.HandleStoreAction already implements the desired dual logic
        playerGrabController.HandleStoreAction();
    }

    // Other inputs usually do nothing for basic hands
    public override void OnFire1Hold() {} 
    public override void OnFire1Up() {}
    public override void OnFire2Hold() {}
    public override void OnFire2Up() {}
    public override void OnUtilityDown() { 
        // Could be used to toggle rotation lock if PGC supports it directly
        // if (playerGrabController != null && playerGrabController.IsGrabbing) { /* playerGrabController.ToggleRotationLock(); */ }
    }
    public override void OnUtilityUp() {}
    public override void OnReloadDown() {}
}
// --- End of script: Assets/Logic/Items/Behaviours/Hands/HandsBehavior.cs ---

// --- Start of script: Assets/Logic/Items/Behaviours/Pickaxe/PickaxeSwingEffect.cs ---
using UnityEngine;

public class PickaxeSwingAnimator : MonoBehaviour
{
    [Header("Swing Targets")]
    [SerializeField] private Transform pickaxeTransform;

    [Header("Swing Settings")]
    [SerializeField] private Vector3 swingRotation = new Vector3(60f, 0f, 0f);
    [SerializeField] private float swingDuration = 0.3f;
    [SerializeField] private float returnDuration = 0.2f;
    [SerializeField] private AnimationCurve swingCurve;

    private Quaternion originalRotation;
    private bool isSwinging = false;
    private float swingTimer = 0f;
    private bool returning = false;

    private void Start()
    {
        originalRotation = pickaxeTransform.localRotation;
        if (swingCurve == null || swingCurve.length == 0)
        {
            swingCurve = AnimationCurve.EaseInOut(0, 0, 1, 1); // default smooth curve
        }
    }

    public void TriggerSwing()
    {
        if (!isSwinging)
        {
            isSwinging = true;
            swingTimer = 0f;
            returning = false;
        }
    }

    private void Update()
    {
        if (!isSwinging) return;

        swingTimer += Time.deltaTime;
        float duration = returning ? returnDuration : swingDuration;
        float t = Mathf.Clamp01(swingTimer / duration);
        float curveT = swingCurve.Evaluate(t);

        if (!returning)
        {
            // Swing forward
            Quaternion targetRotation = originalRotation * Quaternion.Euler(swingRotation);
            pickaxeTransform.localRotation = Quaternion.Slerp(originalRotation, targetRotation, curveT);
        }
        else
        {
            // Return to original rotation
            Quaternion targetRotation = originalRotation * Quaternion.Euler(swingRotation);
            pickaxeTransform.localRotation = Quaternion.Slerp(targetRotation, originalRotation, curveT);
        }

        if (swingTimer >= duration)
        {
            if (!returning)
            {
                // Start returning to idle
                returning = true;
                swingTimer = 0f;
            }
            else
            {
                // Done
                isSwinging = false;
                pickaxeTransform.localRotation = originalRotation;
            }
        }
    }
}
// --- End of script: Assets/Logic/Items/Behaviours/Pickaxe/PickaxeSwingEffect.cs ---

// --- Start of script: Assets/Logic/Items/Data/Ammo/ArrowItemData.cs ---
// Example: Put in Assets/Scripts/Items/Data/Ammo/ArrowItemData.cs
using UnityEngine;

[CreateAssetMenu(fileName = "NewArrowData", menuName = "Items/Ammo/Arrow")]
public class ArrowItemData : ItemData { // Make sure it inherits from ItemData

    [Header("Arrow Specifics")]
    [Tooltip("The projectile prefab containing ArrowProjectile or similar ProjectileBehavior script.")]
    public GameObject projectilePrefab; // This MUST be public GameObject

    // Add other arrow-specific static data if needed (e.g., base penetration value)

    protected override void OnValidate() {
        base.OnValidate();
        this.category = ItemCategory.Ammo; // Set appropriate category
        this.stackable = true; // Arrows are usually stackable
        if (this.maxStack <= 1) this.maxStack = 20; // Default stack size
        if (projectilePrefab == null) Debug.LogWarning($"Projectile Prefab not set for ArrowData: {this.name}", this);
    }
}
// --- End of script: Assets/Logic/Items/Data/Ammo/ArrowItemData.cs ---

// --- Start of script: Assets/Logic/Items/Data/Attachments/AttachmentAimPoint.cs ---
using UnityEngine;

/// <summary>
/// Marker component placed on the specific Transform within an attachment prefab
/// that represents the point to align with the camera during ADS.
/// The ADSController will use this Transform's position.
/// </summary>
public class AttachmentAimPoint : MonoBehaviour
{
    // No code needed, its presence and Transform are the key.
    // You could add debug visuals here later if needed.
}
// --- End of script: Assets/Logic/Items/Data/Attachments/AttachmentAimPoint.cs ---

// --- Start of script: Assets/Logic/Items/Data/Attachments/AttachmentItemData.cs ---
// AttachmentItemData.cs (Relevant parts shown)
using UnityEngine;

[CreateAssetMenu(menuName = "Items/Attachment")]
public class AttachmentItemData : ItemData
{
    [Header("Attachment Specific")]
    public AttachmentType attachmentType = AttachmentType.None;

    [Tooltip("The visual prefab for this attachment.")]
    public GameObject attachmentPrefab; // The model to instantiate on the weapon

    [Tooltip("The tag of the attachment point Transform on the weapon prefab this attaches to (e.g., 'SightMount', 'MuzzleMount').")]
    public string mountPointTag = "Untagged";

    // --- Sight Specific Data ---
    [Header("Sight Specific (If Type is Sight)")]
    // REMOVED: public string sightAimPointName = "SightAimPoint";

    [Tooltip("Does this sight override the default camera anchor offset?")]
    public bool overrideCameraAnchorOffset = false;

    [Tooltip("The camera anchor offset to use IF overriding the default.")]
    public Vector3 customCameraAnchorOffset = new Vector3(0, 0, 0.1f);
}
// --- End of script: Assets/Logic/Items/Data/Attachments/AttachmentItemData.cs ---

// --- Start of script: Assets/Logic/Items/Data/Attachments/AttachmentStatModifier.cs ---
using UnityEngine;

/// <summary>
/// Attach this component to attachment prefabs to modify weapon stats.
/// </summary>
public class AttachmentStatModifier : MonoBehaviour
{
    [Header("ADS")]
    [Tooltip("Multiplier for ADS transition speed. > 1 speeds up, < 1 slows down.")]
    [Range(0.5f, 2f)]
    public float adsSpeedMultiplier = 1.0f;

    [Header("Recoil Modifiers")]
    [Tooltip("Overall multiplier for recoil magnitude (Vertical, Horizontal, Roll, Kickback). < 1 Reduces Recoil magnitude.")]
    [Range(0f, 2f)]
    public float recoilMagnitudeMultiplier = 1.0f;
    [Tooltip("Multiplier for how quickly the weapon recovers from recoil. < 1 Faster Recovery, > 1 Slower Recovery.")]
    [Range(0.5f, 2f)]
    public float recoverySpeedMultiplier = 1.0f;

    // --- ADDED SPREAD MODIFIERS ---
    [Header("Spread Modifiers")]
    [Tooltip("Multiplier for the minimum base spread angle. < 1 Tighter base spread.")]
    [Range(0f, 2f)]
    public float baseSpreadMultiplier = 1.0f;

    [Tooltip("Multiplier for the maximum possible spread angle. < 1 Less max spread.")]
    [Range(0f, 2f)]
    public float maxSpreadMultiplier = 1.0f;

    [Tooltip("Multiplier for how much spread increases per shot. < 1 Less bloom.")]
    [Range(0f, 2f)]
    public float spreadIncreaseMultiplier = 1.0f;

    [Tooltip("Multiplier for how fast spread recovers. < 1 Faster recovery, > 1 Slower recovery.")]
    [Range(0.5f, 2f)]
    public float spreadRecoveryMultiplier = 1.0f;
    // --- END ADDED ---
}
// --- End of script: Assets/Logic/Items/Data/Attachments/AttachmentStatModifier.cs ---

// --- Start of script: Assets/Logic/Items/Data/Attachments/AttachmentType.cs ---
// AttachmentType.cs
public enum AttachmentType
{
    None, // Default
    Sight,
    Muzzle,
    Tactical, // e.g., Flashlight, Laser
    Grip,
    Magazine // While magazines are handled differently now, could be an option
    // Add more as needed
}
// --- End of script: Assets/Logic/Items/Data/Attachments/AttachmentType.cs ---

// --- Start of script: Assets/Logic/Items/Data/Projectiles/ProjectileItemData.cs ---
using UnityEngine;

[CreateAssetMenu(fileName = "NewProjectileItem", menuName = "Items/Projectile")]
public class ProjectileItemData : ItemData
{
    [Header("Projectile Settings")]
    [Tooltip("The projectile prefab that this item represents.")]
    public ProjectileBehavior projectilePrefab;

    [Header("Projectile Attributes")]
    [Tooltip("The damage dealt by this projectile.")]
    public float damage = 10f;

    [Tooltip("The speed of this projectile.")]
    public float speed = 20f;

    [Tooltip("How long the projectile will last before it disappears.")]
    public float lifetime = 5f;

    [Header("Shoot Settings")]
    [Tooltip("The base shoot force applied when firing the projectile.")]
    public float baseShootForce = 40f; // New field to define base shoot force for projectiles

    private void OnEnable()
    {
        category = ItemCategory.Ammo;
        stackable = true;
    }
}
// --- End of script: Assets/Logic/Items/Data/Projectiles/ProjectileItemData.cs ---

// --- Start of script: Assets/Logic/Items/Data/Weapons/FirearmItemData.cs ---
using UnityEngine;
using System.Collections.Generic; // Needed for List

public enum FireMode { Semi, Auto, Burst }

// Ensure your enums exist or are defined elsewhere
// public enum FireMode { Semi, Auto, Burst }
// public struct RecoilPattern { /* Define fields */ }
// public struct SpreadPattern { public void Validate() {} /* Define fields and Validate */ }

[CreateAssetMenu(menuName = "Items/Weapon/Firearm")]
public class FirearmItemData : WeaponItemData { // Inherits WeaponItemData (which inherits ItemData)

    [System.Serializable]
    public struct DefaultAttachmentMapping {
        public string mountPointTag;
        public GameObject defaultPrefab;
    }

    [Header("Firing Mechanism")]
    public FireMode fireMode = FireMode.Semi;
    [Min(0.1f)] public float fireRate = 10f;
    [Min(0.1f)] public float reloadTime = 1.5f;

    [Header("Magazine & Ammunition")]
    [Min(1)] public int magazineSize = 12;
    public ItemData ammoType; // Assign Ammo ItemData SO here

    [Header("Recoil")]
    public RecoilPattern baseRecoilPattern = new RecoilPattern();

    [Header("Spread / Spray")]
    public SpreadPattern baseSpreadPattern = new SpreadPattern();

    [Header("ADS Settings")]
    public Vector3 defaultCameraAnchorOffset = new Vector3(0, 0, 0.15f);
    [Range(0f, 1f)] public float adsVisualRecoilMultiplier = 0.5f;
    [Range(0f, 1f)] public float adsSpreadMultiplier = 0.2f;

    [Header("Attachments")]
    [Min(0)] public int attachmentSlots = 4;
    public List<DefaultAttachmentMapping> defaultAttachments;

    // Factory Method to create an InventoryItem instance with runtime state
    public InventoryItem CreateInventoryItemInstance() {
        // Assuming FirearmState exists and takes attachmentSlots and durability
        var payload = new FirearmRuntimeState(attachmentSlots, 100);
        var item = new InventoryItem(this, payload);
        return item;
    }

    // Editor Validation using override
    protected override void OnValidate() { // Changed private to protected override
        base.OnValidate(); // IMPORTANT: Call the base (WeaponItemData's) OnValidate first

        // --- Firearm Specific Validation ---
        // Clamps
        if (fireRate <= 0) fireRate = 0.1f;
        if (magazineSize < 1) magazineSize = 1;
        if (reloadTime < 0.1f) reloadTime = 0.1f;
        adsVisualRecoilMultiplier = Mathf.Clamp01(adsVisualRecoilMultiplier);
        adsSpreadMultiplier = Mathf.Clamp01(adsSpreadMultiplier);

        // Validate sub-patterns (make sure these structs/classes have Validate methods)
        baseRecoilPattern?.Validate(); // Added null check just in case
        baseSpreadPattern?.Validate(); // Added null check just in case

        // Checks
        if (ammoType == null) Debug.LogWarning($"[{this.name}] Ammo Type is not assigned.", this);

        if (defaultAttachments != null) {
            for (int i = 0; i < defaultAttachments.Count; i++) {
                if (string.IsNullOrEmpty(defaultAttachments[i].mountPointTag)) Debug.LogWarning($"[{this.name}] Default Attachment at index {i} missing Mount Point Tag.", this);
                if (defaultAttachments[i].defaultPrefab == null) Debug.LogWarning($"[{this.name}] Default Attachment at index {i} (Tag: '{defaultAttachments[i].mountPointTag}') missing Default Prefab.", this);
            }
        }
        // --- End Firearm Specific Validation ---
    }

    // --- Placeholder Structs/Classes if not defined elsewhere ---
    // Remove these if you have them defined properly
    // [System.Serializable] public struct RecoilPattern { public void Validate() {} }
    // [System.Serializable] public struct SpreadPattern { public void Validate() {} }

}

// --- Ensure FirearmState exists (Example) ---
// [System.Serializable]
// public class FirearmState : IRuntimeState {
//     public ItemContainer magazine;
//     public ItemContainer attachments;
//     public int durability;
//     public FirearmState(int attachmentSlots, int initialDurability) {
//         magazine = new ItemContainer(1);
//         attachments = new ItemContainer(attachmentSlots);
//         durability = initialDurability;
//     }
// }
// --- End of script: Assets/Logic/Items/Data/Weapons/FirearmItemData.cs ---

// --- Start of script: Assets/Logic/Items/Data/Weapons/WeaponItemData.cs ---
using UnityEngine;

public abstract class WeaponItemData : ItemData
{
    [Header("Generic weapon")]
    public float weight;
}
// --- End of script: Assets/Logic/Items/Data/Weapons/WeaponItemData.cs ---

// --- Start of script: Assets/Logic/Vehicles/Core/Interfaces/IFluidConnector.cs ---
public interface IFluidConnector {
    // Called by a source to push fluid into this connector (which should route it to a container)
    // Returns amount actually transferred.
    float TransferFluidIn(FluidData fluidData, float amountLiters, IFluidConnector sourceConnector);

    // Called by a destination to pull fluid from this connector (which should get it from a container)
    // Returns amount actually transferred and the type of fluid.
    float TransferFluidOut(float requestedAmountLiters, out FluidData fluidTransferred, IFluidConnector destinationConnector);

    bool IsConnected(); // Is this connector currently linked to another?
    ConnectionType GetConnectionType(); // Should return FluidFlow
}
// --- End of script: Assets/Logic/Vehicles/Core/Interfaces/IFluidConnector.cs ---

// --- Start of script: Assets/Logic/Vehicles/Core/Interfaces/IFluidContainer.cs ---
// In Assets/Scripts/Core/Interfaces/IFluidContainer.cs
public interface IFluidContainer {
    FluidData ContainedFluidType { get; } // The type of fluid currently in the container (can be null)
    float CurrentFluidLiters { get; }
    float MaxCapacityLiters { get; }
    float RemainingCapacityLiters { get; }

    /// <summary>
    /// Attempts to add fluid to the container.
    /// </summary>
    /// <param name="fluidData">The type of fluid to add.</param>
    /// <param name="amountLiters">The amount to try and add.</param>
    /// <returns>The amount of fluid actually added (might be less than requested if full or wrong type).</returns>
    float TryAddFluid(FluidData fluidData, float amountLiters);

    /// <summary>
    /// Attempts to remove fluid from the container.
    /// </summary>
    /// <param name="amountLiters">The amount to try and remove.</param>
    /// <returns>The amount of fluid actually removed (might be less than requested if not enough available).</returns>
    float TryRemoveFluid(float amountLiters);

    /// <summary>
    /// Checks if this container can accept the specified fluid type.
    /// </summary>
    bool CanAcceptFluidType(FluidData fluidData);
}
// --- End of script: Assets/Logic/Vehicles/Core/Interfaces/IFluidContainer.cs ---

// --- Start of script: Assets/Logic/Vehicles/Core/Interfaces/IGrabbable.cs ---
// In Assets/Scripts/Core/Interfaces/IGrabbable.cs
using UnityEngine;

/// <summary>
/// Interface for objects in the world that can be picked up and manipulated by the player's hands
/// or potentially other interaction systems.
/// </summary>
public interface IGrabbable {
    /// <summary>
    /// The InventoryItem data (static definition + runtime state) associated with this grabbable object.
    /// </summary>
    InventoryItem GetInventoryItemData();

    /// <summary>
    /// The Transform of the GameObject representing this grabbable object in the world.
    /// </summary>
    Transform GetTransform();

    /// <summary>
    /// Called when the player successfully starts grabbing this object.
    /// The object should disable its physics simulation (make Rigidbody kinematic, disable colliders).
    /// </summary>
    /// <param name="grabberTransform">The transform that is now holding this object (e.g., player's handHoldPoint).</param>
    void OnGrabbed(Transform grabberTransform);

    /// <summary>
    /// Called when the player drops this object.
    /// The object should re-enable its physics simulation.
    /// </summary>
    /// <param name="dropVelocity">Optional velocity to apply when dropped.</param>
    void OnDropped(Vector3 dropVelocity);

    /// <summary>
    /// Called just before the object's GameObject is destroyed because it was successfully stored in an inventory.
    /// Allows for any final cleanup if needed.
    /// </summary>
    void OnStored();

    /// <summary>
    /// Can this item currently be grabbed? (e.g., not bolted down, not too heavy without tool)
    /// </summary>
    bool CanGrab(); // Added for checking pre-grab conditions
}
// --- End of script: Assets/Logic/Vehicles/Core/Interfaces/IGrabbable.cs ---

// --- Start of script: Assets/Logic/Vehicles/Core/Interfaces/IRotationReceiver.cs ---
public interface IRotationReceiver {
    // Informs the receiver about the RPM of the source it's connected to.
    void SetInputRPM(float inputRpm);
}
// --- End of script: Assets/Logic/Vehicles/Core/Interfaces/IRotationReceiver.cs ---

// --- Start of script: Assets/Logic/Vehicles/Core/Interfaces/ITorqueProvider.cs ---
public interface ITorqueProvider {
    /// <summary>
    /// Gets the amount of torque this provider is currently making available at its output.
    /// This is the torque *before* considering the immediate load from the connected receiver,
    /// but it should be calculated based on the provider's own internal state (e.g., engine RPM, throttle).
    /// </summary>
    /// <param name="outputRpmAtSource">The RPM at which this torque is being provided by the source.</param>
    /// <returns>The available torque in Newton-meters (Nm).</returns>
    float GetAvailableTorque(out float outputRpmAtSource);
}
// --- End of script: Assets/Logic/Vehicles/Core/Interfaces/ITorqueProvider.cs ---

// --- Start of script: Assets/Logic/Vehicles/Core/Interfaces/ITorqueReceiver.cs ---
// In Assets/Scripts/Core/Interfaces/ITorqueReceiver.cs
public interface ITorqueReceiver {
    /// <summary>
    /// Called by an upstream ITorqueProvider to deliver torque and its source RPM to this receiver.
    /// The receiver will use this information to update its own state or pass torque further downstream.
    /// </summary>
    /// <param name="torqueNm">The amount of torque being applied to this receiver's input (in Newton-meters).</param>
    /// <param name="sourceOutputRpm">The RPM of the ITorqueProvider's output shaft that is delivering this torque.</param>
    void ApplyReceivedTorque(float torqueNm, float sourceOutputRpm);

    /// <summary>
    /// Calculates and returns the total resistive load torque that this receiver
    /// (and any components connected downstream from it) imposes back onto the
    /// ITorqueProvider connected to its input. This includes internal friction,
    /// inertia effects, and loads from further downstream parts, all reflected
    /// to this receiver's input shaft.
    /// </summary>
    /// <returns>The imposed load torque in Newton-meters (Nm).</returns>
    float GetImposedLoadTorque();

    /// <summary>
    /// Gets the current rotational speed (RPM) of this receiver's input shaft.
    /// This RPM is typically influenced by the ITorqueProvider it's connected to
    /// (e.g., an engine forces a gearbox's input RPM) or by downstream components
    /// if the connection allows slip or is coasting (e.g. wheels driving the engine during engine braking).
    /// </summary>
    /// <returns>The current RPM of the input shaft.</returns>
    float GetCurrentInputRPM();
}
// --- End of script: Assets/Logic/Vehicles/Core/Interfaces/ITorqueReceiver.cs ---

// --- Start of script: Assets/Logic/Vehicles/Parts/Data/CarPartData.cs ---
using UnityEngine;
using System.Collections.Generic;

// Base CarPartData remains largely the same, just ensure it aligns.
public abstract class CarPartData : ItemData {
    [Header("Car Part General Stats")]
    public float baseMaxDurability = 100f;
    public PartType partTypeEnum;

    [Header("Mounting Points Provided by this Part")]
    public List<MountPointDefinition> providedMountPoints;

    public abstract IPartRuntimeState CreateDefaultRuntimeState();

    protected override void OnValidate() {
        base.OnValidate();
        this.category = ItemCategory.CarPart;
        this.stackable = false;
        this.maxStack = 1;
        // Derived classes (like EngineData) should set 'isBulky = true;' if appropriate.
        // worldPrefab on CarPartData should point to the prefab containing the PartInstance-derived script.
        if (this.worldPrefab != null && this.worldPrefab.GetComponent<PartInstance>() == null) {
            Debug.LogWarning($"CarPartData '{this.name}' has a worldPrefab '{this.worldPrefab.name}' that is missing a PartInstance-derived component. This is usually incorrect.", this.worldPrefab);
        }
    }
}
// --- End of script: Assets/Logic/Vehicles/Parts/Data/CarPartData.cs ---

// --- Start of script: Assets/Logic/Vehicles/Parts/Data/EngineData.cs ---
// In Assets/Scripts/Parts/Data/EngineData.cs
using UnityEngine;

[CreateAssetMenu(fileName = "NewEngineData", menuName = "Parts/Data/Engine")]
public class EngineData : CarPartData {
    [Header("Engine Performance")]
    public AnimationCurve torqueCurveNmVsRPM; // X-axis: RPM, Y-axis: Torque (Nm)
    public float maxRPM = 7000f;
    public float idleRPM = 800f;
    public float inertiaKgM2 = 0.5f; // Rotational inertia

    [Header("Engine Requirements & Capacities")]
    public float fuelConsumptionLitersPerFixedTickAtFullLoad = 0.01f; // Tune this!
    public float oilCapacityLiters = 5.0f;
    public float coolantCapacityLiters = 7.0f; // If engine block directly holds coolant
    public float idealOperatingTemperatureCelsius = 90f;
    public float overheatTemperatureCelsius = 120f;

    [Header("Mount Points (IDs from providedMountPoints)")]
    [Tooltip("ID of the MountPointDefinition that serves as the main power output.")]
    public string engineOutputShaftMountID = "EngineOutput";
    // Add more for oil filter, spark plugs, exhaust manifold, intake, etc. if needed by specific systems

    public override IPartRuntimeState CreateDefaultRuntimeState() {
        return new EngineRuntimeState {
            CurrentDurability = this.baseMaxDurability,
            CurrentWear = 0f,
            currentEngineOilLiters = 0f, // Start empty or full?
            currentCoolantLiters = 0f
        };
    }

    protected override void OnValidate() {
        base.OnValidate();
        this.partTypeEnum = PartType.Engine;
        //this.isBulky = true; // Engines are bulky
        if (string.IsNullOrEmpty(this.itemName)) this.itemName = "Engine Block";
    }
}
// --- End of script: Assets/Logic/Vehicles/Parts/Data/EngineData.cs ---

// --- Start of script: Assets/Logic/Vehicles/Parts/Data/FuelTankData.cs ---
using UnityEngine;

[CreateAssetMenu(fileName = "NewFuelTankData", menuName = "Parts/Data/Fuel Tank")]
public class FuelTankData : CarPartData {
    [Header("Fuel Tank Properties")]
    public float capacityLiters = 50f;
    public FluidData acceptedFuelType; // Reference to a FluidData ScriptableObject

    [Header("Mount Points (IDs from providedMountPoints)")]
    public string fuelOutletMountID = "FuelOutlet";
    public string fuelFillerMountID = "FuelFillerCap";

    public override IPartRuntimeState CreateDefaultRuntimeState() {
        return new FluidContainerRuntimeState { CurrentDurability = this.baseMaxDurability, CurrentWear = 0f, capacityLiters = this.capacityLiters };
    }
    protected override void OnValidate() {
        base.OnValidate();
        this.partTypeEnum = PartType.FuelTank;
        if (string.IsNullOrEmpty(this.itemName)) this.itemName = "Fuel Tank";
    }
}
// --- End of script: Assets/Logic/Vehicles/Parts/Data/FuelTankData.cs ---

// --- Start of script: Assets/Logic/Vehicles/Parts/Data/GearboxData.cs ---
using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "NewGearboxData", menuName = "Parts/Data/Gearbox")]
public class GearboxData : CarPartData {
    [Header("Gearbox Properties")]
    // --- MAKE SURE THIS IS SPELLED CORRECTLY ---
    public List<float> forwardGearRatios; // e.g., [2.97, 2.07, 1.43, 1.00, 0.84]
    // --- END CHECK ---
    public float reverseGearRatio = -2.5f;
    public float finalDriveRatio = 3.42f;
    [Range(0.5f, 1.0f)] public float efficiency = 0.95f;
    public float shiftTimeSeconds = 0.2f;

    [Header("Mount Points (IDs from providedMountPoints)")]
    public string inputShaftMountID = "GearboxInput";
    public string outputShaftMountID = "GearboxOutput";

    public override IPartRuntimeState CreateDefaultRuntimeState() {
        return new GearboxRuntimeState { /* Default values */ };
    }
    protected override void OnValidate() { /* ... */ }
}
// --- End of script: Assets/Logic/Vehicles/Parts/Data/GearboxData.cs ---

// --- Start of script: Assets/Logic/Vehicles/Parts/Data/MountPointDefinition.cs ---
using UnityEngine;
using System.Collections.Generic;

[System.Serializable]
public class MountPointDefinition {
    [Tooltip("Unique ID for this mount point within its parent PartData (e.g., 'EngineOutput', 'WheelHub_FL')")]
    public string mountPointID;
    public Vector3 localPosition = Vector3.zero;
    public Quaternion localRotation = Quaternion.identity;

    [Tooltip("What PartType(s) can attach to this mount point. Leave empty to accept any (not recommended).")]
    public List<PartType> acceptedPartTypes = new List<PartType>();

    [Tooltip("Optional: List of C# interface names (e.g., 'ITorqueReceiver') that the attaching part's PartInstance must implement.")]
    public List<string> requiredInterfaces = new List<string>(); // For runtime checking

    public ConnectionType connectionType = ConnectionType.Structural; // Enum for type of connection

    // Optional: Visual representation for the editor or debugging
    public float gizmoRadius = 0.05f;
    public Color gizmoColor = Color.cyan;
}

// Define these enums in a shared file like Utilities/Enums.cs or directly here if only used by MountPointDefinition
public enum PartType { // Add all your part types
    Undefined, Chassis, Engine, Gearbox, Wheel, FuelTank, Radiator, Turbo,
    Exhaust, Intake, Battery, Alternator, Suspension, Differential, Seat, Door, Hood, Trunk,
    FluidHose, WiringHarness, Structural // ... and so on
}

public enum ConnectionType {
    Structural,         // Just physical attachment
    PowerTransmission,  // Torque/RPM
    FluidFlow,          // Coolant, Fuel, Oil
    ElectricalSignal,   // For sensors, ECU, lights
    MechanicalLinkage,  // Shifter, throttle cable (if physical)
    Generic
}
// --- End of script: Assets/Logic/Vehicles/Parts/Data/MountPointDefinition.cs ---

// --- Start of script: Assets/Logic/Vehicles/Parts/Data/WheelData.cs ---
// In Assets/Scripts/Parts/Data/WheelData.cs
using UnityEngine;

[CreateAssetMenu(fileName = "NewWheelData", menuName = "Parts/Data/Wheel")]
public class WheelData : CarPartData {
    [Header("Wheel & Tire Properties")]
    public float radiusMetres = 0.3f;
    // public float tireWidthMetres = 0.205f; // For more advanced grip models
    public float inertiaKgM2 = 1.0f; // Rotational inertia of wheel/tire assembly
    public float rollingResistanceCoefficient = 0.015f;
    public float maxBrakeTorqueNm = 2000f;
    public float maxSteerAngleDegrees = 35f; // Only if this wheel is steerable
    public bool isSteerable = false;
    public bool isDriven = true; // Can this wheel receive power?

    [Header("Mount Points (IDs from providedMountPoints)")]
    public string axleInputMountID = "WheelHub"; // Where it connects to axle/differential

    public override IPartRuntimeState CreateDefaultRuntimeState() {
        return new WheelRuntimeState { CurrentDurability = this.baseMaxDurability, CurrentWear = 0f, tirePressurePsi = 32f };
    }

    protected override void OnValidate() {
        base.OnValidate();
        this.partTypeEnum = PartType.Wheel;
        if (string.IsNullOrEmpty(this.itemName)) this.itemName = "Wheel Assembly";
    }
}
// --- End of script: Assets/Logic/Vehicles/Parts/Data/WheelData.cs ---

// --- Start of script: Assets/Logic/Vehicles/Parts/Instances/EngineInstance.cs ---
using UnityEngine;

[RequireComponent(typeof(Rigidbody))]
public class EngineInstance : PartInstance, ITorqueProvider {

    // --- Internal TRANSIENT Simulation Vars ---
    private float _currentRPM_internal_sim = 0f;
    private float _torqueToProvideThisTick = 0f;

    protected override void Awake() {
        base.Awake();
        _currentRPM_internal_sim = 0f;
        _torqueToProvideThisTick = 0f;
    }

    /// <summary>
    /// Initialize: Sets up engine after base setup.
    /// </summary>
    public override void Initialize(InventoryItem itemInstance, VehicleRoot vehicleRoot) {
        base.Initialize(itemInstance, vehicleRoot); // Handles ItemInstanceData assignment, validation, base setup
        if (!this.enabled) return; // Check if base init failed

        // --- Engine Specific Transient Setup ---
        EngineRuntimeState engineState = GetRuntimeState<EngineRuntimeState>();
        EngineData engineData = GetItemData<EngineData>(); // Correct method name

        if (engineState != null && engineData != null) {
            _currentRPM_internal_sim = engineState.isSeized ? 0f : Mathf.Max(0, engineData.idleRPM * 0.8f);
        } else {
             // Base Initialize should have already disabled if state/data was critically missing
             Debug.LogError($"[{gameObject.name}] EngineInstance Initialize: Missing required state/data after base init!", this);
             this.enabled = false; // Ensure disable
        }
        _torqueToProvideThisTick = 0f;
        // --- End Engine Specific Setup ---
    }

    // InitializeTransientState REMOVED

    protected override void UpdateInventoryItemRuntimeState() {
        // base.UpdateInventoryItemRuntimeState(); // If base managed durability in state obj
        if (GetRuntimeState<EngineRuntimeState>() == null) { /* Log Error */ }
        // Sync back any locally cached values if they existed
    }

    public override void PrePhysicsSimulateTick(float deltaTime) {
        EngineData engineData = GetItemData<EngineData>(); // Correct method name
        EngineRuntimeState engineState = GetRuntimeState<EngineRuntimeState>();
        if (engineData == null || engineState == null) { return; }
        // ... (Simulation logic reading/writing 'engineState' fields) ...
    }

    public float GetAvailableTorque(out float outputRpm) {
        outputRpm = _currentRPM_internal_sim;
        EngineRuntimeState engineState = GetRuntimeState<EngineRuntimeState>();
        if (engineState == null || engineState.isSeized) return 0f;
        EngineData engineData = GetItemData<EngineData>(); // Correct method name
        if (engineData == null) { outputRpm = 0f; return 0f; }
        bool isEffectivelyRunning = _currentRPM_internal_sim >= engineData.idleRPM * 0.85f;
        return isEffectivelyRunning ? _torqueToProvideThisTick : 0f;
    }
}
// --- End of script: Assets/Logic/Vehicles/Parts/Instances/EngineInstance.cs ---

// --- Start of script: Assets/Logic/Vehicles/Parts/Instances/GearboxInstance.cs ---
using UnityEngine;

public class GearboxInstance : PartInstance, ITorqueReceiver, ITorqueProvider {

    // --- Internal TRANSIENT Simulation Vars ---
    private float _inputRPM_sim = 0f;
    private float _torqueAppliedBySource_sim = 0f;
    private float _outputRPM_sim = 0f;
    private float _torqueToProvide_sim = 0f;
    private float _currentTotalRatio = 0f;
    private bool _isCurrentlyShifting_internal = false;
    private float _shiftTimer_internal = 0f;

    protected override void Awake() {
        base.Awake();
        // Initialize transient vars
        _inputRPM_sim = 0f; _torqueAppliedBySource_sim = 0f; _outputRPM_sim = 0f;
        _torqueToProvide_sim = 0f; _currentTotalRatio = 0f;
        _isCurrentlyShifting_internal = false; _shiftTimer_internal = 0f;
    }

    /// <summary>
    /// Initialize: Sets up gearbox after base setup.
    /// </summary>
    public override void Initialize(InventoryItem itemInstance, VehicleRoot vehicleRoot) {
        base.Initialize(itemInstance, vehicleRoot);
        if (!this.enabled) return;

        // --- Gearbox Specific Transient Setup ---
        _isCurrentlyShifting_internal = false; // Reset transient shift state
        _shiftTimer_internal = 0f;
        // Reset transient calculation vars explicitly? (Awake already does this)
        // _inputRPM_sim = 0f; _torqueAppliedBySource_sim = 0f; etc.
        CalculateCurrentTotalRatio(); // Calculate initial ratio based on loaded persistent gear state
        // --- End Gearbox Specific Setup ---
    }

    // InitializeTransientState REMOVED

    protected override void UpdateInventoryItemRuntimeState() {
        // base.UpdateInventoryItemRuntimeState(); // If base manages state
        if (GetRuntimeState<GearboxRuntimeState>() == null) { /* Log Error */ }
    }

    public override void PrePhysicsSimulateTick(float deltaTime) {
        GearboxData gearboxData = GetItemData<GearboxData>(); // Corrected
        GearboxRuntimeState gearboxState = GetRuntimeState<GearboxRuntimeState>();
        if (gearboxData == null || gearboxState == null || OwningVehicle == null) { return; }
        // ... (Shift logic reading/writing gearboxState.currentGear, using internal shift vars) ...
        // ... (Torque calculation reads gearboxState.currentGear via CalculateCurrentTotalRatio) ...
        // ... (Wear update writing gearboxState.CurrentWear) ...
    }

    private void CalculateCurrentTotalRatio() {
        GearboxData gearboxData = GetItemData<GearboxData>(); // Corrected
        GearboxRuntimeState gearboxState = GetRuntimeState<GearboxRuntimeState>();
        if (gearboxData == null || gearboxState == null) { _currentTotalRatio = 0; return; }
        int gear = gearboxState.currentGear; float selectedGearRatio = 0f;
        if (gear == 0) { selectedGearRatio = 0; } else if (gear < 0) { selectedGearRatio = gearboxData.reverseGearRatio; } else if (gear > 0 && gear <= gearboxData.forwardGearRatios.Count) { selectedGearRatio = gearboxData.forwardGearRatios[gear - 1]; } else { gearboxState.currentGear = 0; selectedGearRatio = 0; }
        _currentTotalRatio = selectedGearRatio * gearboxData.finalDriveRatio;
    }

    #region ITorqueReceiver Implementation (Corrected Return Paths)
    public void ApplyReceivedTorque(float torque, float sourceOutputRpm) { _torqueAppliedBySource_sim = torque; _inputRPM_sim = sourceOutputRpm; }
    public float GetImposedLoadTorque() {
        GearboxData gearboxData = GetItemData<GearboxData>(); // Corrected
        GearboxRuntimeState gearboxState = GetRuntimeState<GearboxRuntimeState>();
        if (gearboxData == null || gearboxState == null || _isCurrentlyShifting_internal || gearboxState.currentGear == 0 || Mathf.Abs(_currentTotalRatio) < 0.001f) { return 0f; } // RETURN
        ITorqueReceiver downstream = GetConnectedPartViaInterface<ITorqueReceiver>(gearboxData.outputShaftMountID); float loadDown = (downstream != null) ? downstream.GetImposedLoadTorque() : 0f;
        float reflectedLoad = (loadDown / _currentTotalRatio) / gearboxData.efficiency; float internalLoad = 5.0f;
        return reflectedLoad + internalLoad; // RETURN
    }
    public float GetCurrentInputRPM() { return _inputRPM_sim; } // RETURN
    #endregion

    #region ITorqueProvider Implementation (Corrected Return Paths/Out Param)
    public float GetAvailableTorque(out float outputRpmAtSource) {
        outputRpmAtSource = _outputRPM_sim; // Assign unconditionally
        GearboxRuntimeState gearboxState = GetRuntimeState<GearboxRuntimeState>();
        if (_isCurrentlyShifting_internal || gearboxState == null || gearboxState.currentGear == 0) {
            outputRpmAtSource = 0f; // Ensure RPM is 0
            return 0f; // RETURN
        }
        return _torqueToProvide_sim; // RETURN
    }
    #endregion
}
// --- End of script: Assets/Logic/Vehicles/Parts/Instances/GearboxInstance.cs ---

// --- Start of script: Assets/Logic/Vehicles/Parts/RuntimeStates/EngineRuntimeState.cs ---
using UnityEngine;

[System.Serializable]
public class EngineRuntimeState : IPartRuntimeState { // Implements IPartRuntimeState (which includes ICloneableRuntimeState)

    [field: SerializeField] [field: Range(0f, 100f)]
    public float CurrentDurability { get; set; } = 100f;

    [field: SerializeField] [field: Range(0f, 1f)]
    public float CurrentWear { get; set; } = 0f;

    [SerializeField] public float currentEngineOilLiters = 0f;
    [SerializeField] public float currentCoolantLiters = 0f;
    [SerializeField] public float totalOperatingHours = 0f;
    [SerializeField] public bool isSeized = false;
    [SerializeField] public float currentTemperatureCelsius = 15f;

    public EngineRuntimeState() { } // Needed for serialization

    public IRuntimeState Clone() {
        // Manual field-by-field clone
        return new EngineRuntimeState {
            CurrentDurability = this.CurrentDurability, CurrentWear = this.CurrentWear,
            currentEngineOilLiters = this.currentEngineOilLiters, currentCoolantLiters = this.currentCoolantLiters,
            totalOperatingHours = this.totalOperatingHours, isSeized = this.isSeized,
            currentTemperatureCelsius = this.currentTemperatureCelsius
        };
    }
}
// --- End of script: Assets/Logic/Vehicles/Parts/RuntimeStates/EngineRuntimeState.cs ---

// --- Start of script: Assets/Logic/Vehicles/Parts/RuntimeStates/FluidContainerRuntimeState.cs ---
// In Assets/Scripts/Parts/RuntimeStates/FluidContainerRuntimeState.cs
[System.Serializable]
public class FluidContainerRuntimeState : IPartRuntimeState {
    public float CurrentDurability { get; set; }
    public float CurrentWear { get; set; }
    public float currentFluidLiters { get; set; }
    public string currentFluidID; // Stores itemCode of the FluidData SO if needed
    public float capacityLiters; // Often set from definition, but could be dynamic

    public FluidContainerRuntimeState() { /* Default constructor */ }
}
// --- End of script: Assets/Logic/Vehicles/Parts/RuntimeStates/FluidContainerRuntimeState.cs ---

// --- Start of script: Assets/Logic/Vehicles/Parts/RuntimeStates/GearboxRuntimeState.cs ---
using UnityEngine;

/// <summary>
/// Runtime state for a Gearbox part. Implements cloning for use with spawners.
/// </summary>
[System.Serializable]
public class GearboxRuntimeState : IPartRuntimeState, ICloneableRuntimeState { // Added ICloneableRuntimeState

    // --- IPartRuntimeState Implementation ---
    [field: SerializeField] [field: Range(0f, 100f)]
    public float CurrentDurability { get; set; } = 100f;

    [field: SerializeField] [field: Range(0f, 1f)]
    public float CurrentWear { get; set; } = 0f;

    // --- Gearbox Specific State ---
    [SerializeField] public int currentGear = 0; // 0 for Neutral
    // Shift state is transient, typically not saved/cloned
    // [SerializeField] public bool isShifting = false;
    // [SerializeField] public float shiftTimer = 0f;

    // Default constructor
    public GearboxRuntimeState() { }

    // --- ICloneableRuntimeState Implementation ---
    /// <summary>
    /// Creates a shallow clone using MemberwiseClone. Safe here because all persistent fields are value types.
    /// </summary>
    /// <returns>A new IRuntimeState object containing a copy of the data.</returns>
    public IRuntimeState Clone() {
        // MemberwiseClone creates a new object and copies value-type fields.
        // If you later add reference types (like ItemContainer), you MUST implement deep cloning here.
        return this.MemberwiseClone() as IRuntimeState;
    }
    // --- End ICloneableRuntimeState ---
}
// --- End of script: Assets/Logic/Vehicles/Parts/RuntimeStates/GearboxRuntimeState.cs ---

// --- Start of script: Assets/Logic/Vehicles/Parts/RuntimeStates/IPartRuntimeState.cs ---
// In Assets/Scripts/Parts/RuntimeStates/IPartRuntimeState.cs
public interface IPartRuntimeState : IRuntimeState { // Your existing IRuntimeState
    float CurrentDurability { get; set; }
    float CurrentWear { get; set; } // Normalized 0 (new) to 1 (fully worn)
}
// --- End of script: Assets/Logic/Vehicles/Parts/RuntimeStates/IPartRuntimeState.cs ---

// --- Start of script: Assets/Logic/Vehicles/Parts/RuntimeStates/WheelRuntimeState.cs ---
// In Assets/Scripts/Parts/RuntimeStates/WheelRuntimeState.cs
[System.Serializable]
public class WheelRuntimeState : IPartRuntimeState {
    public float CurrentDurability { get; set; } // For rim/bearing integrity
    public float CurrentWear { get; set; } // For tire tread
    public float tirePressurePsi { get; set; }
    public bool isPunctured { get; set; }

    public WheelRuntimeState() { /* Default constructor */ }
}
// --- End of script: Assets/Logic/Vehicles/Parts/RuntimeStates/WheelRuntimeState.cs ---

// --- Start of script: Assets/Logic/Vehicles/Simulation/Fluids/FluidData.cs ---
// In Assets/Scripts/Simulation/Fluids/FluidData.cs
using UnityEngine;

[CreateAssetMenu(fileName = "NewFluidData", menuName = "Simulation/Fluid Data")]
public class FluidData : ScriptableObject { // Note: Not ItemData unless fluids are individually inventoryable items
    public string fluidID; // e.g., "gasoline95", "engine_oil_10w40", "standard_coolant"
    public string displayName;
    public Color visualColor = Color.grey; // For debug or visual representation
    public float densityKgPerLiter = 0.75f; // Example for gasoline
    // Add other properties: viscosity, flammability, freezingPoint, boilingPoint etc.
}
// --- End of script: Assets/Logic/Vehicles/Simulation/Fluids/FluidData.cs ---

// --- Start of script: Assets/Logic/Items/Behaviours/Firearms/Pistol/PistolBehavior.cs ---
using UnityEngine;

public class PistolBehavior : FirearmBehavior
{
    protected override void Awake()
    {
        base.Awake();
    }
}
// --- End of script: Assets/Logic/Items/Behaviours/Firearms/Pistol/PistolBehavior.cs ---

